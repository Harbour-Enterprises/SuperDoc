var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value) =>
  key2 in obj
    ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key2] = value);
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== 'symbol' ? key2 + '' : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError('Cannot ' + msg);
var __privateGet = (obj, member, getter) => (
  __accessCheck(obj, member, 'read from private field'), getter ? getter.call(obj) : member.get(obj)
);
var __privateAdd = (obj, member, value) =>
  member.has(obj)
    ? __typeError('Cannot add the same private member more than once')
    : member instanceof WeakSet
      ? member.add(obj)
      : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (
  __accessCheck(obj, member, 'write to private field'), setter ? setter.call(obj, value) : member.set(obj, value), value
);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, 'access private method'), method);
var _Attribute_static,
  getGlobalAttributes_fn,
  getNodeAndMarksAttributes_fn,
  _Schema_static,
  createNodesSchema_fn,
  createMarksSchema_fn,
  _DocxExporter_instances,
  generate_xml_as_list_fn,
  replaceSpecialCharacters_fn,
  generateXml_fn,
  _SuperConverter_instances,
  generateDocumentHash_fn,
  exportNumberingFile_fn,
  prepareCommentsXmlFilesForExport_fn,
  exportProcessHeadersFooters_fn,
  exportProcessNewRelationships_fn,
  exportProcessMediaFiles_fn,
  _events,
  _ExtensionService_instances,
  setupExtensions_fn,
  attachEditorEvents_fn,
  _editor,
  _stateValidators,
  _xmlValidators,
  _requiredNodeTypes,
  _requiredMarkTypes,
  _SuperValidator_instances,
  initializeValidators_fn,
  collectValidatorRequirements_fn,
  analyzeDocument_fn,
  _commandService,
  _Editor_instances,
  initContainerElement_fn,
  init_fn,
  initRichText_fn,
  onFocus_fn,
  checkHeadless_fn,
  registerCopyHandler_fn,
  insertNewFileData_fn,
  createExtensionService_fn,
  createCommandService_fn,
  createConverter_fn,
  initMedia_fn,
  initFonts_fn,
  checkFonts_fn,
  determineUnsupportedFonts_fn,
  createSchema_fn,
  generatePmData_fn,
  createView_fn,
  onCollaborationReady_fn,
  initComments_fn,
  initPagination_fn,
  dispatchTransaction_fn,
  handleNodeSelection_fn,
  prepareDocumentForImport_fn,
  prepareDocumentForExport_fn,
  endCollaboration_fn,
  validateDocumentInit_fn,
  validateDocumentExport_fn,
  initDevTools_fn,
  _DocumentSectionView_instances,
  init_fn2,
  addToolTip_fn,
  _ListItemNodeView_instances,
  init_fn3,
  applyIndentStyling_fn,
  _FieldAnnotationView_instances,
  createAnnotation_fn,
  _AutoPageNumberNodeView_instances,
  renderDom_fn,
  scheduleUpdateNodeStyle_fn;
import { redo as redo$1, undo as undo$1, history } from 'prosemirror-history';
import {
  redo,
  undo,
  yUndoPlugin,
  ySyncPlugin,
  prosemirrorToYDoc,
  yXmlFragmentToProseMirrorRootNode,
  yCursorPlugin,
} from 'y-prosemirror';
import { Schema as Schema$1, DOMParser as DOMParser$1, DOMSerializer, Fragment, Slice } from 'prosemirror-model';
import xmljs from 'xml-js';
import { v4 } from 'uuid';
import crc32 from 'buffer-crc32';
import { TextSelection, Plugin, PluginKey, EditorState, NodeSelection, Selection } from 'prosemirror-state';
import { marked } from 'marked';
import he from 'he';
import {
  canSplit,
  liftTarget,
  ReplaceStep,
  ReplaceAroundStep as ReplaceAroundStep$1,
  Mapping,
  AddMarkStep,
  RemoveMarkStep,
} from 'prosemirror-transform';
import {
  liftEmptyBlock as liftEmptyBlock$1,
  createParagraphNear as createParagraphNear$1,
  newlineInCode as newlineInCode$1,
  exitCode as exitCode$1,
  setBlockType,
  selectAll as selectAll$1,
  deleteSelection as deleteSelection$1,
  joinUp as joinUp$1,
  joinDown as joinDown$1,
  joinBackward as joinBackward$1,
  joinForward as joinForward$1,
  selectNodeBackward as selectNodeBackward$1,
  selectNodeForward as selectNodeForward$1,
  selectTextblockStart as selectTextblockStart$1,
  selectTextblockEnd as selectTextblockEnd$1,
  splitBlock as splitBlock$1,
} from 'prosemirror-commands';
import {
  wrapInList as wrapInList$1,
  sinkListItem as sinkListItem$1,
  liftListItem as liftListItem$1,
} from 'prosemirror-schema-list';
import { DecorationSet, Decoration, EditorView } from 'prosemirror-view';
import { keymap } from 'prosemirror-keymap';
import JSZip from 'jszip';
import { gapCursor } from 'prosemirror-gapcursor';
import {
  CellSelection,
  TableMap,
  columnResizing,
  tableEditing,
  fixTables,
  goToNextCell,
  setCellAttr,
  toggleHeaderCell,
  toggleHeader,
  mergeCells,
  selectedRect,
  splitCell,
  deleteRow,
  addRowAfter,
  addRowBefore,
  deleteColumn,
  addColumnAfter,
  addColumnBefore,
  deleteTable,
  tableNodeTypes,
} from 'prosemirror-tables';
import {
  ref,
  computed,
  createElementBlock,
  openBlock,
  withModifiers,
  Fragment as Fragment$1,
  renderList,
  normalizeClass,
  createCommentVNode,
  toDisplayString,
  createElementVNode,
  createApp,
} from 'vue';
import tippy from 'tippy.js';
import { autoUpdate, computePosition, hide } from '@floating-ui/dom';
import { toHex } from 'color2k';
import { dropCursor } from 'prosemirror-dropcursor';
import { encodeStateAsUpdate } from 'yjs';
function getExtensionConfigField(extension, field, context = {}) {
  if (typeof extension.config[field] === 'function') {
    const value = extension.config[field].bind({ ...context });
    return value;
  }
  return extension.config[field];
}
function callOrGet(value, context = null, ...props) {
  if (typeof value === 'function') {
    if (context) return value.bind(context)(...props);
    return value(...props);
  }
  return value;
}
class Extension {
  constructor(config2) {
    __publicField(this, 'type', 'extension');
    __publicField(this, 'name', 'extension');
    __publicField(this, 'options');
    __publicField(this, 'storage');
    __publicField(this, 'config', {
      name: this.name,
    });
    this.config = {
      ...this.config,
      ...config2,
    };
    this.name = this.config.name;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, 'addOptions', {
          name: this.name,
        }),
      );
    }
    this.storage =
      callOrGet(
        getExtensionConfigField(this, 'addStorage', {
          name: this.name,
          options: this.options,
        }),
      ) || {};
  }
  /**
   * Static method for creating an extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Extension(...args);
  }
}
const History = Extension.create({
  name: 'history',
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500,
    };
  },
  addPmPlugins() {
    if (this.editor.options.collaborationProvider && this.editor.options.ydoc) {
      const undoPlugin = createUndoPlugin();
      return [undoPlugin];
    }
    const historyPlugin = history(this.options);
    return [historyPlugin];
  },
  //prettier-ignore
  addCommands() {
    return {
      /**
       * Undo the last action
       * @category Command
       * @example
       * editor.commands.undo()
       * @note Groups changes within the newGroupDelay window
       */
      undo: () => ({ state, dispatch, tr }) => {
        if (this.editor.options.collaborationProvider && this.editor.options.ydoc) {
          tr.setMeta("preventDispatch", true);
          return undo(state);
        }
        tr.setMeta("inputType", "historyUndo");
        return undo$1(state, dispatch);
      },
      /**
       * Redo the last undone action
       * @category Command
       * @example
       * editor.commands.redo()
       * @note Only available after an undo action
       */
      redo: () => ({ state, dispatch, tr }) => {
        if (this.editor.options.collaborationProvider && this.editor.options.ydoc) {
          tr.setMeta("preventDispatch", true);
          return redo(state);
        }
        tr.setMeta("inputType", "historyRedo");
        return redo$1(state, dispatch);
      }
    };
  },
  addShortcuts() {
    return {
      'Mod-z': () => this.editor.commands.undo(),
      'Mod-Shift-z': () => this.editor.commands.redo(),
      'Mod-y': () => this.editor.commands.redo(),
    };
  },
});
const createUndoPlugin = () => {
  const yUndoPluginInstance = yUndoPlugin();
  return yUndoPluginInstance;
};
let Node$1 = class Node2 {
  /**
   * @param {import('./types/index.js').EditorNodeConfig} config
   */
  constructor(config2) {
    /** @type {import('prosemirror-model').NodeType | String} */
    __publicField(this, 'type', 'node');
    /** @type {string} */
    __publicField(this, 'name', 'node');
    /** @type {import('./types/index.js').EditorNodeOptions} */
    __publicField(this, 'options');
    /** @type {string} */
    __publicField(this, 'group');
    /** @type {boolean} */
    __publicField(this, 'atom');
    /** @type {import('./Editor.js').Editor} */
    __publicField(this, 'editor');
    /** @type {import('./types/index.js').EditorNodeStorage} */
    __publicField(this, 'storage');
    /** @type {import('./types/index.js').EditorNodeConfig} */
    __publicField(this, 'config', {
      name: this.name,
    });
    this.config = {
      ...this.config,
      ...config2,
    };
    this.name = this.config.name;
    this.group = this.config.group;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, 'addOptions', {
          name: this.name,
        }),
      );
    }
    this.storage =
      callOrGet(
        getExtensionConfigField(this, 'addStorage', {
          name: this.name,
          options: this.options,
        }),
      ) || {};
  }
  /**
   * Factory method to construct a new Node extension.
   *
   * @param {import('./types/index.js').EditorNodeConfig} config - The node configuration.
   * @returns {Node} A new Node instance.
   */
  static create(config2) {
    return new Node2(config2);
  }
};
class Mark {
  constructor(config2) {
    __publicField(this, 'type', 'mark');
    __publicField(this, 'name', 'mark');
    __publicField(this, 'options');
    __publicField(this, 'storage');
    __publicField(this, 'isExternal');
    __publicField(this, 'config', {
      name: this.name,
    });
    this.config = {
      ...this.config,
      ...config2,
    };
    this.name = this.config.name;
    this.isExternal = Boolean(this.config.isExternal);
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, 'addOptions', {
          name: this.name,
        }),
      );
    }
    this.storage =
      callOrGet(
        getExtensionConfigField(this, 'addStorage', {
          name: this.name,
          options: this.options,
        }),
      ) || {};
  }
  /**
   * Static method for creating Mark extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Mark(...args);
  }
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === 'string') {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}' in schema.`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === 'string') {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}' in schema.`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) return 'node';
  if (schema.marks[name]) return 'mark';
  return null;
}
function getMarksFromSelection(state) {
  const { from, to, empty } = state.selection;
  const marks = [];
  if (empty) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from, to, (node) => {
      marks.push(...node.marks);
    });
  }
  return marks;
}
class Attribute {
  /**
   * Get a list of all attributes defined in the extensions.
   * @param extensions List of all extensions.
   * @returns Extension attributes.
   */
  static getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderDOM: null,
      parseDOM: null,
      keepOnSplit: true,
    };
    const globalAttributes = __privateMethod(this, _Attribute_static, getGlobalAttributes_fn).call(
      this,
      extensions,
      defaultAttribute,
    );
    const nodeAndMarksAttributes = __privateMethod(this, _Attribute_static, getNodeAndMarksAttributes_fn).call(
      this,
      extensions,
      defaultAttribute,
    );
    extensionAttributes.push(...globalAttributes, ...nodeAndMarksAttributes);
    return extensionAttributes;
  }
  /**
   * Inserts extension attributes into parseRule attributes.
   * @param parseRule PM ParseRule.
   * @param extensionAttrs List of attributes to insert.
   */
  static insertExtensionAttrsToParseRule(parseRule, extensionAttrs) {
    if ('style' in parseRule) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node) => {
        const oldAttrs = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttrs === false) return false;
        const parseFromString = (value) => {
          if (typeof value !== 'string') return value;
          if (value.match(/^[+-]?(\d*\.)?\d+$/)) return Number(value);
          if (value === 'true') return true;
          if (value === 'false') return false;
          return value;
        };
        let newAttrs = {};
        for (const item of extensionAttrs) {
          const value = item.attribute.parseDOM
            ? item.attribute.parseDOM(node)
            : parseFromString(node.getAttribute(item.name));
          if (value === null || value === void 0) continue;
          newAttrs = {
            ...newAttrs,
            [item.name]: value,
          };
        }
        return { ...oldAttrs, ...newAttrs };
      },
    };
  }
  /**
   * Get attributes to render.
   * @param nodeOrMark Node or Mark.
   * @param extensionAttrs Extension attributes.
   */
  static getAttributesToRender(nodeOrMark, extensionAttrs) {
    const attributes = extensionAttrs
      .filter((item) => item.attribute.rendered)
      .map((item) => {
        if (!item.attribute.renderDOM) {
          return { [item.name]: nodeOrMark.attrs[item.name] };
        }
        return item.attribute.renderDOM(nodeOrMark.attrs) || {};
      });
    let mergedAttrs = {};
    for (const attribute of attributes) {
      mergedAttrs = this.mergeAttributes(mergedAttrs, attribute);
    }
    return mergedAttrs;
  }
  /**
   * Merges attributes.
   * @param objects Objects with attributes.
   * @returns Object with merged attributes.
   */
  static mergeAttributes(...objects) {
    const items = objects.filter((item) => !!item);
    let attrs = {};
    for (const item of items) {
      const mergedAttributes = { ...attrs };
      for (const [key2, value] of Object.entries(item)) {
        const exists = mergedAttributes[key2];
        if (!exists) {
          mergedAttributes[key2] = value;
          continue;
        }
        if (key2 === 'class') {
          const valueClasses = value ? value.split(' ') : [];
          const existingClasses = mergedAttributes[key2] ? mergedAttributes[key2].split(' ') : [];
          const insertClasses = valueClasses.filter((value2) => !existingClasses.includes(value2));
          mergedAttributes[key2] = [...existingClasses, ...insertClasses].join(' ');
        } else if (key2 === 'style') {
          mergedAttributes[key2] = [mergedAttributes[key2], value].join('; ');
        } else {
          mergedAttributes[key2] = value;
        }
      }
      attrs = mergedAttributes;
    }
    return attrs;
  }
  /**
   * Get extension attributes that should be splitted by keepOnSplit flag.
   * @param extensionAttrs Array of attributes.
   * @param typeName The type of the extension.
   * @param attributes The extension attributes.
   * @returns The splitted attributes.
   */
  static getSplittedAttributes(extensionAttrs, typeName, attributes) {
    const entries = Object.entries(attributes).filter(([name]) => {
      const extensionAttr = extensionAttrs.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttr) return false;
      return extensionAttr.attribute.keepOnSplit;
    });
    return Object.fromEntries(entries);
  }
  /**
   * Get mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The mark type or name.
   * @returns The mark attrs.
   */
  static getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const marks = getMarksFromSelection(state);
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) return {};
    return { ...mark.attrs };
  }
  /**
   * Get node attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node type or name.
   * @returns The node attrs.
   */
  static getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from, to, (node2) => {
      nodes.push(node2);
    });
    const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node) return {};
    return { ...node.attrs };
  }
  /**
   * Get node or mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node/mark type or name.
   * @returns The attrs of the node/mark or an empty object.
   */
  static getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(
      typeof typeOrName === 'string' ? typeOrName : typeOrName.name,
      state.schema,
    );
    if (schemaType === 'node') {
      return this.getNodeAttributes(state, typeOrName);
    }
    if (schemaType === 'mark') {
      return this.getMarkAttributes(state, typeOrName);
    }
    return {};
  }
}
_Attribute_static = new WeakSet();
getGlobalAttributes_fn = function (extensions, defaultAttribute) {
  const extensionAttributes = [];
  const collectAttribute = (globalAttr) => {
    for (const type of globalAttr.types) {
      const entries = Object.entries(globalAttr.attributes);
      for (const [name, attribute] of entries) {
        extensionAttributes.push({
          type,
          name,
          attribute: {
            ...defaultAttribute,
            ...attribute,
          },
        });
      }
    }
  };
  for (const extension of extensions) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
    };
    const addGlobalAttributes = getExtensionConfigField(extension, 'addGlobalAttributes', context);
    if (!addGlobalAttributes) continue;
    const globalAttributes = addGlobalAttributes();
    for (const globalAttr of globalAttributes) {
      collectAttribute(globalAttr);
    }
  }
  return extensionAttributes;
};
getNodeAndMarksAttributes_fn = function (extensions, defaultAttribute) {
  const extensionAttributes = [];
  const nodeAndMarkExtensions = extensions.filter((e) => {
    return e.type === 'node' || e.type === 'mark';
  });
  for (const extension of nodeAndMarkExtensions) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
    };
    const addAttributes = getExtensionConfigField(extension, 'addAttributes', context);
    if (!addAttributes) continue;
    const attributes = addAttributes();
    for (const [name, attribute] of Object.entries(attributes)) {
      const merged = {
        ...defaultAttribute,
        ...attribute,
      };
      if (typeof merged.default === 'function') {
        merged.default = merged.default();
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: merged,
      });
    }
  }
  return extensionAttributes;
};
__privateAdd(Attribute, _Attribute_static);
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function cleanSchemaItem(schemaItem) {
  const entries = Object.entries(schemaItem).filter(([key2, value]) => {
    if (key2 === 'attrs' && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  });
  return Object.fromEntries(entries);
}
const _Schema = class _Schema {
  /**
   * Creates PM schema by resolved extensions.
   * @param extensions List of extensions.
   * @param editor Editor instance.
   * @returns PM schema
   */
  static createSchemaByExtensions(extensions, editor) {
    var _a, _b;
    const nodeExtensions = extensions.filter((e) => e.type === 'node');
    const markExtensions = extensions.filter((e) => e.type === 'mark');
    const topNode = nodeExtensions.find((e) => getExtensionConfigField(e, 'topNode'))?.name;
    const attributes = Attribute.getAttributesFromExtensions(extensions);
    const nodes = __privateMethod((_a = _Schema), _Schema_static, createNodesSchema_fn).call(
      _a,
      nodeExtensions,
      attributes,
      editor,
    );
    const marks = __privateMethod((_b = _Schema), _Schema_static, createMarksSchema_fn).call(
      _b,
      markExtensions,
      attributes,
      editor,
    );
    return new Schema$1({ topNode, nodes, marks });
  }
};
_Schema_static = new WeakSet();
createNodesSchema_fn = function (nodeExtensions, attributes, editor) {
  const nodeEntries = nodeExtensions.map((extension) => {
    const extensionAttributes = attributes.filter((a) => a.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor,
    };
    const attrs = Object.fromEntries(
      extensionAttributes.map((attr) => {
        return [attr.name, { default: attr?.attribute?.default }];
      }),
    );
    const additionalNodeFields = nodeExtensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionConfigField(e, 'extendNodeSchema', context);
      return {
        ...fields,
        ...(extendNodeSchema ? extendNodeSchema(extension) : {}),
      };
    }, {});
    const schema = cleanSchemaItem({
      content: callOrGet(getExtensionConfigField(extension, 'content', context)),
      group: callOrGet(getExtensionConfigField(extension, 'group', context)),
      marks: callOrGet(getExtensionConfigField(extension, 'marks', context)),
      inline: callOrGet(getExtensionConfigField(extension, 'inline', context)),
      atom: callOrGet(getExtensionConfigField(extension, 'atom', context)),
      selectable: callOrGet(getExtensionConfigField(extension, 'selectable', context)),
      draggable: callOrGet(getExtensionConfigField(extension, 'draggable', context)),
      code: callOrGet(getExtensionConfigField(extension, 'code', context)),
      defining: callOrGet(getExtensionConfigField(extension, 'defining', context)),
      isolating: callOrGet(getExtensionConfigField(extension, 'isolating', context)),
      attrs,
      ...additionalNodeFields,
    });
    if (typeof extension.validChildren === 'function' || Array.isArray(extension.validChildren)) {
      Object.defineProperty(schema, 'validChildren', {
        enumerable: false,
        configurable: false,
        get: () => extension.validChildren,
      });
    }
    const parseDOM = callOrGet(getExtensionConfigField(extension, 'parseDOM', context));
    if (parseDOM) {
      schema.parseDOM = parseDOM.map((parseRule) => {
        return Attribute.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
      });
    }
    const renderDOM = getExtensionConfigField(extension, 'renderDOM', context);
    if (renderDOM) {
      schema.toDOM = (node) =>
        renderDOM({
          node,
          htmlAttributes: Attribute.getAttributesToRender(node, extensionAttributes),
        });
    }
    const renderText = getExtensionConfigField(extension, 'renderText', context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  });
  return Object.fromEntries(nodeEntries);
};
createMarksSchema_fn = function (markExtensions, attributes, editor) {
  const markEntries = markExtensions.map((extension) => {
    const extensionAttributes = attributes.filter((a) => a.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor,
    };
    const attrs = Object.fromEntries(
      extensionAttributes.map((attr) => {
        return [attr.name, { default: attr?.attribute?.default }];
      }),
    );
    const schema = cleanSchemaItem({
      group: callOrGet(getExtensionConfigField(extension, 'group', context)),
      inclusive: callOrGet(getExtensionConfigField(extension, 'inclusive', context)),
      excludes: callOrGet(getExtensionConfigField(extension, 'excludes', context)),
      spanning: callOrGet(getExtensionConfigField(extension, 'spanning', context)),
      code: callOrGet(getExtensionConfigField(extension, 'code', context)),
      attrs,
    });
    const parseDOM = callOrGet(getExtensionConfigField(extension, 'parseDOM', context));
    if (parseDOM) {
      schema.parseDOM = parseDOM.map((parseRule) => {
        return Attribute.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
      });
    }
    const renderDOM = getExtensionConfigField(extension, 'renderDOM', context);
    if (renderDOM) {
      schema.toDOM = (mark) =>
        renderDOM({
          mark,
          htmlAttributes: Attribute.getAttributesToRender(mark, extensionAttributes),
        });
    }
    return [extension.name, schema];
  });
  return Object.fromEntries(markEntries);
};
__privateAdd(_Schema, _Schema_static);
let Schema = _Schema;
function chainableEditorState(transaction, state) {
  let { selection, doc, storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc;
    },
    get tr() {
      selection = transaction.selection;
      doc = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    },
  };
}
class CommandService {
  /**
   * @param {import('./commands/types/index.js').CommandServiceOptions} props
   */
  constructor(props) {
    __publicField(this, 'editor');
    __publicField(this, 'rawCommands');
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionService.commands;
  }
  /**
   * Static method for creating a service.
   * @param {import('./commands/types/index.js').CommandServiceOptions} params for the constructor.
   * @returns {CommandService} New instance of CommandService
   */
  static create(params) {
    return new CommandService(params);
  }
  /**
   * Get editor state.
   * @returns {import("prosemirror-state").EditorState} Editor state
   */
  get state() {
    return this.editor.state;
  }
  /**
   * Get all editor commands
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object
   */
  get commands() {
    const { editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.createProps(tr);
    const entries = Object.entries(this.rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const fn = command2(...args)(props);
        if (!tr.getMeta('preventDispatch')) {
          view.dispatch(tr);
        }
        return fn;
      };
      return [name, method];
    });
    return (
      /** @type {import('./commands/types/index.js').EditorCommands} */
      Object.fromEntries(entries)
    );
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {(startTr?: Transaction, shouldDispatch?: boolean) => ChainableCommandObject} Function that creates a command chain
   */
  get chain() {
    return () => this.createChain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {() => import('./commands/types/index.js').CanObject} Function that creates a can object
   */
  get can() {
    return () => this.createCan();
  }
  /**
   * Creates a chain of commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @param {boolean} [shouldDispatch=true] - Whether to dispatch the transaction.
   * @returns {import('./commands/types/index.js').ChainableCommandObject} The command chain.
   */
  createChain(startTr, shouldDispatch = true) {
    const { editor, state, rawCommands } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTr = !!startTr;
    const tr = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTr && shouldDispatch && !tr.getMeta('preventDispatch')) {
        view.dispatch(tr);
      }
      return callbacks.every((cb) => cb === true);
    };
    const entries = Object.entries(rawCommands).map(([name, command2]) => {
      const chainedCommand = (...args) => {
        const props = this.createProps(tr, shouldDispatch);
        const callback = command2(...args)(props);
        callbacks.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    });
    const chain = {
      ...Object.fromEntries(entries),
      run: run2,
    };
    return chain;
  }
  /**
   * Creates a can check for commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @returns {import('./commands/types/index.js').CanObject} The can object.
   */
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr = startTr || state.tr;
    const props = this.createProps(tr, dispatch);
    const commands2 = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      }),
    );
    const result = {
      ...commands2,
      chain: () => this.createChain(tr, dispatch),
    };
    return (
      /** @type {import('./commands/types/index.js').CanObject} */
      result
    );
  }
  /**
   * Creates default props for the command method.
   * @param {import("prosemirror-state").Transaction} tr Transaction.
   * @param {boolean} shouldDispatch Check if should dispatch.
   * @returns {Object} Props object.
   */
  createProps(tr, shouldDispatch = true) {
    const { editor, state, rawCommands } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: chainableEditorState(tr, state),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          }),
        );
      },
    };
    return props;
  }
}
const isMacOS = () => {
  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
};
const isIOS = () => {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(
    navigator.platform,
  );
};
const isRegExp$1 = (value) => {
  return Object.prototype.toString.call(value) === '[object RegExp]';
};
function objectIncludes(obj1, obj2, options = { strict: true }) {
  const keys = Object.keys(obj2);
  if (!keys.length) return true;
  return keys.every((key2) => {
    if (options.strict) return obj2[key2] === obj1[key2];
    if (isRegExp$1(obj2[key2])) return obj2[key2].test(obj1[key2]);
    return obj2[key2] === obj1[key2];
  });
}
function deleteProps(obj, propOrProps) {
  const isString = typeof propOrProps === 'string';
  const props = isString ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    const contains = props.includes(prop);
    if (!contains) newObj[prop] = obj[prop];
    return newObj;
  }, {});
}
const CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
const DOM_SIZE_UNITS = ['px', 'rem', 'em', 'in', 'q', 'mm', 'cm', 'pt', 'pc', 'vh', 'vw', 'vmin', 'vmax'];
function parseSizeUnit(val = '0') {
  const length = val.toString() || '0';
  const value = Number.parseFloat(length);
  const match = length.match(CSS_DIMENSION_REGEX);
  const unit = (match?.[1] ?? '').toLowerCase();
  return [value, DOM_SIZE_UNITS.includes(unit) ? unit : null];
}
function minMax(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}
const PIXELS_PER_INCH = 96;
function inchesToTwips(inches) {
  if (inches == null) return;
  if (typeof inches === 'string') inches = parseFloat(inches);
  return Math.round(Number(inches) * 1440);
}
function twipsToInches(twips) {
  if (twips == null) return;
  const value = Number(twips);
  if (Number.isNaN(value)) return;
  return value / 1440;
}
function twipsToPixels(twips) {
  if (twips == null) return;
  const inches = twipsToInches(twips);
  return inchesToPixels(inches);
}
function pixelsToTwips(pixels) {
  const inches = pixelsToInches(pixels);
  return inchesToTwips(inches);
}
function inchesToPixels(inches) {
  if (inches == null) return;
  const pixels = inches * PIXELS_PER_INCH;
  return Math.round(pixels * 1e3) / 1e3;
}
function pixelsToInches(pixels) {
  if (pixels == null) return;
  const inches = Number(pixels) / PIXELS_PER_INCH;
  return inches;
}
function twipsToLines(twips) {
  if (twips == null) return;
  return twips / 240;
}
function linesToTwips(lines) {
  if (lines == null) return;
  return lines * 240;
}
function halfPointToPoints(halfPoints) {
  if (halfPoints == null) return;
  return Math.round(halfPoints / 2);
}
function emuToPixels(emu) {
  if (emu == null) return;
  if (typeof emu === 'string') emu = parseFloat(emu);
  const pixels = (emu * PIXELS_PER_INCH) / 914400;
  return Math.round(pixels);
}
function pixelsToEmu(px) {
  if (px == null) return;
  if (typeof px === 'string') px = parseFloat(px);
  return Math.round(px * 9525);
}
function eighthPointsToPixels(eighthPoints) {
  if (eighthPoints == null) return;
  const points = parseFloat(eighthPoints) / 8;
  const pixels = points * 1.3333;
  return pixels;
}
function pixelsToEightPoints(pixels) {
  if (pixels == null) return;
  return Math.round(pixels * 6);
}
function twipsToPt(twips) {
  if (twips == null) return;
  return twips / 20;
}
function ptToTwips(pt) {
  if (pt == null) return;
  return pt * 20;
}
function rotToDegrees(rot) {
  if (rot == null) return;
  return rot / 6e4;
}
function degreesToRot(degrees) {
  if (degrees == null) return;
  return degrees * 6e4;
}
function pixelsToPolygonUnits(pixels) {
  if (pixels == null) return;
  const pu = pixels * PIXELS_PER_INCH;
  return Math.round(pu);
}
function polygonUnitsToPixels(pu) {
  if (pu == null) return;
  const pixels = Number(pu) / PIXELS_PER_INCH;
  return Math.round(pixels * 1e3) / 1e3;
}
function polygonToObj(polygonNode) {
  if (!polygonNode) return null;
  const points = [];
  polygonNode.elements.forEach((element) => {
    if (['wp:start', 'wp:lineTo'].includes(element.name)) {
      const { x, y } = element.attributes;
      points.push([polygonUnitsToPixels(x), polygonUnitsToPixels(y)]);
    }
  });
  if (points.length > 1) {
    const firstPoint = points[0];
    const lastPoint = points[points.length - 1];
    if (firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1]) {
      points.pop();
    }
  }
  return points;
}
function objToPolygon(points) {
  if (!points || !Array.isArray(points)) return null;
  const polygonNode = {
    name: 'wp:wrapPolygon',
    type: 'wp:wrapPolygon',
    attributes: {
      edited: '0',
    },
    elements: [],
  };
  points.forEach((point, index) => {
    const [x, y] = point;
    const tagName = index === 0 ? 'wp:start' : 'wp:lineTo';
    const pointNode = {
      name: tagName,
      type: tagName,
      attributes: {
        x: pixelsToPolygonUnits(x),
        y: pixelsToPolygonUnits(y),
      },
    };
    polygonNode.elements.push(pointNode);
  });
  if (points.length > 0) {
    const [startX, startY] = points[0];
    const closePointNode = {
      name: 'wp:lineTo',
      type: 'wp:lineTo',
      attributes: {
        x: pixelsToPolygonUnits(startX),
        y: pixelsToPolygonUnits(startY),
      },
    };
    polygonNode.elements.push(closePointNode);
  }
  return polygonNode;
}
const getTextIndentExportValue = (indent) => {
  const [value, unit] = parseSizeUnit(indent);
  const functionsMap = {
    pt: ptToTwips,
    in: inchesToTwips,
  };
  const exportValue = functionsMap[unit] ? functionsMap[unit](value) : pixelsToTwips(value);
  return exportValue;
};
const REMOTE_RESOURCE_PATTERN = /^https?:|^blob:|^file:/i;
const DATA_URI_PATTERN = /^data:/i;
const getArrayBufferFromUrl = async (input) => {
  if (input == null) {
    return new ArrayBuffer(0);
  }
  if (input instanceof ArrayBuffer) {
    return input;
  }
  if (ArrayBuffer.isView(input)) {
    const view = input;
    return view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }
  if (typeof Blob !== 'undefined' && input instanceof Blob) {
    return await input.arrayBuffer();
  }
  if (typeof input !== 'string') {
    throw new TypeError('Unsupported media input type');
  }
  const trimmed = input.trim();
  const shouldFetchRemote = REMOTE_RESOURCE_PATTERN.test(trimmed);
  const isDataUri = DATA_URI_PATTERN.test(trimmed);
  if (shouldFetchRemote) {
    if (typeof fetch !== 'function') {
      throw new Error(`Fetch API is not available to retrieve media: ${trimmed}`);
    }
    const response = await fetch(trimmed);
    if (!response.ok) {
      throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
    }
    return await response.arrayBuffer();
  }
  const base64Payload = isDataUri ? trimmed.split(',', 2)[1] : trimmed.replace(/\s/g, '');
  try {
    if (typeof globalThis.atob === 'function') {
      const binary = globalThis.atob(base64Payload);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }
  } catch (err) {
    console.warn('atob failed, falling back to Buffer:', err);
  }
  const buf = Buffer.from(base64Payload, 'base64');
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
};
const getContentTypesFromXml = (contentTypesXml) => {
  const parser = new window.DOMParser();
  const xmlDoc = parser.parseFromString(contentTypesXml, 'text/xml');
  const defaults = xmlDoc.querySelectorAll('Default');
  return Array.from(defaults).map((item) => item.getAttribute('Extension'));
};
const DOCX_HIGHLIGHT_KEYWORD_MAP = /* @__PURE__ */ new Map([
  ['yellow', 'FFFF00'],
  ['green', '00FF00'],
  ['blue', '0000FF'],
  ['cyan', '00FFFF'],
  ['magenta', 'FF00FF'],
  ['red', 'FF0000'],
  ['darkYellow', '808000'],
  ['darkGreen', '008000'],
  ['darkBlue', '000080'],
  ['darkCyan', '008080'],
  ['darkMagenta', '800080'],
  ['darkGray', '808080'],
  ['darkRed', '800000'],
  ['lightGray', 'C0C0C0'],
  ['black', '000000'],
  ['white', 'FFFFFF'],
]);
const normalizeHexColor = (hex) => {
  if (!hex) return null;
  let value = hex.replace('#', '').trim();
  if (!value) return null;
  value = value.toUpperCase();
  if (value.length === 3)
    value = value
      .split('')
      .map((c) => c + c)
      .join('');
  if (value.length === 8) value = value.slice(0, 6);
  return value;
};
const getHexColorFromDocxSystem = (docxColor) => {
  const hex = DOCX_HIGHLIGHT_KEYWORD_MAP.get(docxColor);
  return hex ? `#${hex}` : null;
};
const getDocxHighlightKeywordFromHex = (hexColor) => {
  if (!hexColor) return null;
  if (DOCX_HIGHLIGHT_KEYWORD_MAP.has(hexColor)) return hexColor;
  const normalized = normalizeHexColor(hexColor);
  if (!normalized) return null;
  for (const [keyword, hex] of DOCX_HIGHLIGHT_KEYWORD_MAP.entries()) {
    if (hex === normalized) return keyword;
  }
  return null;
};
function isValidHexColor(color) {
  if (!color || typeof color !== 'string') return false;
  switch (color.length) {
    case 3:
      return /^[0-9A-F]{3}$/i.test(color);
    case 6:
      return /^[0-9A-F]{6}$/i.test(color);
    case 8:
      return /^[0-9A-F]{8}$/i.test(color);
    default:
      return false;
  }
}
const componentToHex = (val) => {
  const a = Number(val).toString(16);
  return a.length === 1 ? '0' + a : a;
};
const rgbToHex = (rgb) => {
  return '#' + rgb.match(/\d+/g).map(componentToHex).join('');
};
const getLineHeightValueString = (lineHeight, defaultUnit, lineRule = '', isObject = false) => {
  let [value, unit] = parseSizeUnit(lineHeight);
  if (Number.isNaN(value) || value === 0) return {};
  if (lineRule === 'atLeast' && value < 1) return {};
  unit = unit ? unit : defaultUnit;
  return isObject ? { ['line-height']: `${value}${unit}` } : `line-height: ${value}${unit}`;
};
const deobfuscateFont = (arrayBuffer, guidHex) => {
  const dta = new Uint8Array(arrayBuffer);
  const guidStr = guidHex.replace(/[-{}]/g, '');
  if (guidStr.length !== 32) {
    console.error('Invalid GUID');
    return;
  }
  const guidBytes = new Uint8Array(16);
  for (let i = 0, j = 0; i < 32; i += 2, j++) {
    const hexByte = guidStr[i] + guidStr[i + 1];
    guidBytes[j] = parseInt(hexByte, 16);
  }
  for (let i = 0; i < 32; i++) {
    const gi = 15 - (i % 16);
    dta[i] ^= guidBytes[gi];
  }
  return dta.buffer;
};
const hasSomeParentWithClass = (element, classname) => {
  if (element.className?.split(' ')?.indexOf(classname) >= 0) return true;
  return element.parentNode && hasSomeParentWithClass(element.parentNode, classname);
};
function generateDocxRandomId(length = 8) {
  const max = 2147483647;
  const value = Math.floor(Math.random() * (max + 1));
  return value.toString(16).padStart(length, '0').slice(0, length);
}
function generateRandomSigned32BitIntStrId() {
  const val = Math.floor(Math.random() * 2147483647);
  return val.toString();
}
function generateRandom32BitHex() {
  const val = Math.floor(Math.random() * 2147483647);
  return val.toString(16).toUpperCase().padStart(8, '0');
}
const DEFAULT_DOCX_DEFS = {
  'xmlns:wpc': 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas',
  'xmlns:cx': 'http://schemas.microsoft.com/office/drawing/2014/chartex',
  'xmlns:cx1': 'http://schemas.microsoft.com/office/drawing/2015/9/8/chartex',
  'xmlns:cx2': 'http://schemas.microsoft.com/office/drawing/2015/10/21/chartex',
  'xmlns:cx3': 'http://schemas.microsoft.com/office/drawing/2016/5/9/chartex',
  'xmlns:cx4': 'http://schemas.microsoft.com/office/drawing/2016/5/10/chartex',
  'xmlns:cx5': 'http://schemas.microsoft.com/office/drawing/2016/5/11/chartex',
  'xmlns:cx6': 'http://schemas.microsoft.com/office/drawing/2016/5/12/chartex',
  'xmlns:cx7': 'http://schemas.microsoft.com/office/drawing/2016/5/13/chartex',
  'xmlns:cx8': 'http://schemas.microsoft.com/office/drawing/2016/5/14/chartex',
  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
  'xmlns:aink': 'http://schemas.microsoft.com/office/drawing/2016/ink',
  'xmlns:am3d': 'http://schemas.microsoft.com/office/drawing/2017/model3d',
  'xmlns:o': 'urn:schemas-microsoft-com:office:office',
  'xmlns:oel': 'http://schemas.microsoft.com/office/2019/extlst',
  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
  'xmlns:m': 'http://schemas.openxmlformats.org/officeDocument/2006/math',
  'xmlns:v': 'urn:schemas-microsoft-com:vml',
  'xmlns:wp14': 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing',
  'xmlns:wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing',
  'xmlns:w10': 'urn:schemas-microsoft-com:office:word',
  'xmlns:w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
  'xmlns:w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
  'xmlns:w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
  'xmlns:w16cex': 'http://schemas.microsoft.com/office/word/2018/wordml/cex',
  'xmlns:w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
  'xmlns:w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
  'xmlns:w16du': 'http://schemas.microsoft.com/office/word/2023/wordml/word16du',
  'xmlns:w16sdtdh': 'http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash',
  'xmlns:w16sdtfl': 'http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock',
  'xmlns:w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
  'xmlns:wpg': 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup',
  'xmlns:wpi': 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk',
  'xmlns:wne': 'http://schemas.microsoft.com/office/word/2006/wordml',
  'xmlns:wps': 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape',
  'mc:Ignorable': 'w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14',
};
const DEFAULT_CUSTOM_XML = {
  elements: [
    {
      type: 'element',
      name: 'Properties',
      attributes: {
        xmlns: 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
        'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
      },
      elements: [],
    },
  ],
};
const COMMENT_REF = {
  type: 'element',
  name: 'w:r',
  elements: [
    {
      type: 'element',
      name: 'w:rPr',
      elements: [
        {
          type: 'element',
          name: 'w:rStyle',
          attributes: {
            'w:val': 'CommentReference',
          },
        },
      ],
    },
    {
      type: 'element',
      name: 'w:annotationRef',
    },
  ],
};
const DEFAULT_LINKED_STYLES = {
  Normal: {
    type: 'element',
    name: 'w:style',
    attributes: {
      'w:type': 'paragraph',
      'w:default': '1',
      'w:styleId': 'Normal',
    },
    elements: [
      {
        type: 'element',
        name: 'w:name',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:qFormat',
      },
    ],
  },
  Title: {
    type: 'element',
    name: 'w:style',
    attributes: {
      'w:type': 'paragraph',
      'w:styleId': 'Title',
    },
    elements: [
      {
        type: 'element',
        name: 'w:name',
        attributes: {
          'w:val': 'Title',
        },
      },
      {
        type: 'element',
        name: 'w:basedOn',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:next',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:link',
        attributes: {
          'w:val': 'TitleChar',
        },
      },
      {
        type: 'element',
        name: 'w:uiPriority',
        attributes: {
          'w:val': '10',
        },
      },
      {
        type: 'element',
        name: 'w:qFormat',
      },
      {
        type: 'element',
        name: 'w:rsid',
        attributes: {
          'w:val': '00B72667',
        },
      },
      {
        type: 'element',
        name: 'w:pPr',
        elements: [
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:after': '80',
            },
          },
          {
            type: 'element',
            name: 'w:contextualSpacing',
          },
        ],
      },
      {
        type: 'element',
        name: 'w:rPr',
        elements: [
          {
            type: 'element',
            name: 'w:rFonts',
            attributes: {
              'w:asciiTheme': 'majorHAnsi',
              'w:eastAsiaTheme': 'majorEastAsia',
              'w:hAnsiTheme': 'majorHAnsi',
              'w:cstheme': 'majorBidi',
            },
          },
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:val': '-10',
            },
          },
          {
            type: 'element',
            name: 'w:kern',
            attributes: {
              'w:val': '28',
            },
          },
          {
            type: 'element',
            name: 'w:sz',
            attributes: {
              'w:val': '56',
            },
          },
          {
            type: 'element',
            name: 'w:szCs',
            attributes: {
              'w:val': '56',
            },
          },
        ],
      },
    ],
  },
  Subtitle: {
    type: 'element',
    name: 'w:style',
    attributes: {
      'w:type': 'paragraph',
      'w:styleId': 'Subtitle',
    },
    elements: [
      {
        type: 'element',
        name: 'w:name',
        attributes: {
          'w:val': 'Subtitle',
        },
      },
      {
        type: 'element',
        name: 'w:basedOn',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:next',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:link',
        attributes: {
          'w:val': 'SubtitleChar',
        },
      },
      {
        type: 'element',
        name: 'w:uiPriority',
        attributes: {
          'w:val': '11',
        },
      },
      {
        type: 'element',
        name: 'w:qFormat',
      },
      {
        type: 'element',
        name: 'w:rsid',
        attributes: {
          'w:val': '00B72667',
        },
      },
      {
        type: 'element',
        name: 'w:pPr',
        elements: [
          {
            type: 'element',
            name: 'w:numPr',
            elements: [
              {
                type: 'element',
                name: 'w:ilvl',
                attributes: {
                  'w:val': '1',
                },
              },
            ],
          },
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:after': '160',
            },
          },
        ],
      },
      {
        type: 'element',
        name: 'w:rPr',
        elements: [
          {
            type: 'element',
            name: 'w:rFonts',
            attributes: {
              'w:asciiTheme': 'minorHAnsi',
              'w:eastAsiaTheme': 'majorEastAsia',
              'w:hAnsiTheme': 'minorHAnsi',
              'w:cstheme': 'majorBidi',
            },
          },
          {
            type: 'element',
            name: 'w:color',
            attributes: {
              'w:val': '595959',
              'w:themeColor': 'text1',
              'w:themeTint': 'A6',
            },
          },
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:val': '15',
            },
          },
          {
            type: 'element',
            name: 'w:sz',
            attributes: {
              'w:val': '28',
            },
          },
          {
            type: 'element',
            name: 'w:szCs',
            attributes: {
              'w:val': '28',
            },
          },
        ],
      },
    ],
  },
  Heading1: {
    type: 'element',
    name: 'w:style',
    attributes: {
      'w:type': 'paragraph',
      'w:styleId': 'Heading1',
    },
    elements: [
      {
        type: 'element',
        name: 'w:name',
        attributes: {
          'w:val': 'heading 1',
        },
      },
      {
        type: 'element',
        name: 'w:basedOn',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:next',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:link',
        attributes: {
          'w:val': 'Heading1Char',
        },
      },
      {
        type: 'element',
        name: 'w:uiPriority',
        attributes: {
          'w:val': '9',
        },
      },
      {
        type: 'element',
        name: 'w:qFormat',
      },
      {
        type: 'element',
        name: 'w:rsid',
        attributes: {
          'w:val': '00233D7B',
        },
      },
      {
        type: 'element',
        name: 'w:pPr',
        elements: [
          {
            type: 'element',
            name: 'w:keepNext',
          },
          {
            type: 'element',
            name: 'w:keepLines',
          },
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:before': '360',
              'w:after': '80',
            },
          },
          {
            type: 'element',
            name: 'w:outlineLvl',
            attributes: {
              'w:val': '0',
            },
          },
        ],
      },
      {
        type: 'element',
        name: 'w:rPr',
        elements: [
          {
            type: 'element',
            name: 'w:rFonts',
            attributes: {
              'w:asciiTheme': 'majorHAnsi',
              'w:eastAsiaTheme': 'majorEastAsia',
              'w:hAnsiTheme': 'majorHAnsi',
              'w:cstheme': 'majorBidi',
            },
          },
          {
            type: 'element',
            name: 'w:color',
            attributes: {
              'w:val': '0F4761',
              'w:themeColor': 'accent1',
              'w:themeShade': 'BF',
            },
          },
          {
            type: 'element',
            name: 'w:sz',
            attributes: {
              'w:val': '40',
            },
          },
          {
            type: 'element',
            name: 'w:szCs',
            attributes: {
              'w:val': '40',
            },
          },
        ],
      },
    ],
  },
  Heading2: {
    type: 'element',
    name: 'w:style',
    attributes: {
      'w:type': 'paragraph',
      'w:styleId': 'Heading2',
    },
    elements: [
      {
        type: 'element',
        name: 'w:name',
        attributes: {
          'w:val': 'heading 2',
        },
      },
      {
        type: 'element',
        name: 'w:basedOn',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:next',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:link',
        attributes: {
          'w:val': 'Heading2Char',
        },
      },
      {
        type: 'element',
        name: 'w:uiPriority',
        attributes: {
          'w:val': '9',
        },
      },
      {
        type: 'element',
        name: 'w:semiHidden',
      },
      {
        type: 'element',
        name: 'w:unhideWhenUsed',
      },
      {
        type: 'element',
        name: 'w:qFormat',
      },
      {
        type: 'element',
        name: 'w:rsid',
        attributes: {
          'w:val': '00233D7B',
        },
      },
      {
        type: 'element',
        name: 'w:pPr',
        elements: [
          {
            type: 'element',
            name: 'w:keepNext',
          },
          {
            type: 'element',
            name: 'w:keepLines',
          },
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:before': '160',
              'w:after': '80',
            },
          },
          {
            type: 'element',
            name: 'w:outlineLvl',
            attributes: {
              'w:val': '1',
            },
          },
        ],
      },
      {
        type: 'element',
        name: 'w:rPr',
        elements: [
          {
            type: 'element',
            name: 'w:rFonts',
            attributes: {
              'w:asciiTheme': 'majorHAnsi',
              'w:eastAsiaTheme': 'majorEastAsia',
              'w:hAnsiTheme': 'majorHAnsi',
              'w:cstheme': 'majorBidi',
            },
          },
          {
            type: 'element',
            name: 'w:color',
            attributes: {
              'w:val': '0F4761',
              'w:themeColor': 'accent1',
              'w:themeShade': 'BF',
            },
          },
          {
            type: 'element',
            name: 'w:sz',
            attributes: {
              'w:val': '32',
            },
          },
          {
            type: 'element',
            name: 'w:szCs',
            attributes: {
              'w:val': '32',
            },
          },
        ],
      },
    ],
  },
  Heading3: {
    type: 'element',
    name: 'w:style',
    attributes: {
      'w:type': 'paragraph',
      'w:styleId': 'Heading3',
    },
    elements: [
      {
        type: 'element',
        name: 'w:name',
        attributes: {
          'w:val': 'heading 3',
        },
      },
      {
        type: 'element',
        name: 'w:basedOn',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:next',
        attributes: {
          'w:val': 'Normal',
        },
      },
      {
        type: 'element',
        name: 'w:link',
        attributes: {
          'w:val': 'Heading3Char',
        },
      },
      {
        type: 'element',
        name: 'w:uiPriority',
        attributes: {
          'w:val': '9',
        },
      },
      {
        type: 'element',
        name: 'w:semiHidden',
      },
      {
        type: 'element',
        name: 'w:unhideWhenUsed',
      },
      {
        type: 'element',
        name: 'w:qFormat',
      },
      {
        type: 'element',
        name: 'w:rsid',
        attributes: {
          'w:val': '00233D7B',
        },
      },
      {
        type: 'element',
        name: 'w:pPr',
        elements: [
          {
            type: 'element',
            name: 'w:keepNext',
          },
          {
            type: 'element',
            name: 'w:keepLines',
          },
          {
            type: 'element',
            name: 'w:spacing',
            attributes: {
              'w:before': '160',
              'w:after': '80',
            },
          },
          {
            type: 'element',
            name: 'w:outlineLvl',
            attributes: {
              'w:val': '2',
            },
          },
        ],
      },
      {
        type: 'element',
        name: 'w:rPr',
        elements: [
          {
            type: 'element',
            name: 'w:rFonts',
            attributes: {
              'w:eastAsiaTheme': 'majorEastAsia',
              'w:cstheme': 'majorBidi',
            },
          },
          {
            type: 'element',
            name: 'w:color',
            attributes: {
              'w:val': '0F4761',
              'w:themeColor': 'accent1',
              'w:themeShade': 'BF',
            },
          },
          {
            type: 'element',
            name: 'w:sz',
            attributes: {
              'w:val': '28',
            },
          },
          {
            type: 'element',
            name: 'w:szCs',
            attributes: {
              'w:val': '28',
            },
          },
        ],
      },
    ],
  },
};
const COMMENTS_XML_DEF = {
  declaration: {
    attributes: {
      version: '1.0',
      encoding: 'UTF-8',
      standalone: 'yes',
    },
  },
  elements: [
    {
      type: 'element',
      name: 'w:comments',
      attributes: {
        'xmlns:wpc': 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas',
        'xmlns:cx': 'http://schemas.microsoft.com/office/drawing/2014/chartex',
        'xmlns:cx1': 'http://schemas.microsoft.com/office/drawing/2015/9/8/chartex',
        'xmlns:cx2': 'http://schemas.microsoft.com/office/drawing/2015/10/21/chartex',
        'xmlns:cx3': 'http://schemas.microsoft.com/office/drawing/2016/5/9/chartex',
        'xmlns:cx4': 'http://schemas.microsoft.com/office/drawing/2016/5/10/chartex',
        'xmlns:cx5': 'http://schemas.microsoft.com/office/drawing/2016/5/11/chartex',
        'xmlns:cx6': 'http://schemas.microsoft.com/office/drawing/2016/5/12/chartex',
        'xmlns:cx7': 'http://schemas.microsoft.com/office/drawing/2016/5/13/chartex',
        'xmlns:cx8': 'http://schemas.microsoft.com/office/drawing/2016/5/14/chartex',
        'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
        'xmlns:aink': 'http://schemas.microsoft.com/office/drawing/2016/ink',
        'xmlns:am3d': 'http://schemas.microsoft.com/office/drawing/2017/model3d',
        'xmlns:o': 'urn:schemas-microsoft-com:office:office',
        'xmlns:oel': 'http://schemas.microsoft.com/office/2019/extlst',
        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
        'xmlns:m': 'http://schemas.openxmlformats.org/officeDocument/2006/math',
        'xmlns:v': 'urn:schemas-microsoft-com:vml',
        'xmlns:wp14': 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing',
        'xmlns:wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing',
        'xmlns:w10': 'urn:schemas-microsoft-com:office:word',
        'xmlns:w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
        'xmlns:w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
        'xmlns:w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
        'xmlns:w16cex': 'http://schemas.microsoft.com/office/word/2018/wordml/cex',
        'xmlns:w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
        'xmlns:w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
        'xmlns:w16du': 'http://schemas.microsoft.com/office/word/2023/wordml/word16du',
        'xmlns:w16sdtdh': 'http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash',
        'xmlns:w16sdtfl': 'http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock',
        'xmlns:w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
        'xmlns:wpg': 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup',
        'xmlns:wpi': 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk',
        'xmlns:wne': 'http://schemas.microsoft.com/office/word/2006/wordml',
        'xmlns:wps': 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape',
        'mc:Ignorable': 'w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14',
      },
      elements: [],
    },
  ],
};
const COMMENTS_EXTENDED_XML_DEF = {
  declaration: {
    attributes: {
      version: '1.0',
      encoding: 'UTF-8',
      standalone: 'yes',
    },
  },
  elements: [
    {
      type: 'element',
      name: 'w15:commentsEx',
      attributes: {
        'xmlns:wpc': 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas',
        'xmlns:cx': 'http://schemas.microsoft.com/office/drawing/2014/chartex',
        'xmlns:cx1': 'http://schemas.microsoft.com/office/drawing/2015/9/8/chartex',
        'xmlns:cx2': 'http://schemas.microsoft.com/office/drawing/2015/10/21/chartex',
        'xmlns:cx3': 'http://schemas.microsoft.com/office/drawing/2016/5/9/chartex',
        'xmlns:cx4': 'http://schemas.microsoft.com/office/drawing/2016/5/10/chartex',
        'xmlns:cx5': 'http://schemas.microsoft.com/office/drawing/2016/5/11/chartex',
        'xmlns:cx6': 'http://schemas.microsoft.com/office/drawing/2016/5/12/chartex',
        'xmlns:cx7': 'http://schemas.microsoft.com/office/drawing/2016/5/13/chartex',
        'xmlns:cx8': 'http://schemas.microsoft.com/office/drawing/2016/5/14/chartex',
        'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
        'xmlns:aink': 'http://schemas.microsoft.com/office/drawing/2016/ink',
        'xmlns:am3d': 'http://schemas.microsoft.com/office/drawing/2017/model3d',
        'xmlns:o': 'urn:schemas-microsoft-com:office:office',
        'xmlns:oel': 'http://schemas.microsoft.com/office/2019/extlst',
        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
        'xmlns:m': 'http://schemas.openxmlformats.org/officeDocument/2006/math',
        'xmlns:v': 'urn:schemas-microsoft-com:vml',
        'xmlns:wp14': 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing',
        'xmlns:wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing',
        'xmlns:w10': 'urn:schemas-microsoft-com:office:word',
        'xmlns:w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
        'xmlns:w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
        'xmlns:w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
        'xmlns:w16cex': 'http://schemas.microsoft.com/office/word/2018/wordml/cex',
        'xmlns:w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
        'xmlns:w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
        'xmlns:w16du': 'http://schemas.microsoft.com/office/word/2023/wordml/word16du',
        'xmlns:w16sdtdh': 'http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash',
        'xmlns:w16sdtfl': 'http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock',
        'xmlns:w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
        'xmlns:wpg': 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup',
        'xmlns:wpi': 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk',
        'xmlns:wne': 'http://schemas.microsoft.com/office/word/2006/wordml',
        'xmlns:wps': 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape',
        'mc:Ignorable': 'w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14',
      },
      elements: [],
    },
  ],
};
const COMMENTS_EXTENSIBLE_XML_DEF = {
  declaration: {
    attributes: {
      version: '1.0',
      encoding: 'UTF-8',
      standalone: 'yes',
    },
  },
  elements: [
    {
      type: 'element',
      name: 'w16cex:commentsExtensible',
      attributes: {
        'xmlns:wpc': 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas',
        'xmlns:cx': 'http://schemas.microsoft.com/office/drawing/2014/chartex',
        'xmlns:cx1': 'http://schemas.microsoft.com/office/drawing/2015/9/8/chartex',
        'xmlns:cx2': 'http://schemas.microsoft.com/office/drawing/2015/10/21/chartex',
        'xmlns:cx3': 'http://schemas.microsoft.com/office/drawing/2016/5/9/chartex',
        'xmlns:cx4': 'http://schemas.microsoft.com/office/drawing/2016/5/10/chartex',
        'xmlns:cx5': 'http://schemas.microsoft.com/office/drawing/2016/5/11/chartex',
        'xmlns:cx6': 'http://schemas.microsoft.com/office/drawing/2016/5/12/chartex',
        'xmlns:cx7': 'http://schemas.microsoft.com/office/drawing/2016/5/13/chartex',
        'xmlns:cx8': 'http://schemas.microsoft.com/office/drawing/2016/5/14/chartex',
        'xmlns:cr': 'http://schemas.microsoft.com/office/comments/2020/reactions',
        'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
        'xmlns:aink': 'http://schemas.microsoft.com/office/drawing/2016/ink',
        'xmlns:am3d': 'http://schemas.microsoft.com/office/drawing/2017/model3d',
        'xmlns:o': 'urn:schemas-microsoft-com:office:office',
        'xmlns:oel': 'http://schemas.microsoft.com/office/2019/extlst',
        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
        'xmlns:m': 'http://schemas.openxmlformats.org/officeDocument/2006/math',
        'xmlns:v': 'urn:schemas-microsoft-com:vml',
        'xmlns:wp14': 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing',
        'xmlns:wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing',
        'xmlns:w10': 'urn:schemas-microsoft-com:office:word',
        'xmlns:w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
        'xmlns:w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
        'xmlns:w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
        'xmlns:w16cex': 'http://schemas.microsoft.com/office/word/2018/wordml/cex',
        'xmlns:w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
        'xmlns:w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
        'xmlns:w16du': 'http://schemas.microsoft.com/office/word/2023/wordml/word16du',
        'xmlns:w16sdtdh': 'http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash',
        'xmlns:w16sdtfl': 'http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock',
        'xmlns:w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
        'xmlns:wpg': 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup',
        'xmlns:wpi': 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk',
        'xmlns:wne': 'http://schemas.microsoft.com/office/word/2006/wordml',
        'xmlns:wps': 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape',
        'mc:Ignorable': 'w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl cr w16du wp14',
      },
      elements: [],
    },
  ],
};
const COMMENTS_IDS_XML_DEF = {
  declaration: {
    attributes: {
      version: '1.0',
      encoding: 'UTF-8',
      standalone: 'yes',
    },
  },
  elements: [
    {
      type: 'element',
      name: 'w16cid:commentsIds',
      attributes: {
        'xmlns:wpc': 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas',
        'xmlns:cx': 'http://schemas.microsoft.com/office/drawing/2014/chartex',
        'xmlns:cx1': 'http://schemas.microsoft.com/office/drawing/2015/9/8/chartex',
        'xmlns:cx2': 'http://schemas.microsoft.com/office/drawing/2015/10/21/chartex',
        'xmlns:cx3': 'http://schemas.microsoft.com/office/drawing/2016/5/9/chartex',
        'xmlns:cx4': 'http://schemas.microsoft.com/office/drawing/2016/5/10/chartex',
        'xmlns:cx5': 'http://schemas.microsoft.com/office/drawing/2016/5/11/chartex',
        'xmlns:cx6': 'http://schemas.microsoft.com/office/drawing/2016/5/12/chartex',
        'xmlns:cx7': 'http://schemas.microsoft.com/office/drawing/2016/5/13/chartex',
        'xmlns:cx8': 'http://schemas.microsoft.com/office/drawing/2016/5/14/chartex',
        'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
        'xmlns:aink': 'http://schemas.microsoft.com/office/drawing/2016/ink',
        'xmlns:am3d': 'http://schemas.microsoft.com/office/drawing/2017/model3d',
        'xmlns:o': 'urn:schemas-microsoft-com:office:office',
        'xmlns:oel': 'http://schemas.microsoft.com/office/2019/extlst',
        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
        'xmlns:m': 'http://schemas.openxmlformats.org/officeDocument/2006/math',
        'xmlns:v': 'urn:schemas-microsoft-com:vml',
        'xmlns:wp14': 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing',
        'xmlns:wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing',
        'xmlns:w10': 'urn:schemas-microsoft-com:office:word',
        'xmlns:w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
        'xmlns:w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
        'xmlns:w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
        'xmlns:w16cex': 'http://schemas.microsoft.com/office/word/2018/wordml/cex',
        'xmlns:w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
        'xmlns:w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
        'xmlns:w16du': 'http://schemas.microsoft.com/office/word/2023/wordml/word16du',
        'xmlns:w16sdtdh': 'http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash',
        'xmlns:w16sdtfl': 'http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock',
        'xmlns:w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
        'xmlns:wpg': 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup',
        'xmlns:wpi': 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk',
        'xmlns:wne': 'http://schemas.microsoft.com/office/word/2006/wordml',
        'xmlns:wps': 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape',
        'mc:Ignorable': 'w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14',
      },
      elements: [],
    },
  ],
};
const DOCUMENT_RELS_XML_DEF = {
  elements: [
    {
      type: 'element',
      name: 'Relationships',
      attributes: {
        xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',
      },
      elements: [
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId8',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable',
            Target: 'fontTable.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId3',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings',
            Target: 'webSettings.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId7',
            Type: 'http://schemas.microsoft.com/office/2018/08/relationships/commentsExtensible',
            Target: 'commentsExtensible.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId2',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings',
            Target: 'settings.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId1',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
            Target: 'styles.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId6',
            Type: 'http://schemas.microsoft.com/office/2016/09/relationships/commentsIds',
            Target: 'commentsIds.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId5',
            Type: 'http://schemas.microsoft.com/office/2011/relationships/commentsExtended',
            Target: 'commentsExtended.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId10',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
            Target: 'theme/theme1.xml',
          },
        },
        {
          type: 'element',
          name: 'Relationship',
          attributes: {
            Id: 'rId4',
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
            Target: 'comments.xml',
          },
        },
        // {
        //     "type": "element",
        //     "name": "Relationship",
        //     "attributes": {
        //         "Id": "rId9",
        //         "Type": "http://schemas.microsoft.com/office/2011/relationships/people",
        //         "Target": "people.xml"
        //     }
        // }
      ],
    },
  ],
};
const CONTENT_TYPES = {
  declaration: {
    attributes: {
      version: '1.0',
      encoding: 'UTF-8',
      standalone: 'yes',
    },
  },
  elements: [
    {
      type: 'element',
      name: 'Types',
      attributes: {
        xmlns: 'http://schemas.openxmlformats.org/package/2006/content-types',
      },
      elements: [
        {
          type: 'element',
          name: 'Default',
          attributes: {
            Extension: 'rels',
            ContentType: 'application/vnd.openxmlformats-package.relationships+xml',
          },
        },
        {
          type: 'element',
          name: 'Default',
          attributes: {
            Extension: 'xml',
            ContentType: 'application/xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/document.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/styles.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/settings.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/webSettings.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/comments.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/commentsExtended.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/commentsIds.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/commentsExtensible.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/fontTable.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/people.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.people+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/theme/theme1.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/docProps/core.xml',
            ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/docProps/app.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.extended-properties+xml',
          },
        },
        {
          type: 'element',
          name: 'Override',
          attributes: {
            PartName: '/word/numbering.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml',
          },
        },
      ],
    },
  ],
};
const COMMENTS_XML_DEFINITIONS = {
  COMMENTS_XML_DEF,
  COMMENTS_EXTENDED_XML_DEF,
  COMMENTS_EXTENSIBLE_XML_DEF,
  COMMENTS_IDS_XML_DEF,
  DOCUMENT_RELS_XML_DEF,
  CONTENT_TYPES,
};
const carbonCopy = (obj) => {
  if (!obj) return void 0;
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (e) {
    console.error('Error in carbonCopy', obj, e);
    return void 0;
  }
};
const baseNumbering = {
  declaration: {
    attributes: {
      version: '1.0',
      encoding: 'UTF-8',
      standalone: 'yes',
    },
  },
  elements: [
    {
      type: 'element',
      name: 'w:numbering',
      attributes: {
        'xmlns:wpc': 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas',
        'xmlns:cx': 'http://schemas.microsoft.com/office/drawing/2014/chartex',
        'xmlns:cx1': 'http://schemas.microsoft.com/office/drawing/2015/9/8/chartex',
        'xmlns:cx2': 'http://schemas.microsoft.com/office/drawing/2015/10/21/chartex',
        'xmlns:cx3': 'http://schemas.microsoft.com/office/drawing/2016/5/9/chartex',
        'xmlns:cx4': 'http://schemas.microsoft.com/office/drawing/2016/5/10/chartex',
        'xmlns:cx5': 'http://schemas.microsoft.com/office/drawing/2016/5/11/chartex',
        'xmlns:cx6': 'http://schemas.microsoft.com/office/drawing/2016/5/12/chartex',
        'xmlns:cx7': 'http://schemas.microsoft.com/office/drawing/2016/5/13/chartex',
        'xmlns:cx8': 'http://schemas.microsoft.com/office/drawing/2016/5/14/chartex',
        'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
        'xmlns:aink': 'http://schemas.microsoft.com/office/drawing/2016/ink',
        'xmlns:am3d': 'http://schemas.microsoft.com/office/drawing/2017/model3d',
        'xmlns:o': 'urn:schemas-microsoft-com:office:office',
        'xmlns:oel': 'http://schemas.microsoft.com/office/2019/extlst',
        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
        'xmlns:m': 'http://schemas.openxmlformats.org/officeDocument/2006/math',
        'xmlns:v': 'urn:schemas-microsoft-com:vml',
        'xmlns:wp14': 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing',
        'xmlns:wp': 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing',
        'xmlns:w10': 'urn:schemas-microsoft-com:office:word',
        'xmlns:w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
        'xmlns:w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
        'xmlns:w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
        'xmlns:w16cex': 'http://schemas.microsoft.com/office/word/2018/wordml/cex',
        'xmlns:w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
        'xmlns:w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
        'xmlns:w16du': 'http://schemas.microsoft.com/office/word/2023/wordml/word16du',
        'xmlns:w16sdtdh': 'http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash',
        'xmlns:w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
        'xmlns:wpg': 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup',
        'xmlns:wpi': 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk',
        'xmlns:wne': 'http://schemas.microsoft.com/office/word/2006/wordml',
        'xmlns:wps': 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape',
        'mc:Ignorable': 'w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14',
      },
      elements: [
        {
          type: 'element',
          name: 'w:abstractNum',
          attributes: {
            'w:abstractNumId': '0',
            'w15:restartNumberingAfterBreak': '0',
          },
          elements: [
            {
              type: 'element',
              name: 'w:nsid',
              attributes: {
                'w:val': '16126B07',
              },
            },
            {
              type: 'element',
              name: 'w:multiLevelType',
              attributes: {
                'w:val': 'hybridMultilevel',
              },
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '0',
                'w:tplc': '04090001',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '720',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Symbol',
                        'w:hAnsi': 'Symbol',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '1',
                'w:tplc': '04090003',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': 'o',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '1440',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Courier New',
                        'w:hAnsi': 'Courier New',
                        'w:cs': 'Courier New',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '2',
                'w:tplc': '04090005',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '2160',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Wingdings',
                        'w:hAnsi': 'Wingdings',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '3',
                'w:tplc': '04090001',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '2880',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Symbol',
                        'w:hAnsi': 'Symbol',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '4',
                'w:tplc': '04090003',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': 'o',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '3600',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Courier New',
                        'w:hAnsi': 'Courier New',
                        'w:cs': 'Courier New',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '5',
                'w:tplc': '04090005',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '4320',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Wingdings',
                        'w:hAnsi': 'Wingdings',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '6',
                'w:tplc': '04090001',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '5040',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Symbol',
                        'w:hAnsi': 'Symbol',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '7',
                'w:tplc': '04090003',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': 'o',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '5760',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Courier New',
                        'w:hAnsi': 'Courier New',
                        'w:cs': 'Courier New',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '8',
                'w:tplc': '04090005',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'bullet',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '6480',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
                {
                  type: 'element',
                  name: 'w:rPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:rFonts',
                      attributes: {
                        'w:ascii': 'Wingdings',
                        'w:hAnsi': 'Wingdings',
                        'w:hint': 'default',
                      },
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          type: 'element',
          name: 'w:abstractNum',
          attributes: {
            'w:abstractNumId': '1',
            'w15:restartNumberingAfterBreak': '0',
          },
          elements: [
            {
              type: 'element',
              name: 'w:nsid',
              attributes: {
                'w:val': '587013BA',
              },
            },
            {
              type: 'element',
              name: 'w:multiLevelType',
              attributes: {
                'w:val': 'hybridMultilevel',
              },
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '0',
                'w:tplc': '0409000F',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'decimal',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%1.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '720',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '1',
                'w:tplc': '04090019',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'lowerLetter',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%2.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '1440',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '2',
                'w:tplc': '0409001B',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'lowerRoman',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%3.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'right',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '2160',
                        'w:hanging': '180',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '3',
                'w:tplc': '0409000F',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'decimal',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%4.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '2880',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '4',
                'w:tplc': '04090019',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'lowerLetter',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%5.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '3600',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '5',
                'w:tplc': '0409001B',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'lowerRoman',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%6.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'right',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '4320',
                        'w:hanging': '180',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '6',
                'w:tplc': '0409000F',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'decimal',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%7.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '5040',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '7',
                'w:tplc': '04090019',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'lowerLetter',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%8.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'left',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '5760',
                        'w:hanging': '360',
                      },
                    },
                  ],
                },
              ],
            },
            {
              type: 'element',
              name: 'w:lvl',
              attributes: {
                'w:ilvl': '8',
                'w:tplc': '0409001B',
                'w:tentative': '1',
              },
              elements: [
                {
                  type: 'element',
                  name: 'w:start',
                  attributes: {
                    'w:val': '1',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numFmt',
                  attributes: {
                    'w:val': 'lowerRoman',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlText',
                  attributes: {
                    'w:val': '%9.',
                  },
                },
                {
                  type: 'element',
                  name: 'w:lvlJc',
                  attributes: {
                    'w:val': 'right',
                  },
                },
                {
                  type: 'element',
                  name: 'w:pPr',
                  elements: [
                    {
                      type: 'element',
                      name: 'w:ind',
                      attributes: {
                        'w:left': '6480',
                        'w:hanging': '180',
                      },
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          type: 'element',
          name: 'w:num',
          attributes: {
            'w:numId': '1',
            'w16cid:durableId': '100147962',
          },
          elements: [
            {
              type: 'element',
              name: 'w:abstractNumId',
              attributes: {
                'w:val': '0',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:num',
          attributes: {
            'w:numId': '2',
            'w16cid:durableId': '485517411',
          },
          elements: [
            {
              type: 'element',
              name: 'w:abstractNumId',
              attributes: {
                'w:val': '1',
              },
            },
          ],
        },
      ],
    },
  ],
};
const docxNumberingCacheStore = /* @__PURE__ */ new WeakMap();
const NUMBERING_CACHE_KEY = 'numbering-cache';
const LEVELS_MAP_KEY = Symbol('superdoc.numbering.levels');
const NUMBERING_CACHE_DOCX_KEY = Symbol('superdoc.numbering.docx');
const clearConverterCache = (converter) => {
  if (!converter) return;
  delete converter[NUMBERING_CACHE_KEY];
  delete converter[NUMBERING_CACHE_DOCX_KEY];
};
const setConverterCache = (converter, cache, docx) => {
  if (!converter) return;
  converter[NUMBERING_CACHE_KEY] = cache;
  if (docx && typeof docx === 'object') {
    converter[NUMBERING_CACHE_DOCX_KEY] = docx;
  } else {
    delete converter[NUMBERING_CACHE_DOCX_KEY];
  }
};
const createEmptyCache = () => ({
  numToAbstractId: /* @__PURE__ */ new Map(),
  abstractById: /* @__PURE__ */ new Map(),
  templateById: /* @__PURE__ */ new Map(),
  numToDefinition: /* @__PURE__ */ new Map(),
  numNodesById: /* @__PURE__ */ new Map(),
});
const ensureElementsArray = (docx) => {
  let numbering = docx?.['word/numbering.xml'];
  if (!numbering || !numbering.elements?.length || !numbering.elements[0].elements?.length) {
    numbering = baseNumbering;
  }
  return numbering?.elements?.[0]?.elements || [];
};
const buildNumberingCache = (docx) => {
  if (!docx || typeof docx !== 'object') return createEmptyCache();
  const elements = ensureElementsArray(docx);
  if (!elements.length) return createEmptyCache();
  const numToAbstractId = /* @__PURE__ */ new Map();
  const abstractById = /* @__PURE__ */ new Map();
  const templateById = /* @__PURE__ */ new Map();
  const numToDefinition = /* @__PURE__ */ new Map();
  const numNodesById = /* @__PURE__ */ new Map();
  for (const element of elements) {
    if (element?.name === 'w:abstractNum') {
      const abstractIdRaw = element.attributes?.['w:abstractNumId'];
      if (abstractIdRaw == null) continue;
      const abstractId = String(abstractIdRaw);
      abstractById.set(abstractId, element);
      const levelEntries = element.elements?.filter((child) => child.name === 'w:lvl') || [];
      const levelsMap = /* @__PURE__ */ new Map();
      for (const lvl of levelEntries) {
        const rawLevel = lvl?.attributes?.['w:ilvl'];
        const parsedLevel = rawLevel == null ? 0 : Number(rawLevel);
        if (!Number.isNaN(parsedLevel) && !levelsMap.has(parsedLevel)) {
          levelsMap.set(parsedLevel, lvl);
        }
      }
      if (!Object.prototype.hasOwnProperty.call(element, LEVELS_MAP_KEY)) {
        Object.defineProperty(element, LEVELS_MAP_KEY, {
          value: levelsMap,
          enumerable: false,
          configurable: false,
          writable: false,
        });
      }
      const templateTag = element.elements?.find((child) => child.name === 'w:tmpl');
      const templateVal = templateTag?.attributes?.['w:val'];
      if (templateVal != null && levelsMap.size) {
        templateById.set(String(templateVal), element);
      }
    } else if (element?.name === 'w:num') {
      const numIdRaw = element.attributes?.['w:numId'];
      if (numIdRaw == null) continue;
      const numId = String(numIdRaw);
      numNodesById.set(numId, element);
      const abstractRef = element.elements?.find((child) => child.name === 'w:abstractNumId');
      const abstractVal = abstractRef?.attributes?.['w:val'];
      if (abstractVal != null) {
        numToAbstractId.set(numId, String(abstractVal));
      }
    }
  }
  for (const [numId, abstractId] of numToAbstractId.entries()) {
    const abstract = abstractById.get(abstractId);
    if (abstract) {
      numToDefinition.set(numId, abstract);
    }
  }
  return { numToAbstractId, abstractById, templateById, numToDefinition, numNodesById };
};
const ensureNumberingCache = (docx, converter) => {
  if (converter?.[NUMBERING_CACHE_KEY]) {
    const cachedDocx = converter[NUMBERING_CACHE_DOCX_KEY];
    if (docx && cachedDocx && cachedDocx !== docx) {
      clearConverterCache(converter);
    } else {
      return converter[NUMBERING_CACHE_KEY];
    }
  }
  if (!docx || typeof docx !== 'object') return createEmptyCache();
  const existingCache = docxNumberingCacheStore.get(docx);
  if (existingCache) {
    setConverterCache(converter, existingCache, docx);
    return existingCache;
  }
  const cache = buildNumberingCache(docx);
  if (converter) {
    setConverterCache(converter, cache, docx);
  } else {
    docxNumberingCacheStore.set(docx, cache);
  }
  return cache;
};
const handleListNode = (params) => {
  const { nodes, docx } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:p' || nodes[0].isList) {
    return { nodes: [], consumed: 0 };
  }
  const node = carbonCopy(nodes[0]);
  const isList2 = testForList(node, docx);
  if (isList2) {
    node.isList = true;
    const result = handleListNodes(params, node);
    return {
      nodes: [result],
      consumed: 1,
    };
  } else {
    return { nodes: [], consumed: 0 };
  }
};
const listHandlerEntity = {
  handlerName: 'listHandler',
  handler: handleListNode,
};
function handleListNodes(params, node) {
  const { docx, nodeListHandler, lists } = params;
  const initialpPr = node.elements.find((el) => el.name === 'w:pPr');
  const styleTag = initialpPr?.elements?.find((el) => el.name === 'w:pStyle');
  const styleId = styleTag?.attributes['w:val'];
  const { numPr: numPrTag, type: numPrType } = getNumPrRecursive({ node, styleId, docx });
  const currentListNumId = getNumIdFromTag(numPrTag);
  const iLvlTag = numPrTag?.elements?.find((el) => el.name === 'w:ilvl');
  let iLvl = Number(iLvlTag?.attributes['w:val']);
  if (!iLvl && iLvl !== 0) iLvl = getOutlineLevelFromStyleTag(styleId, docx);
  let numberingDefinition = getNodeNumberingDefinition(node, iLvl, docx);
  if (!Object.keys(numberingDefinition).length) {
    const { definition, ilvl } = getNodeNumberingDefinitionByStyle(node, docx);
    if (definition) numberingDefinition = definition;
    if (Number.isNaN(iLvl)) iLvl = ilvl;
  }
  const { listType, listOrderingType, listpPrs, start, lvlText, customFormat } = numberingDefinition;
  if (!listType) {
    const pPrIndex = node.elements.findIndex((el) => el.name === 'w:pPr');
    const pPr = node.elements[pPrIndex];
    const numPrIndex2 = pPr?.elements?.findIndex((el) => el.name === 'w:numPr');
    if (numPrIndex2 >= 0) {
      pPr?.elements?.splice(numPrIndex2, 1);
      node.elements[pPrIndex] = pPr;
    }
    const styleIdIndex = pPr?.elements?.findIndex((el) => el.name === 'w:pStyle');
    if (styleIdIndex >= 0) pPr?.elements?.splice(styleIdIndex, 1);
    const fallBack = nodeListHandler
      .handler({
        ...params,
        nodes: [node],
        path: [...(params.path || []), node],
      })
      ?.filter((n) => n);
    return fallBack[0];
  }
  if (!lists[currentListNumId]) lists[currentListNumId] = { levels: {} };
  const currentListByNumId = lists[currentListNumId];
  if (!currentListByNumId.levels[iLvl]) currentListByNumId.levels[iLvl] = Number(start) || 1;
  else currentListByNumId.levels[iLvl]++;
  Object.keys(currentListByNumId.levels).forEach((key2) => {
    const level = Number(key2);
    if (level > iLvl) {
      delete currentListByNumId.levels[level];
    }
  });
  const path = generateListPath$1(iLvl, currentListNumId, styleId, currentListByNumId.levels, docx);
  if (!path.length) path.push(currentListByNumId.levels[iLvl]);
  const attrs = {};
  attrs.lvlText = lvlText;
  attrs.listLevel = path;
  attrs.listNumberingType = listOrderingType;
  attrs.numId = currentListNumId;
  attrs.level = iLvl;
  attrs.numPrType = numPrType;
  attrs.styleId = styleId;
  attrs.customFormat = customFormat;
  node.isList = true;
  const nodePpr = node.attrs?.paragraphProperties?.elements?.find((el) => el.name === 'w:pPr');
  const numPrIndex = node.attrs?.paragraphProperties?.elements?.findIndex((el) => el.name === 'w:numPr');
  nodePpr?.elements?.splice(numPrIndex, 1);
  const listContents = nodeListHandler.handler({
    ...params,
    nodes: [node],
    path: [...(params.path || []), node],
  });
  const innerParagraph = listContents.find((el) => el.type === 'paragraph');
  const firstElement = innerParagraph.content[0];
  firstElement?.marks?.find((mark) => mark.type === 'textStyle');
  attrs.indent = listpPrs?.indent;
  const processedContents = listContents.map((el, index) => {
    const { attrs: elementAttrs } = el;
    const { indent, textIndent, paragraphProperties, ...rest } = elementAttrs;
    if (index === 0 && !attrs.indent) attrs.indent = indent;
    return {
      ...el,
      attrs: rest,
    };
  });
  const listItem = {
    type: 'listItem',
    content: processedContents || [],
    attrs,
  };
  const resultingList = {
    type: listType,
    content: [listItem],
    attrs: {
      'list-style-type': listOrderingType,
      listId: currentListNumId,
    },
  };
  return resultingList;
}
const getOutlineLevelFromStyleTag = (styleTag, docx) => {
  const matchedStyle = getStyleTagFromStyleId(styleTag, docx);
  const pPr = matchedStyle?.elements?.find((style) => style.name === 'w:pPr');
  const outlineLevel = pPr?.elements?.find((style) => style.name === 'w:outlineLvl');
  try {
    return parseInt(outlineLevel?.attributes['w:val']);
  } catch {}
};
function testForList(node, docx) {
  const { elements } = node;
  const pPr = elements?.find((el) => el.name === 'w:pPr');
  if (!pPr) return false;
  const paragraphStyle = pPr.elements?.find((el) => el.name === 'w:pStyle');
  let numPr = pPr.elements?.find((el) => el.name === 'w:numPr');
  let numId = getNumIdFromTag(numPr);
  const ilvlTag = numPr?.elements?.find((el) => el.name === 'w:ilvl');
  let ilvl = ilvlTag?.attributes['w:val'];
  let outlinelvl;
  const styleId = paragraphStyle?.attributes['w:val'];
  const styleTag = getStyleTagFromStyleId(styleId, docx);
  if (styleTag && !numId) {
    const { numPr: numPrRecursve } = getNumPrRecursive({ node, styleId, docx });
    numPr = numPrRecursve;
    numId = getNumIdFromTag(numPr);
    const stylePpr = styleTag?.elements?.find((el) => el.name === 'w:pPr');
    ilvl = stylePpr?.elements?.find((el) => el.name === 'w:ilvl')?.attributes['w:val'];
    outlinelvl = stylePpr?.elements?.find((el) => el.name === 'w:outlineLvl')?.attributes['w:val'];
    ilvl = outlinelvl || ilvl;
  }
  const abstractNumDefinition = getAbstractDefinition(numId, docx);
  const levelDefinition = abstractNumDefinition?.elements?.find(
    (el) => el.name === 'w:lvl' && el.attributes?.['w:ilvl'] == ilvl,
  );
  if (numId && !levelDefinition && abstractNumDefinition) {
    return true;
  }
  if (!levelDefinition) return false;
  return !!numId;
}
const getNumIdFromTag = (tag) => {
  return tag?.elements?.find((el) => el.name === 'w:numId')?.attributes['w:val'];
};
function getStyleTagFromStyleId(styleId, docx) {
  const styles = docx['word/styles.xml'];
  if (!styles) return {};
  const styleEls = styles.elements;
  const wStyles = styleEls.find((el) => el.name === 'w:styles');
  const styleTags = wStyles.elements.filter((style) => style.name === 'w:style');
  const styleDef = styleTags.find((tag) => tag.attributes['w:styleId'] === styleId);
  return styleDef;
}
function getNumPrRecursive({ node, styleId, docx, seenStyleIds = /* @__PURE__ */ new Set() }) {
  const initialPpr = node?.elements?.find((el) => el.name === 'w:pPr');
  const initialNumPr = initialPpr?.elements?.find((el) => el.name === 'w:numPr');
  let numPr = initialNumPr;
  let numId = getNumIdFromTag(numPr);
  if (numId) return { numPr, type: 'inline' };
  const matchedStyle = getStyleTagFromStyleId(styleId, docx);
  const pPr = matchedStyle?.elements?.find((style) => style.name === 'w:pPr');
  numPr = pPr?.elements?.find((style) => style.name === 'w:numPr');
  numId = getNumIdFromTag(numPr);
  const basedOn = matchedStyle?.elements?.find((style) => style.name === 'w:basedOn');
  if (!numId && !seenStyleIds.has(styleId)) {
    const basedOnStyleId = basedOn?.attributes['w:val'];
    seenStyleIds.add(styleId);
    if (!basedOnStyleId) return {};
    return getNumPrRecursive({ styleId: basedOnStyleId, docx, seenStyleIds });
  }
  return { numPr, type: 'numbering' };
}
const orderedListTypes = [
  'decimal',
  // eg: 1, 2, 3, 4, 5, ...
  'decimalZero',
  // eg: 01, 02, 03, 04, 05, ...
  'lowerRoman',
  // eg: i, ii, iii, iv, v, ...
  'upperRoman',
  // eg: I, II, III, IV, V, ...
  'lowerLetter',
  // eg: a, b, c, d, e, ...
  'upperLetter',
  // eg: A, B, C, D, E, ...
  'ordinal',
  // eg: 1st, 2nd, 3rd, 4th, 5th, ...
  'cardinalText',
  // eg: one, two, three, four, five, ...
  'ordinalText',
  // eg: first, second, third, fourth, fifth, ...
  'hex',
  // eg: 0, 1, 2, ..., 9, A, B, C, ..., F, 10, 11, ...
  'chicago',
  // eg: (0, 1, 2, ..., 9, 10, 11, 12, ..., 19, 1A, 1B, 1C, ..., 1Z, 20, 21, ..., 2Z)
  'none',
  // No bullet
  'japaneseCounting',
  // japanese
];
const unorderedListTypes = [
  'bullet',
  // A standard bullet point ()
  'square',
  // Square bullets ()
  'circle',
  // Circle bullets ()
  'disc',
  // Disc bullets ()
];
const getListNumIdFromStyleRef = (styleId, docx) => {
  const styles = docx['word/styles.xml'];
  if (!styles) return null;
  const { elements } = styles;
  const styleTags = elements[0].elements.filter((style2) => style2.name === 'w:style');
  const style = styleTags.find((tag) => tag.attributes['w:styleId'] === styleId) || {};
  const pPr = style?.elements?.find((style2) => style2.name === 'w:pPr');
  if (!pPr) return null;
  let numPr = pPr?.elements?.find((style2) => style2.name === 'w:numPr');
  if (!numPr) return null;
  let numIdTag = numPr?.elements?.find((style2) => style2.name === 'w:numId') || {};
  let numId = getNumIdFromTag(numPr);
  let ilvlTag = numPr?.elements?.find((style2) => style2.name === 'w:ilvl');
  let ilvl = ilvlTag?.attributes?.['w:val'];
  const basedOnTag = style?.elements?.find((style2) => style2.name === 'w:basedOn');
  const basedOnId = basedOnTag?.attributes?.['w:val'];
  let loopCount = 0;
  while (numPr && !numId && loopCount < 10) {
    const basedOnStyle = styleTags.find((tag) => tag.attributes['w:styleId'] === basedOnId) || {};
    const basedOnPPr = basedOnStyle?.elements?.find((style2) => style2.name === 'w:pPr');
    numPr = basedOnPPr?.elements?.find((style2) => style2.name === 'w:numPr');
    numIdTag = numPr?.elements?.find((style2) => style2.name === 'w:numId') || {};
    numId = numIdTag?.attributes?.['w:val'];
    if (!ilvlTag) {
      ilvlTag = numPr?.elements?.find((style2) => style2.name === 'w:ilvl');
      ilvl = ilvlTag?.attributes?.['w:val'];
    }
    loopCount++;
  }
  return { numId, ilvl };
};
const getAbstractDefinition = (numId, docx, converter) => {
  const numberingXml = docx['word/numbering.xml'];
  if (!numberingXml) return {};
  if (numId == null) return void 0;
  const cache = ensureNumberingCache(docx, converter);
  const numKey = String(numId);
  let listDefinitionForThisNumId = cache.numToDefinition.get(numKey);
  if (!listDefinitionForThisNumId) {
    const abstractNumId = cache.numToAbstractId.get(numKey);
    if (abstractNumId) {
      listDefinitionForThisNumId = cache.abstractById.get(abstractNumId);
      if (listDefinitionForThisNumId) {
        cache.numToDefinition.set(numKey, listDefinitionForThisNumId);
      }
    }
  }
  const levelMap = listDefinitionForThisNumId ? listDefinitionForThisNumId[LEVELS_MAP_KEY] : null;
  const hasLevels = levelMap && levelMap.size > 0;
  if (!listDefinitionForThisNumId || !hasLevels) {
    const templateIdTag = listDefinitionForThisNumId?.elements?.find((el) => el.name === 'w:tmpl');
    const templateId = templateIdTag?.attributes?.['w:val'];
    if (templateId) {
      const byTemplate = cache.templateById.get(String(templateId));
      if (byTemplate) listDefinitionForThisNumId = byTemplate;
    }
  }
  return listDefinitionForThisNumId;
};
const generateListPath$1 = (level, numId, styleId, levels, docx) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      const { start: lvlStart } = getListLevelDefinitionTag(numId, i, styleId, docx);
      if (!levels[i]) levels[i] = Number(lvlStart) || 1;
      path.unshift(levels[i]);
    }
  }
  return path;
};
const getListLevelDefinitionTag = (numId, level, pStyleId, docx) => {
  if (pStyleId) {
    const { numId: numIdFromStyles, ilvl: iLvlFromStyles } = getListNumIdFromStyleRef(pStyleId, docx) || {};
    if (!numId && numIdFromStyles) numId = numIdFromStyles;
    if (!level && iLvlFromStyles) level = iLvlFromStyles ? parseInt(iLvlFromStyles) : null;
  }
  const listDefinitionForThisNumId = getAbstractDefinition(numId, docx);
  const currentLevel = getDefinitionForLevel(listDefinitionForThisNumId, level);
  const numStyleLink = listDefinitionForThisNumId?.elements?.find((style) => style.name === 'w:numStyleLink');
  const numStyleLinkId = numStyleLink?.attributes['w:val'];
  if (numStyleLinkId) {
    const current = getListNumIdFromStyleRef(numStyleLinkId, docx);
    return getListLevelDefinitionTag(current.numId, level, null, docx);
  }
  const start = currentLevel?.elements?.find((style) => style.name === 'w:start')?.attributes['w:val'];
  let numFmtTag = currentLevel?.elements?.find((style) => style.name === 'w:numFmt');
  let numFmt = numFmtTag?.attributes['w:val'];
  if (!numFmt) {
    const altChoice = currentLevel?.elements.find((style) => style.name === 'mc:AlternateContent');
    const choice = altChoice?.elements.find((style) => style.name === 'mc:Choice');
    const choiceNumFmtTag = choice?.elements.find((style) => style.name === 'w:numFmt');
    const choiceNumFmt = choiceNumFmtTag?.attributes['w:val'];
    if (choiceNumFmt) {
      numFmtTag = choiceNumFmtTag;
      numFmt = choiceNumFmt;
    }
  }
  let lvlText = currentLevel?.elements?.find((style) => style.name === 'w:lvlText').attributes['w:val'];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === 'custom') customFormat = numFmtTag?.attributes?.['w:format'];
  const lvlJc = currentLevel?.elements?.find((style) => style.name === 'w:lvlJc').attributes['w:val'];
  const pPr = currentLevel?.elements?.find((style) => style.name === 'w:pPr');
  const rPr = currentLevel?.elements?.find((style) => style.name === 'w:rPr');
  return { start, numFmt, lvlText, lvlJc, pPr, rPr, customFormat };
};
function normalizeLvlTextChar(lvlText) {
  const normalizeChars = ['', '', '', 'o', '', ''];
  if (!lvlText || !normalizeChars.includes(lvlText)) return lvlText;
  if (lvlText === '') lvlText = '';
  if (lvlText === '' || lvlText === 'o') lvlText = '';
  if (lvlText === '' || lvlText === '') lvlText = '';
  if (lvlText === '') lvlText = '';
  return lvlText;
}
function getNodeNumberingDefinition(item, level, docx) {
  if (!item) return {};
  const { attributes = {} } = item;
  const { paragraphProperties = {} } = attributes;
  const { elements: listStyles = [] } = paragraphProperties;
  const initialPpr = item.elements.find((el) => el.name === 'w:pPr');
  const styleTag = initialPpr?.elements?.find((el) => el.name === 'w:pStyle');
  const styleId = styleTag?.attributes['w:val'];
  const { numPr: numPrTag } = getNumPrRecursive({ node: item, styleId, docx });
  if (!numPrTag) return {};
  const numIdTag = numPrTag?.elements.find((style) => style.name === 'w:numId');
  const numId = numIdTag?.attributes['w:val'];
  const pStyle = listStyles.find((style) => style.name === 'w:pStyle');
  const pStyleId = pStyle?.attributes['w:val'];
  const {
    start,
    numFmt: listTypeDef,
    lvlText,
    lvlJc,
    pPr,
    rPr,
    customFormat,
  } = getListLevelDefinitionTag(numId, level, pStyleId, docx);
  let listpPrs, listrPrs;
  if (pPr) listpPrs = _processListParagraphProperties(pPr, initialPpr);
  if (rPr) listrPrs = _processListRunProperties(rPr);
  let listType;
  if (unorderedListTypes.includes(listTypeDef?.toLowerCase())) listType = 'bulletList';
  else if (orderedListTypes.includes(listTypeDef)) listType = 'orderedList';
  else if (listTypeDef === 'custom') {
    listType = 'orderedList';
  } else {
    return {};
  }
  return { listType, listOrderingType: listTypeDef, listrPrs, listpPrs, start, lvlText, lvlJc, customFormat };
}
function getNodeNumberingDefinitionByStyle(item, docx) {
  if (!item) return {};
  const initialPpr = item.elements?.find((el) => el.name === 'w:pPr');
  const styleTag = initialPpr?.elements?.find((el) => el.name === 'w:pStyle');
  const styleId = styleTag?.attributes['w:val'];
  const styleDef = getStyleTagFromStyleId(styleId, docx);
  if (!styleDef) return {};
  const pPr = styleDef.elements?.find((el) => el.name === 'w:pPr');
  const numPr = pPr?.elements?.find((el) => el.name === 'w:numPr');
  const numIdTag = numPr?.elements?.find((el) => el.name === 'w:numId');
  const numId = numIdTag?.attributes?.['w:val'];
  if (!numId) return {};
  const abstractNumId = getAbstractNumIdByNumId(numId, docx);
  if (!abstractNumId) return {};
  const levelData = getLevelDataFromAbstractNum(abstractNumId, styleId, docx);
  if (!levelData) return {};
  const definition = extractDefinitionFromLevel(levelData.level, initialPpr);
  return {
    definition,
    ilvl: levelData.ilvl,
  };
}
function getAbstractNumIdByNumId(numId, docx) {
  const numbering = docx['word/numbering.xml'];
  if (!numbering) return null;
  const { elements } = numbering;
  const listData = elements[0];
  const numberingElements = listData.elements || [];
  const numDef = numberingElements.find((el) => el.name === 'w:num' && el.attributes?.['w:numId'] === numId);
  if (!numDef) return null;
  const abstractNumIdRef = numDef.elements?.find((el) => el.name === 'w:abstractNumId');
  return abstractNumIdRef?.attributes?.['w:val'];
}
function getLevelDataFromAbstractNum(abstractNumId, styleId, docx) {
  const numbering = docx['word/numbering.xml'];
  if (!numbering) return null;
  const { elements } = numbering;
  const listData = elements[0];
  const numberingElements = listData.elements || [];
  const abstractNum = numberingElements.find(
    (el) => el.name === 'w:abstractNum' && el.attributes?.['w:abstractNumId'] === abstractNumId,
  );
  if (!abstractNum) return null;
  const levels = abstractNum.elements?.filter((el) => el.name === 'w:lvl') || [];
  for (const level of levels) {
    const pStyle = level.elements?.find((el) => el.name === 'w:pStyle');
    if (pStyle?.attributes?.['w:val'] === styleId) {
      const found = {
        level,
        ilvl: Number(level.attributes?.['w:ilvl']) || 0,
      };
      return found;
    }
  }
  const level0 = levels.find((level) => level.attributes?.['w:ilvl'] === '0');
  if (level0) {
    return {
      level: level0,
      ilvl: 0,
    };
  }
  return null;
}
function extractDefinitionFromLevel(level, initialPpr) {
  if (!level) return {};
  const start = level.elements?.find((el) => el.name === 'w:start')?.attributes?.['w:val'];
  let numFmtTag = level.elements?.find((el) => el.name === 'w:numFmt');
  let numFmt = numFmtTag?.attributes?.['w:val'];
  let lvlText = level.elements?.find((el) => el.name === 'w:lvlText')?.attributes?.['w:val'];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === 'custom') customFormat = numFmtTag?.attributes?.['w:format'];
  const lvlJc = level.elements?.find((el) => el.name === 'w:lvlJc')?.attributes?.['w:val'];
  const pPr = level.elements?.find((el) => el.name === 'w:pPr');
  const rPr = level.elements?.find((el) => el.name === 'w:rPr');
  let listpPrs, listrPrs;
  if (pPr) listpPrs = _processListParagraphProperties(pPr, initialPpr);
  if (rPr) listrPrs = _processListRunProperties(rPr);
  let listType;
  if (unorderedListTypes.includes(numFmt?.toLowerCase())) {
    listType = 'bulletList';
  } else if (orderedListTypes.includes(numFmt)) {
    listType = 'orderedList';
  } else if (numFmt === 'custom') {
    listType = 'orderedList';
  } else {
    return {};
  }
  return {
    listType,
    listOrderingType: numFmt,
    listrPrs,
    listpPrs,
    start,
    lvlText,
    lvlJc,
    customFormat,
  };
}
function getDefinitionForLevel(data, level) {
  if (!data) return void 0;
  const parsedLevel = Number(level);
  if (Number.isNaN(parsedLevel)) return void 0;
  const cachedLevels = data[LEVELS_MAP_KEY];
  if (cachedLevels?.has(parsedLevel)) {
    return cachedLevels.get(parsedLevel);
  }
  return data?.elements?.find((item) => Number(item.attributes?.['w:ilvl']) === parsedLevel);
}
function parseIndentElement(indElem) {
  if (!indElem || !indElem.attributes) return {};
  const out = {};
  if (indElem.attributes['w:left'] != null) out.left = twipsToPixels(indElem.attributes['w:left']);
  if (indElem.attributes['w:right'] != null) out.right = twipsToPixels(indElem.attributes['w:right']);
  if (indElem.attributes['w:firstLine'] != null) out.firstLine = twipsToPixels(indElem.attributes['w:firstLine']);
  if (indElem.attributes['w:hanging'] != null) out.hanging = twipsToPixels(indElem.attributes['w:hanging']);
  if (indElem.attributes['w:leftChars'] != null) out.leftChars = twipsToPixels(indElem.attributes['w:leftChars']);
  return out;
}
function combineIndents(ind1, ind2) {
  ind1 = ind1 && typeof ind1 === 'object' ? ind1 : {};
  ind2 = ind2 && typeof ind2 === 'object' ? ind2 : {};
  const indent = {};
  ['left', 'right', 'firstLine', 'hanging'].forEach((prop) => {
    const v1 = ind1[prop] !== void 0 ? Number(ind1[prop]) : null;
    const v2 = ind2[prop] !== void 0 ? Number(ind2[prop]) : null;
    if (v1 != null && v2 != null) {
      indent[prop] = prop === 'left' || prop === 'hanging' ? Math.max(v1, v2) : v1;
    } else if (v1 != null) {
      indent[prop] = v1;
    } else if (v2 != null) {
      indent[prop] = v2;
    }
  });
  return indent;
}
function _processListParagraphProperties(data, inlinePpr) {
  const { elements } = data;
  const expectedTypes = ['w:ind', 'w:jc', 'w:tabs'];
  const paragraphProperties = {};
  if (!elements) return paragraphProperties;
  elements.forEach((item) => {
    if (!expectedTypes.includes(item.name)) {
      console.warn(`[numbering.xml] Unexpected list paragraph prop found: ${item.name}`);
    }
  });
  const inlineIndent = inlinePpr?.elements?.find((item) => item.name === 'w:ind');
  const parsedInlineIndent = parseIndentElement(inlineIndent);
  const styleIndent = elements.find((item) => item.name === 'w:ind');
  parseIndentElement(styleIndent);
  paragraphProperties.indent = parsedInlineIndent;
  const justify = elements.find((item) => item.name === 'w:jc');
  if (justify) {
    const justifyAttrs = {};
    if (!justify.attributes) justify.attributes = {};
    if (justify.attributes['w:val'] !== void 0) justifyAttrs.val = justify.attributes['w:val'];
    paragraphProperties.justify = justifyAttrs;
  }
  const tabs = elements.find((item) => item.name === 'w:tabs');
  if (tabs) {
    const tabElements = tabs.elements.filter((item) => item.name === 'w:tab');
    const tabStops = [];
    tabElements.forEach((tab) => {
      const tabStop = {};
      if (!tab.attributes) tab.attributes = {};
      if (tab.attributes['w:val'] !== void 0) tabStop.val = tab.attributes['w:val'];
      if (tab.attributes['w:leader'] !== void 0) tabStop.leader = tab.attributes['w:leader'];
      if (tab.attributes['w:pos'] !== void 0) tabStop.pos = twipsToPixels(tab.attributes['w:pos']);
      tabStops.push(tabStop);
    });
    paragraphProperties.tabStops = tabStops;
  }
  return paragraphProperties;
}
function _processListRunProperties(data) {
  const { elements } = data;
  const expectedTypes = [
    'w:rFonts',
    'w:b',
    'w:bCs',
    'w:i',
    'w:iCs',
    'w:strike',
    'w:dstrike',
    'w:color',
    'w:sz',
    'w:szCs',
    'w:u',
    'w:bdr',
    'w:shd',
    'w:vertAlign',
    'w:jc',
    'w:spacing',
    'w:w',
    'w:smallCaps',
    'w:position',
    'w:lang',
  ];
  const runProperties = {};
  if (!elements) return runProperties;
  elements.forEach((item) => {
    if (!expectedTypes.includes(item.name));
    const { attributes = {} } = item;
    Object.keys(attributes).forEach((key2) => {
      runProperties[key2] = attributes[key2];
    });
  });
  return runProperties;
}
const docxNumberingHelpers = {
  getListLevelDefinitionTag,
  combineIndents,
  parseIndentElement,
  generateListPath: generateListPath$1,
  normalizeLvlTextChar,
};
const baseOrderedListDef = {
  type: 'element',
  name: 'w:abstractNum',
  attributes: {
    'w:abstractNumId': '1',
    'w15:restartNumberingAfterBreak': '0',
  },
  elements: [
    {
      type: 'element',
      name: 'w:multiLevelType',
      attributes: {
        'w:val': 'hybridMultilevel',
      },
    },
    {
      type: 'element',
      name: 'w:tmpl',
      attributes: {
        'w:val': 'EE6417C4',
      },
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '0',
        'w:tplc': '0409000F',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'decimal',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%1.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '720',
                'w:hanging': '360',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '1',
        'w:tplc': '04090019',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'lowerLetter',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%2.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '1440',
                'w:hanging': '360',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '2',
        'w:tplc': '0409001B',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'lowerRoman',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%3.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'right',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '2160',
                'w:hanging': '180',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '3',
        'w:tplc': '0409000F',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'decimal',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%4.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '2880',
                'w:hanging': '360',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '4',
        'w:tplc': '04090019',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'lowerLetter',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%5.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '3600',
                'w:hanging': '360',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '5',
        'w:tplc': '0409001B',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'lowerRoman',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%6.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'right',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '4320',
                'w:hanging': '180',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '6',
        'w:tplc': '0409000F',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'decimal',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%7.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '5040',
                'w:hanging': '360',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '7',
        'w:tplc': '04090019',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'lowerLetter',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%8.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '5760',
                'w:hanging': '360',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '8',
        'w:tplc': '0409001B',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'lowerRoman',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '%9.',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'right',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '6480',
                'w:hanging': '180',
              },
            },
          ],
        },
      ],
    },
  ],
};
const baseBulletList = {
  type: 'element',
  name: 'w:abstractNum',
  attributes: {
    'w:abstractNumId': '0',
    'w15:restartNumberingAfterBreak': '0',
  },
  elements: [
    {
      type: 'element',
      name: 'w:nsid',
      attributes: {
        'w:val': '16126B07',
      },
    },
    {
      type: 'element',
      name: 'w:multiLevelType',
      attributes: {
        'w:val': 'hybridMultilevel',
      },
    },
    {
      type: 'element',
      name: 'w:tmpl',
      attributes: {
        'w:val': '51EC4E08',
      },
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '0',
        'w:tplc': '04090001',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '720',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Symbol',
                'w:hAnsi': 'Symbol',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '1',
        'w:tplc': '04090003',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '1440',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Courier New',
                'w:hAnsi': 'Courier New',
                'w:cs': 'Courier New',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '2',
        'w:tplc': '04090005',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '2160',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Wingdings',
                'w:hAnsi': 'Wingdings',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '3',
        'w:tplc': '04090001',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '2880',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Symbol',
                'w:hAnsi': 'Symbol',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '4',
        'w:tplc': '04090003',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '3600',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Courier New',
                'w:hAnsi': 'Courier New',
                'w:cs': 'Courier New',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '5',
        'w:tplc': '04090005',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '4320',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Wingdings',
                'w:hAnsi': 'Wingdings',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '6',
        'w:tplc': '04090001',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '5040',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Symbol',
                'w:hAnsi': 'Symbol',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '7',
        'w:tplc': '04090003',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': 'o',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '5760',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Courier New',
                'w:hAnsi': 'Courier New',
                'w:cs': 'Courier New',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'w:lvl',
      attributes: {
        'w:ilvl': '8',
        'w:tplc': '04090005',
        'w:tentative': '1',
      },
      elements: [
        {
          type: 'element',
          name: 'w:start',
          attributes: {
            'w:val': '1',
          },
        },
        {
          type: 'element',
          name: 'w:numFmt',
          attributes: {
            'w:val': 'bullet',
          },
        },
        {
          type: 'element',
          name: 'w:lvlText',
          attributes: {
            'w:val': '',
          },
        },
        {
          type: 'element',
          name: 'w:lvlJc',
          attributes: {
            'w:val': 'left',
          },
        },
        {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:ind',
              attributes: {
                'w:left': '6480',
                'w:hanging': '360',
              },
            },
          ],
        },
        {
          type: 'element',
          name: 'w:rPr',
          elements: [
            {
              type: 'element',
              name: 'w:rFonts',
              attributes: {
                'w:ascii': 'Wingdings',
                'w:hAnsi': 'Wingdings',
                'w:hint': 'default',
              },
            },
          ],
        },
      ],
    },
  ],
};
function createDocument(converter, schema, editor, { check = false } = {}) {
  const documentData = converter.getSchema(editor);
  if (documentData) {
    const documentNode = schema.nodeFromJSON(documentData);
    if (check) {
      documentNode.check();
    }
    return documentNode;
  }
  return schema.topNodeType.createAndFill();
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) return type;
  }
  return null;
}
const findParentNodeClosestToPos = ($pos, predicate) => {
  for (let i = $pos.depth; i > 0; i--) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node,
      };
    }
  }
};
const findParentNode = (predicate) => {
  return ({ $from }) => findParentNodeClosestToPos($from, predicate);
};
const isList$1 = (name, extensions) => {
  const nodeExtensions = extensions.filter((e) => e.type === 'node');
  const extension = nodeExtensions.find((i) => i.name === name);
  if (!extension) return false;
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage,
  };
  const group = callOrGet(getExtensionConfigField(extension, 'group', context));
  if (typeof group !== 'string') return false;
  return group.split(' ').includes('list');
};
function generateDocxListAttributes(listType) {
  const listTypesMap = {
    bulletList: 1,
    orderedList: 2,
  };
  return {
    attributes: {
      parentAttributes: {
        'w14:paraId': generateDocxRandomId(),
        'w14:textId': generateDocxRandomId(),
        'w:rsidR': generateDocxRandomId(),
        'w:rsidRDefault': generateDocxRandomId(),
        'w:rsidP': generateDocxRandomId(),
        paragraphProperties: {
          type: 'element',
          name: 'w:pPr',
          elements: [
            {
              type: 'element',
              name: 'w:pStyle',
              attributes: {
                'w:val': 'ListParagraph',
              },
            },
            {
              type: 'element',
              name: 'w:numPr',
              elements: [
                {
                  type: 'element',
                  name: 'w:ilvl',
                  attributes: {
                    'w:val': '0',
                  },
                },
                {
                  type: 'element',
                  name: 'w:numId',
                  attributes: {
                    'w:val': listTypesMap[listType] || 0,
                  },
                },
              ],
            },
          ],
        },
      },
    },
  };
}
const isTextSelection = (value) => {};
function findMarkInSet(marks, type, attrs = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attrs);
  });
}
function isMarkInSet(marks, type, attrs = {}) {
  return !!findMarkInSet(marks, type, attrs);
}
function getMarkRange($pos, type, attrs = {}) {
  if (!$pos || !type) return;
  let start = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start.offset && start.offset !== 0) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node) return;
  const mark = findMarkInSet([...start.node.marks], type, attrs);
  if (!mark) return;
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  findMarkInSet([...start.node.marks], type, attrs);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attrs)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return { from: startPos, to: endPos };
}
function isMarkActive(state, typeOrName, attrs = {}) {
  const { empty, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty) {
    return !!(state.storedMarks || state.selection.$from.marks())
      .filter((mark) => {
        if (!type) return true;
        return type.name === mark.type.name;
      })
      .find((mark) => objectIncludes(mark.attrs, attrs, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (!node.isText && !node.marks.length) return;
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo,
        })),
      );
    });
  });
  if (selectionRange === 0) return false;
  const matchedRange = markRanges
    .filter((markRange) => {
      if (!type) return true;
      return type.name === markRange.mark.type.name;
    })
    .filter((markRange) => objectIncludes(markRange.mark.attrs, attrs, { strict: false }))
    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges
    .filter((markRange) => {
      if (!type) return true;
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    })
    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function getMarksBetween(from, to, doc) {
  const marks = [];
  if (from === to) {
    doc
      .resolve(from)
      .marks()
      .forEach((mark) => {
        const $pos = doc.resolve(from - 1);
        const range = getMarkRange($pos, mark.type);
        if (!range) {
          return;
        }
        marks.push({
          mark,
          ...range,
        });
      });
  } else {
    doc.nodesBetween(from, to, (node, pos) => {
      if (!node || node?.nodeSize === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark,
        })),
      );
    });
  }
  return marks;
}
function isNodeActive(state, typeOrName, attrs = {}) {
  const { from, to, empty } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from, to, (node, pos) => {
    if (node.isText) return;
    const relativeFrom = Math.max(from, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo,
    });
  });
  const selectionRange = to - from;
  const matchedNodeRanges = nodeRanges
    .filter((nodeRange) => {
      if (!type) return true;
      return type.name === nodeRange.node.type.name;
    })
    .filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attrs, { strict: false }));
  if (empty) return !!matchedNodeRanges.length;
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
function isActive(state, name, attrs = {}) {
  if (!name) {
    return isNodeActive(state, null, attrs) || isMarkActive(state, null, attrs);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === 'node') {
    return isNodeActive(state, name, attrs);
  }
  if (schemaType === 'mark') {
    return isMarkActive(state, name, attrs);
  }
  return false;
}
const findMark = (state, markType, toArr = false) => {
  const { selection, doc } = state;
  const { $from, $to } = selection;
  const fromMark = $from.marks().find((mark) => mark.type === markType);
  const toMark = $to.marks().find((mark) => mark.type === markType);
  let markFound;
  const marksFound = [];
  doc.nodesBetween($from.pos, $to.pos, (node, from) => {
    if (node.marks) {
      const actualMark = node.marks.find((mark) => mark.type === markType);
      if (actualMark) {
        markFound = {
          from,
          to: from + node.nodeSize,
          attrs: actualMark.attrs,
          contained: !fromMark || !toMark || fromMark === toMark,
        };
        marksFound.push(markFound);
      }
    }
  });
  if (toArr) {
    return marksFound;
  }
  return markFound;
};
function getActiveFormatting(editor) {
  const { state } = editor;
  const { selection } = state;
  const marks = getMarksFromSelection(state);
  const markAttrs = selection.$head.parent.attrs.marksAttrs;
  const marksToProcess = marks
    .filter((mark) => !['textStyle', 'link'].includes(mark.type.name))
    .map((mark) => ({ name: mark.type.name, attrs: mark.attrs }));
  const textStyleMarks = marks.filter((mark) => mark.type.name === 'textStyle');
  marksToProcess.push(...textStyleMarks.flatMap(unwrapTextMarks));
  if (markAttrs) {
    const marksFromAttrs = markAttrs
      .filter((mark) => !['textStyle', 'link'].includes(mark.type))
      .map((mark) => ({ name: mark.type, attrs: mark.attrs || {} }));
    const textStyleMarksFromAttrs = markAttrs.filter((mark) => mark.type === 'textStyle');
    marksToProcess.push(...marksFromAttrs);
    marksToProcess.push(...textStyleMarksFromAttrs.flatMap(unwrapTextMarks));
  }
  const linkMarkType = state.schema.marks['link'];
  const linkMark = findMark(state, linkMarkType);
  if (linkMark) {
    let { from, to, attrs } = linkMark;
    if (selection.from >= from && selection.to <= to) {
      marksToProcess.push({ name: 'link', attrs });
    }
  }
  const ignoreKeys = ['paragraphSpacing'];
  const attributes = getActiveAttributes(state);
  Object.keys(attributes).forEach((key2) => {
    if (ignoreKeys.includes(key2)) return;
    const attrs = {};
    attrs[key2] = attributes[key2];
    marksToProcess.push({ name: key2, attrs });
  });
  const textColor = marksToProcess.find((i) => i.name === 'textColor');
  const textHightlight = marksToProcess.find((i) => i.name === 'textHighlight');
  if (textColor) {
    marksToProcess.push({
      name: 'color',
      attrs: { color: textColor.attrs?.textColor },
    });
  }
  if (textHightlight) {
    marksToProcess.push({
      name: 'highlight',
      attrs: { color: textHightlight.attrs?.textHighlight },
    });
  }
  const hasPendingFormatting = !!editor.storage.formatCommands?.storedStyle;
  if (hasPendingFormatting) marksToProcess.push({ name: 'copyFormat', attrs: true });
  return marksToProcess;
}
function unwrapTextMarks(textStyleMark) {
  const processedMarks = [];
  const { attrs } = textStyleMark;
  Object.keys(attrs).forEach((key2) => {
    if (!attrs[key2]) return;
    processedMarks.push({ name: key2, attrs: { [key2]: attrs[key2] } });
  });
  return processedMarks;
}
function getActiveAttributes(state) {
  try {
    const { from, to, empty } = state.selection;
    const attributes = {};
    const getAttrs = (node) => {
      Object.keys(node.attrs).forEach((key2) => {
        const value = node.attrs[key2];
        if (value) {
          attributes[key2] = value;
        }
      });
    };
    let start = from;
    let end = to;
    if (empty) state.doc.nodesBetween(start, end + 1, (node) => getAttrs(node));
    else state.doc.nodesBetween(from, to, (node) => getAttrs(node));
    return attributes;
  } catch {
    return {};
  }
}
function findChildren$4(node, predicate) {
  const nodesWithPos = [];
  node.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos,
      });
    }
  });
  return nodesWithPos;
}
function posToDOMRect(view, from, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start = view.coordsAtPos(resolvedFrom);
  const end = view.coordsAtPos(resolvedEnd, -1);
  const top = Math.min(start.top, end.top);
  const bottom = Math.max(start.bottom, end.bottom);
  const left = Math.min(start.left, end.left);
  const right = Math.max(start.right, end.right);
  const width = right - left;
  const height = bottom - top;
  const x = left;
  const y = top;
  const data = {
    top,
    bottom,
    left,
    right,
    width,
    height,
    x,
    y,
  };
  return {
    ...data,
    toJSON: () => data,
  };
}
const isInTable = (state) => {
  const { $head } = state.selection;
  for (let d2 = $head.depth; d2 > 0; d2 -= 1) {
    if ($head.node(d2).type?.spec?.tableRole === 'row') {
      return true;
    }
  }
  return false;
};
function stripHtmlStyles(html) {
  if (!html) return '';
  const parser = new window.DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  const SUPPORTED_ATTRS = [
    'href',
    'src',
    'alt',
    'title',
    'colspan',
    'rowspan',
    'headers',
    'scope',
    'lang',
    'dir',
    'cite',
    'start',
    'type',
    'styleid',
  ];
  const cleanNode = (node) => {
    if (node.nodeType !== window.Node.ELEMENT_NODE) return;
    if (node.nodeName.toLowerCase() === 'span' && !node.children.length) {
      node.innerHTML = preserveSpaces(node.innerHTML);
    }
    [...node.attributes].forEach((attr) => {
      const name = attr.name.toLowerCase();
      if (name === 'style') {
        const cleanedStyle = cleanStyle(attr.value);
        if (!cleanedStyle) {
          node.removeAttribute(attr.name);
        } else node.setAttribute(attr.name, cleanedStyle);
        return;
      }
      const shouldKeep = SUPPORTED_ATTRS.includes(name) || name.startsWith('data-');
      if (!shouldKeep) {
        node.removeAttribute(attr.name);
      }
    });
    [...node.children].forEach(cleanNode);
  };
  cleanNode(doc.body);
  return doc.body.innerHTML;
}
function cleanStyle(style) {
  if (!style) return '';
  const declarations = style
    .split(';')
    .map((s2) => s2.trim())
    .filter(Boolean);
  const textAlign = declarations.find((d2) => d2.startsWith('text-align'));
  return textAlign ? `${textAlign};` : '';
}
function preserveSpaces(innerHtml) {
  return innerHtml.replace(/^\s+/, '&nbsp;').replace(/\s+$/, '&nbsp;');
}
function createDocFromHTML(content, schema, options = {}) {
  const { isImport = false } = options;
  let parsedContent;
  if (typeof content === 'string') {
    const cleanHtml = stripHtmlStyles(content);
    const tempDiv = document.createElement('div');
    if (isImport) {
      tempDiv.dataset.superdocImport = 'true';
    }
    tempDiv.innerHTML = cleanHtml;
    parsedContent = tempDiv;
  } else {
    parsedContent = content;
  }
  return DOMParser$1.fromSchema(schema).parse(parsedContent);
}
marked.use({
  breaks: false,
  // Use proper paragraphs, not <br> tags
  gfm: true,
  // GitHub Flavored Markdown support
});
function createDocFromMarkdown(markdown, schema, options = {}) {
  const html = convertMarkdownToHTML(markdown);
  return createDocFromHTML(html, schema, options);
}
function convertMarkdownToHTML(markdown) {
  let html = marked.parse(markdown, { async: false });
  return html
    .replace(/<\/p>\n<ul>/g, '</p>\n<p>&nbsp;</p>\n<ul>')
    .replace(/<\/p>\n<ol>/g, '</p>\n<p>&nbsp;</p>\n<ol>')
    .replace(/<\/ul>\n<h/g, '</ul>\n<p>&nbsp;</p>\n<h')
    .replace(/<\/ol>\n<h/g, '</ol>\n<p>&nbsp;</p>\n<h');
}
function processContent({ content, type, schema }) {
  let doc;
  switch (type) {
    case 'html':
      doc = createDocFromHTML(content, schema, { isImport: true });
      break;
    case 'markdown':
      doc = createDocFromMarkdown(content, schema, { isImport: true });
      break;
    case 'text':
      const wrapper = document.createElement('div');
      wrapper.dataset.superdocImport = 'true';
      const para = document.createElement('p');
      para.textContent = content;
      wrapper.appendChild(para);
      doc = DOMParser$1.fromSchema(schema).parse(wrapper);
      break;
    case 'schema':
      doc = schema.nodeFromJSON(content);
      break;
    default:
      throw new Error(`Unknown content type: ${type}`);
  }
  return doc;
}
const defaultBooleans = ['required', 'readonly', 'disabled', 'checked', 'multiple', 'autofocus'];
function updateDOMAttributes(dom, attrs = {}, options = {}) {
  const customBooleans = options.customBooleans || [];
  const booleans = [...defaultBooleans, ...customBooleans];
  Object.entries(attrs).forEach(([key2, value]) => {
    if (booleans.includes(key2)) {
      if (!value) dom.removeAttribute(key2);
      else dom.setAttribute(key2, '');
      return;
    }
    if (value != null) {
      dom.setAttribute(key2, value);
    } else {
      dom.removeAttribute(key2);
    }
  });
}
const helpers = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      chainableEditorState,
      cleanSchemaItem,
      convertMarkdownToHTML,
      createDocFromHTML,
      createDocFromMarkdown,
      createDocument,
      defaultBlockAt,
      findChildren: findChildren$4,
      findMark,
      findParentNode,
      findParentNodeClosestToPos,
      generateDocxListAttributes,
      generateDocxRandomId,
      generateRandom32BitHex,
      generateRandomSigned32BitIntStrId,
      getActiveFormatting,
      getExtensionConfigField,
      getMarkRange,
      getMarkType,
      getMarksBetween,
      getMarksFromSelection,
      getNodeType,
      getSchemaTypeByName,
      getSchemaTypeNameByName,
      isActive,
      isInTable,
      isList: isList$1,
      isMarkActive,
      isNodeActive,
      isTextSelection,
      posToDOMRect,
      processContent,
      updateDOMAttributes,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
const generateNewListDefinition = ({ numId, listType, level, start, text, fmt, editor }) => {
  if (typeof listType === 'string') listType = editor.schema.nodes[listType];
  const definition = listType.name === 'orderedList' ? baseOrderedListDef : baseBulletList;
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  let skipAddingNewAbstract = false;
  let newAbstractId = getNewListId(editor, 'abstracts');
  let newAbstractDef = JSON.parse(
    JSON.stringify({
      ...definition,
      attributes: {
        ...definition.attributes,
        'w:abstractNumId': String(newAbstractId),
      },
    }),
  );
  if (level && start && text && fmt) {
    if (newNumbering.definitions[numId]) {
      const abstractId = newNumbering.definitions[numId]?.elements[0]?.attributes['w:val'];
      newAbstractId = abstractId;
      const abstract = editor.converter.numbering.abstracts[abstractId];
      newAbstractDef = { ...abstract };
      skipAddingNewAbstract = true;
    }
    const levelDefIndex = newAbstractDef.elements.findIndex(
      (el) => el.name === 'w:lvl' && el.attributes['w:ilvl'] === level,
    );
    const levelProps = newAbstractDef.elements[levelDefIndex];
    const elToFilter = ['w:numFmt', 'w:lvlText', 'w:start'];
    const oldElements = levelProps.elements.filter((el) => !elToFilter.includes(el.name));
    levelProps.elements = [
      ...oldElements,
      {
        type: 'element',
        name: 'w:start',
        attributes: {
          'w:val': start,
        },
      },
      {
        type: 'element',
        name: 'w:numFmt',
        attributes: {
          'w:val': fmt,
        },
      },
      {
        type: 'element',
        name: 'w:lvlText',
        attributes: {
          'w:val': text,
        },
      },
    ];
  }
  if (!skipAddingNewAbstract) newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(numId, newAbstractId);
  newNumbering.definitions[numId] = newNumDef;
  editor.converter.numbering = newNumbering;
  const change = { numDef: newNumDef, abstractDef: newAbstractDef, editor };
  editor.emit('list-definitions-change', { change, numbering: newNumbering, editor });
  return { abstract: newAbstractDef, definition: newNumDef };
};
const changeNumIdSameAbstract = (numId, level, listType, editor) => {
  const newId = getNewListId(editor, 'definitions');
  const { abstract } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  if (!abstract) {
    ListHelpers.generateNewListDefinition({ numId: newId, listType, editor });
    return newId;
  }
  const newAbstractId = getNewListId(editor, 'abstracts');
  const newAbstractDef = {
    ...abstract,
    attributes: {
      ...(abstract.attributes || {}),
      'w:abstractNumId': String(newAbstractId),
    },
  };
  newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(newId, newAbstractId);
  newNumbering.definitions[newId] = newNumDef;
  editor.converter.numbering = newNumbering;
  return newId;
};
const getBasicNumIdTag = (numId, abstractId) => {
  return {
    type: 'element',
    name: 'w:num',
    attributes: {
      'w:numId': String(numId),
    },
    elements: [{ name: 'w:abstractNumId', attributes: { 'w:val': String(abstractId) } }],
  };
};
const getNewListId = (editor, grouping = 'definitions') => {
  const defs = editor.converter.numbering[grouping] || {};
  const intKeys = Object.keys(defs)
    .map((k2) => Number(k2))
    .filter((n) => Number.isInteger(n));
  const max = intKeys.length ? Math.max(...intKeys) : 0;
  return max + 1;
};
const getListDefinitionDetails = ({ numId, level, listType, editor, tries = 0 }) => {
  const { definitions, abstracts } = editor.converter.numbering;
  if (!numId) return {};
  const numDef = definitions[numId];
  if (!numDef && listType) {
    ListHelpers.generateNewListDefinition({ numId, listType, editor });
  }
  const abstractId = definitions[numId]?.elements?.find((item) => item.name === 'w:abstractNumId')?.attributes?.[
    'w:val'
  ];
  const abstract = abstracts[abstractId];
  if (!abstract) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      customFormat: null,
      abstract: null,
      abstractId,
    };
  }
  const numStyleLink = abstract.elements?.find((item) => item.name === 'w:numStyleLink');
  const styleId = numStyleLink?.attributes?.['w:val'];
  if (styleId && tries < 1) {
    const styleDefinition = getStyleTagFromStyleId(styleId, editor.converter.convertedXml);
    const linkedNumId = styleDefinition?.elements
      ?.find((el) => el.name === 'w:pPr')
      ?.elements?.find((el) => el.name === 'w:numPr')
      ?.elements?.find((el) => el.name === 'w:numId')?.attributes?.['w:val'];
    if (linkedNumId) {
      return getListDefinitionDetails({
        numId: Number(linkedNumId),
        level,
        listType,
        editor,
        tries: tries + 1,
      });
    }
  }
  const listDefinition = abstract.elements?.find(
    (item) => item.name === 'w:lvl' && item.attributes?.['w:ilvl'] == level,
  );
  if (!listDefinition) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      customFormat: null,
      abstract,
      abstractId,
    };
  }
  const findElement = (name) => listDefinition.elements?.find((item) => item.name === name);
  const startElement = findElement('w:start');
  const numFmtElement = findElement('w:numFmt');
  const lvlTextElement = findElement('w:lvlText');
  const start = startElement?.attributes?.['w:val'];
  const numFmt = numFmtElement?.attributes?.['w:val'];
  const lvlText = lvlTextElement?.attributes?.['w:val'];
  const listNumberingType = numFmt;
  const customFormat = numFmt === 'custom' ? numFmtElement?.attributes?.['w:format'] : void 0;
  return {
    start,
    numFmt,
    lvlText,
    listNumberingType,
    customFormat,
    abstract,
    abstractId,
  };
};
const removeListDefinitions = (listId, editor) => {
  const { numbering } = editor.converter;
  if (!numbering) return;
  const { definitions, abstracts } = numbering;
  const abstractId = definitions[listId].elements[0].attributes['w:val'];
  delete definitions[listId];
  delete abstracts[abstractId];
  editor.converter.numbering = {
    definitions,
    abstracts,
  };
};
const createListItemNodeJSON = ({ level, lvlText, numId, numFmt, listLevel, contentNode }) => {
  if (!contentNode) {
    contentNode = {
      type: 'paragraph',
      content: [],
    };
  }
  if (!Array.isArray(contentNode)) contentNode = [contentNode];
  const attrs = {
    lvlText,
    listLevel,
    level,
    numId,
    numPrType: 'inline',
    listNumberingType: numFmt,
  };
  const listItem = {
    type: 'listItem',
    attrs,
    content: [...contentNode],
  };
  return listItem;
};
const createSchemaOrderedListNode = ({ level, numId, listType, editor, listLevel, contentNode }) => {
  level = Number(level);
  numId = Number(numId);
  const { lvlText, numFmt } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const listNodeJSON = createListItemNodeJSON({ level, lvlText, numFmt, numId, listLevel, contentNode });
  const nodeTypeName = typeof listType === 'string' ? listType : listType?.name;
  const type = nodeTypeName || 'orderedList';
  const attrs = {
    'list-style-type': numFmt,
    listId: numId,
  };
  if (type === 'orderedList') {
    attrs.order = level;
  }
  const node = {
    type,
    attrs,
    content: [listNodeJSON],
  };
  return editor.schema.nodeFromJSON(node);
};
function setCaretInsideFirstTextblockOfInsertedAt(tr, startBefore) {
  const containerStart = tr.mapping.map(startBefore, 1);
  const $start = tr.doc.resolve(containerStart);
  const container = $start.nodeAfter;
  if (!container) {
    const nearPos = Math.max(1, Math.min(containerStart, tr.doc.content.size - 1));
    tr.setSelection(TextSelection.near(tr.doc.resolve(nearPos), 1));
    return;
  }
  let found = null;
  container.descendants((n, p) => {
    if (n.isTextblock) {
      found = containerStart + 1 + p + 1;
      return false;
    }
    return true;
  });
  if (found != null) {
    tr.setSelection(TextSelection.create(tr.doc, found));
  } else {
    tr.setSelection(TextSelection.near(tr.doc.resolve(containerStart + 1), 1));
  }
}
const createNewList = ({ listType, tr, editor }) => {
  const numId = ListHelpers.getNewListId(editor);
  if (typeof listType === 'string') listType = editor.schema.nodes[listType];
  ListHelpers.generateNewListDefinition({ numId, listType, editor });
  const { $from } = tr.selection;
  const para = $from.parent;
  if (!para || para.type.name !== 'paragraph') return false;
  const level = 0;
  const listNode = ListHelpers.createSchemaOrderedListNode({
    level,
    numId,
    listType,
    editor,
    listLevel: [1],
    contentNode: para.toJSON(),
    // preserve inline content/marks
  });
  const depth = $from.depth;
  const replaceFrom = $from.before(depth);
  const replaceTo = $from.after(depth);
  const startBefore = replaceFrom;
  tr.replaceWith(replaceFrom, replaceTo, listNode);
  setCaretInsideFirstTextblockOfInsertedAt(tr, startBefore);
  return true;
};
const getCurrentListItem = (state) => {
  return findParentNode((node) => node.type.name === 'listItem')(state.selection);
};
const getParentOrderedList = (state) => {
  return findParentNode((node) => node.type.name === 'orderedList')(state.selection);
};
const setSelectionInsideNewList = (tr, basePos) => {
  try {
    const $pos = tr.doc.resolve(basePos + 3);
    tr.setSelection(TextSelection.near($pos));
  } catch {
    const $fallback = tr.doc.resolve(basePos + 1);
    tr.setSelection(TextSelection.near($fallback));
  }
};
const replaceListWithNode = ({ tr, from, to, newNode }) => {
  tr.replaceWith(from, to, newNode);
};
const convertListItemToParagraph = ({ state, tr, currentNode, replaceFrom, replaceTo }) => {
  const paragraphContent = currentNode.node.content.firstChild;
  if (!paragraphContent) return false;
  const paragraphNode = state.schema.nodes.paragraph.create(
    paragraphContent.attrs,
    paragraphContent.content,
    paragraphContent.marks,
  );
  replaceListWithNode({ tr, from: replaceFrom, to: replaceTo, newNode: paragraphNode });
  const newPos = replaceFrom + 1;
  const $pos = tr.doc.resolve(newPos);
  tr.setSelection(TextSelection.near($pos));
  return true;
};
const insertNewList = (tr, replaceFrom, replaceTo, listNode, marks = []) => {
  tr.replaceWith(replaceFrom, replaceTo, listNode);
  tr.ensureMarks(marks);
  const listStart = replaceFrom;
  const $paragraphStart = tr.doc.resolve(listStart + 2);
  const paragraphNode = $paragraphStart.parent;
  const endPos = $paragraphStart.pos + paragraphNode.content.size;
  const $endPos = tr.doc.resolve(endPos);
  tr.setSelection(TextSelection.near($endPos));
  return true;
};
const getListItemStyleDefinitions = ({ styleId, numId, level, editor, tries }) => {
  if (tries) return {};
  if (typeof numId === 'string') numId = Number(numId);
  if (typeof level === 'string') level = Number(level);
  const docx = editor?.converter?.convertedXml;
  const converter = editor?.converter;
  const numbering = converter?.numbering;
  const styleDefinition = docx ? getStyleTagFromStyleId(styleId, docx) : null;
  const stylePpr = styleDefinition?.elements.find((el) => el.name === 'w:pPr');
  let abstractDefinition = docx ? getAbstractDefinition(numId, docx, converter) : null;
  if (!abstractDefinition) {
    const listDef = numbering?.definitions?.[numId];
    const abstractId = listDef?.elements?.find((item) => item.name === 'w:abstractNumId')?.attributes?.['w:val'];
    abstractDefinition = numbering?.abstracts?.[abstractId];
  }
  const numDefinition = getDefinitionForLevel(abstractDefinition, level);
  const numDefPpr = numDefinition?.elements.find((el) => el.name === 'w:pPr');
  const numLvlJs = numDefinition?.elements.find((el) => el.name === 'w:lvlJc');
  return {
    stylePpr,
    numDefPpr,
    numLvlJs,
  };
};
const addInlineTextMarks = (currentNode, filteredMarks) => {
  const newMarks = [...filteredMarks];
  try {
    const textMarks = currentNode.children[0].children[0].marks;
    const inlineTextStyleFromSplitBlock = textMarks.find((m) => m.type.name === 'textStyle');
    inlineTextStyleFromSplitBlock && newMarks.push(inlineTextStyleFromSplitBlock);
  } catch {}
  return newMarks;
};
const ListHelpers = {
  getCurrentListItem,
  getParentOrderedList,
  setSelectionInsideNewList,
  replaceListWithNode,
  convertListItemToParagraph,
  // DOCX helpers
  insertNewList,
  getListDefinitionDetails,
  generateNewListDefinition,
  getBasicNumIdTag,
  getNewListId,
  removeListDefinitions,
  getListItemStyleDefinitions,
  // Schema helpers
  createNewList,
  createSchemaOrderedListNode,
  createListItemNodeJSON,
  addInlineTextMarks,
  changeNumIdSameAbstract,
  // Base list definitions
  baseOrderedListDef,
  baseBulletList,
};
function translateChildNodes(params) {
  const { content: nodes } = params.node;
  if (!nodes) return [];
  const translatedNodes = [];
  const hyperlinkGroup = [];
  let index = 0;
  while (index < nodes.length) {
    const node = nodes[index];
    const linkMark = _isLinkNode(node);
    if (linkMark) {
      hyperlinkGroup.push(node);
      const nextNode = index + 1 < nodes.length ? nodes[index + 1] : null;
      const nextIsLink = _isLinkNode(nextNode, linkMark);
      if (nextIsLink) {
        index++;
        continue;
      } else {
        let translatedLinkGroup = exportSchemaToJson({
          ...params,
          node: hyperlinkGroup[0],
          extraParams: { ...(params.extraParams || {}), hyperlinkGroup: hyperlinkGroup.slice() },
        });
        if (translatedLinkGroup instanceof Array) translatedNodes.push(...translatedLinkGroup);
        else translatedNodes.push(translatedLinkGroup);
        hyperlinkGroup.length = 0;
        index++;
        continue;
      }
    }
    let translatedNode = exportSchemaToJson({ ...params, node });
    if (translatedNode instanceof Array) translatedNodes.push(...translatedNode);
    else translatedNodes.push(translatedNode);
    index++;
  }
  return translatedNodes.filter((n) => n);
}
function _isLinkNode(node, referenceMark = null) {
  if (!node || (!node.marks && !node.attrs?.marksAsAttrs)) return null;
  const marks = node.marks || node.attrs.marksAsAttrs;
  const linkMark = marks.find((mark) => mark.type === 'link');
  if (!linkMark) return null;
  if (referenceMark) {
    return _isSameLinkMark(linkMark.attrs, referenceMark.attrs) ? linkMark : null;
  }
  return linkMark;
}
function _isSameLinkMark(attrsA, attrsB) {
  for (let key2 of ['anchor', 'docLocation', 'history', 'href', 'rId', 'target']) {
    if (attrsA[key2] != attrsB[key2]) {
      return false;
    }
  }
  return true;
}
const TranslatorTypes = Object.freeze({
  NODE: 'node',
  ATTRIBUTE: 'attribute',
});
const _NodeTranslator = class _NodeTranslator {
  /**
   * @param {string} xmlName
   * @param {SuperDocNodeOrKeyName} sdNodeOrKeyName
   * @param {NodeTranslatorEncodeFn} encode
   * @param {NodeTranslatorDecodeFn} decode
   * @param {number} [priority]
   * @param {MatchesEncodeFn} [matchesEncode]
   * @param {MatchesDecodeFn} [matchesDecode]
   * @param {AttrConfig[]} [attributes]
   */
  constructor(xmlName, sdNodeOrKeyName, encode2, decode2, priority, matchesEncode, matchesDecode, attributes) {
    /** @type {string} */
    __publicField(this, 'xmlName');
    /** @type {SuperDocNodeOrKeyName} */
    __publicField(this, 'sdNodeOrKeyName');
    /** @type {number} */
    __publicField(this, 'priority');
    /** @type {NodeTranslatorEncodeFn} */
    __publicField(this, 'encodeFn');
    /** @type {NodeTranslatorDecodeFn} */
    __publicField(this, 'decodeFn');
    /** @type {MatchesEncodeFn} */
    __publicField(this, 'matchesEncode');
    /** @type {MatchesDecodeFn} */
    __publicField(this, 'matchesDecode');
    /** @type {AttrConfig[]} */
    __publicField(this, 'attributes');
    this.xmlName = xmlName;
    this.sdNodeOrKeyName = sdNodeOrKeyName;
    this.encodeFn = encode2;
    this.decodeFn = decode2;
    this.attributes = attributes || [];
    this.priority = typeof priority === 'number' ? priority : 0;
    this.matchesEncode = typeof matchesEncode === 'function' ? matchesEncode : () => true;
    this.matchesDecode = typeof matchesDecode === 'function' ? matchesDecode : () => true;
  }
  /**
   * Encode the attributes for the node.
   * @param {SCEncoderConfig} params
   * @returns {Object} Encoded attributes object.
   */
  encodeAttributes(params) {
    const { nodes = [] } = params || {};
    const node = nodes[0];
    const { attributes = {} } = node || {};
    const encodedAttrs = {};
    this.attributes.forEach(({ sdName, encode: encode2 }) => {
      if (!encode2) return;
      const encodedAttr = encode2(attributes);
      if (encodedAttr !== void 0 && encodedAttr !== null) {
        encodedAttrs[sdName] = encodedAttr;
      }
    });
    return encodedAttrs;
  }
  /**
   * Decode the attributes for the node.
   * @param {SCDecoderConfig} params
   * @returns {Object} Decoded attributes object.
   */
  decodeAttributes(params) {
    const { node } = params || {};
    const { attrs = {} } = node || {};
    const decodedAttrs = {};
    this.attributes.forEach(({ xmlName, decode: decode2 }) => {
      if (!decode2) return;
      const decodedAttr = decode2(attrs);
      if (decodedAttr !== void 0 && decodedAttr !== null) {
        decodedAttrs[xmlName] = decodedAttr;
      }
    });
    return decodedAttrs;
  }
  /**
   * Decode the attributes for the node.
   * @param {SCDecoderConfig} params
   * @returns {Object} Decoded attributes object.
   */
  decode(params) {
    const decodedAttrs = this.decodeAttributes(params);
    return this.decodeFn ? this.decodeFn.call(this, params, decodedAttrs) : void 0;
  }
  /**
   * Encode the attributes for the node.
   * @param {SCEncoderConfig} params
   * @returns {Object} Encoded attributes object.
   */
  encode(params) {
    const encodedAttrs = this.encodeAttributes(params);
    return this.encodeFn ? this.encodeFn.call(this, params, encodedAttrs) : void 0;
  }
  /**
   * Create a new NodeTranslator instance from a configuration object.
   * @param {NodeTranslatorConfig} config - The configuration object.
   * @returns {NodeTranslator} The created NodeTranslator instance.
   */
  static from(config2) {
    const {
      xmlName,
      sdNodeOrKeyName,
      encode: encode2,
      decode: decode2,
      priority = 0,
      matchesEncode,
      matchesDecode,
      attributes,
    } = config2;
    if (typeof encode2 !== 'function' || (!!decode2 && typeof decode2 !== 'function')) {
      throw new TypeError(`${xmlName}: encode/decode must be functions`);
    }
    const inst = new _NodeTranslator(
      xmlName,
      sdNodeOrKeyName,
      encode2,
      decode2,
      priority,
      matchesEncode,
      matchesDecode,
      attributes,
    );
    return Object.freeze(inst);
  }
  /**
   * Convert the NodeTranslator instance to a string representation.
   * @returns {string} - The string representation of the NodeTranslator instance.
   */
  toString() {
    return `NodeTranslator(${this.xmlName}, priority=${this.priority})`;
  }
};
/** @type {typeof TranslatorTypes} */
__publicField(_NodeTranslator, 'translatorTypes', TranslatorTypes);
let NodeTranslator = _NodeTranslator;
const encode$1c = (attributes) => {
  return attributes['w:type'];
};
const decode$14 = (attrs) => {
  const { lineBreakType } = attrs;
  return lineBreakType;
};
const attrConfig$G = Object.freeze({
  xmlName: 'w:type',
  sdName: 'lineBreakType',
  encode: encode$1c,
  decode: decode$14,
});
const encode$1b = (attributes) => {
  const xmlAttrValue = attributes['w:clear'];
  return xmlAttrValue;
};
const decode$13 = (attrs) => {
  const { clear } = attrs;
  return clear;
};
const attrConfig$F = Object.freeze({
  xmlName: 'w:clear',
  sdName: 'clear',
  encode: encode$1b,
  decode: decode$13,
});
const validXmlAttributes$q = [attrConfig$G, attrConfig$F];
const XML_NODE_NAME$z = 'w:br';
const SD_NODE_NAME$i = 'lineBreak';
const encode$1a = (_, encodedAttrs) => {
  const isPageBreak = encodedAttrs?.lineBreakType === 'page';
  const translated = {
    type: isPageBreak ? 'hardBreak' : 'lineBreak',
  };
  if (encodedAttrs) {
    translated.attrs = { ...encodedAttrs };
  }
  return translated;
};
const decode$12 = (params, decodedAttrs) => {
  const { node } = params;
  if (!node) return;
  const wBreak = { name: 'w:br' };
  if (decodedAttrs) {
    wBreak.attributes = { ...decodedAttrs };
  }
  const isPageBreak = node.type === 'hardBreak';
  if (isPageBreak && (!wBreak.attributes || !wBreak.attributes['w:type'])) {
    wBreak.attributes = { ...wBreak.attributes, 'w:type': 'page' };
  }
  const translated = {
    name: 'w:r',
    elements: [wBreak],
  };
  return translated;
};
const config$y = {
  xmlName: XML_NODE_NAME$z,
  sdNodeOrKeyName: SD_NODE_NAME$i,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$1a,
  decode: decode$12,
  attributes: validXmlAttributes$q,
};
const translator$1s = NodeTranslator.from(config$y);
const encode$19 = (attributes) => attributes?.['w:val'];
const decode$11 = (attrs) => attrs?.highlight;
const attrConfig$E = Object.freeze({
  xmlName: 'w:val',
  sdName: 'highlight',
  encode: encode$19,
  decode: decode$11,
});
const validXmlAttributes$p = [attrConfig$E];
const XML_NODE_NAME$y = 'w:highlight';
const SD_ATTR_KEY$f = 'highlight';
const DISABLED_TOKENS = /* @__PURE__ */ new Set(['transparent', 'none', 'inherit']);
const encode$18 = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const value = encodedAttrs.highlight ?? node?.attributes?.['w:val'];
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$y,
    sdNodeOrKeyName: SD_ATTR_KEY$f,
    attributes: { 'w:val': value ?? null },
  };
};
const decode$10 = (params) => {
  const attrs = params?.node?.attrs || {};
  const highlightValue = attrs.highlight ?? attrs.color ?? null;
  if (!highlightValue) return void 0;
  const normalizedValue = String(highlightValue).trim().toLowerCase();
  if (!normalizedValue) return void 0;
  if (DISABLED_TOKENS.has(normalizedValue)) {
    return {
      name: XML_NODE_NAME$y,
      attributes: { 'w:val': 'none' },
    };
  }
  const keyword = getDocxHighlightKeywordFromHex(highlightValue);
  if (keyword) {
    return {
      name: XML_NODE_NAME$y,
      attributes: { 'w:val': keyword },
    };
  }
  const fill = normalizeHexColor(highlightValue);
  if (!fill) return void 0;
  return {
    name: 'w:shd',
    attributes: {
      'w:color': 'auto',
      'w:val': 'clear',
      'w:fill': fill,
    },
  };
};
const config$x = {
  xmlName: XML_NODE_NAME$y,
  sdNodeOrKeyName: SD_ATTR_KEY$f,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$18,
  decode: decode$10,
  attributes: validXmlAttributes$p,
};
const translator$1r = NodeTranslator.from(config$x);
const encode$17 = (attributes) => {
  return attributes['w:val'];
};
const decode$$ = (attrs) => {
  const { tabSize } = attrs || {};
  return tabSize;
};
const attrConfig$D = Object.freeze({
  xmlName: 'w:val',
  sdName: 'tabSize',
  encode: encode$17,
  decode: decode$$,
});
const encode$16 = (attributes) => {
  return attributes['w:leader'];
};
const decode$_ = (attrs) => {
  const { leader } = attrs || {};
  return leader;
};
const attrConfig$C = Object.freeze({
  xmlName: 'w:leader',
  sdName: 'leader',
  encode: encode$16,
  decode: decode$_,
});
const encode$15 = (attributes) => {
  return attributes['w:pos'];
};
const decode$Z = (attrs) => {
  const { pos } = attrs || {};
  return pos;
};
const attrConfig$B = Object.freeze({
  xmlName: 'w:pos',
  sdName: 'pos',
  encode: encode$15,
  decode: decode$Z,
});
const validXmlAttributes$o = [attrConfig$D, attrConfig$B, attrConfig$C];
const XML_NODE_NAME$x = 'w:tab';
const SD_NODE_NAME$h = 'tab';
const encode$14 = (_, encodedAttrs = {}) => {
  const translated = { type: 'tab' };
  if (encodedAttrs) translated.attrs = { ...encodedAttrs };
  return translated;
};
const decode$Y = (params, decodedAttrs = {}) => {
  const { node } = params || {};
  if (!node) return;
  const wTab = { name: 'w:tab' };
  if (decodedAttrs) wTab.attributes = { ...decodedAttrs };
  const translated = {
    name: 'w:r',
    elements: [wTab],
  };
  const { marks: nodeMarks = [] } = node;
  const outputMarks = processOutputMarks(nodeMarks);
  if (outputMarks.length) {
    translated.elements.unshift(generateRunProps(outputMarks));
  }
  return translated;
};
const config$w = {
  xmlName: XML_NODE_NAME$x,
  sdNodeOrKeyName: SD_NODE_NAME$h,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$14,
  decode: decode$Y,
  attributes: validXmlAttributes$o,
};
const translator$1q = NodeTranslator.from(config$w);
const mergeTextNodes = (nodes) => {
  if (!nodes || !Array.isArray(nodes)) {
    return nodes;
  }
  let mergedNodes = [];
  let prevTextNode = null;
  for (let node of nodes) {
    if (node.type === 'text') {
      if (prevTextNode && canMergeTextNodes(prevTextNode, node)) {
        prevTextNode = {
          ...prevTextNode,
          text: (prevTextNode.text += node.text),
        };
      } else {
        if (prevTextNode) mergedNodes.push(prevTextNode);
        prevTextNode = { ...node };
      }
    } else {
      if (prevTextNode) {
        mergedNodes.push(prevTextNode);
        prevTextNode = null;
      }
      mergedNodes.push(node);
    }
  }
  if (prevTextNode) {
    mergedNodes.push(prevTextNode);
  }
  return mergedNodes;
};
const canMergeTextNodes = (nodeA, nodeB) => {
  if (!nodeA || !nodeB) return false;
  let marksA = nodeA.marks ?? [];
  let marksB = nodeB.marks ?? [];
  if (marksA.length !== marksB.length) {
    return false;
  }
  for (let i = 0; i < marksA.length; i++) {
    if (!marksA[i].attrs) marksA[i].attrs = {};
    if (!marksB[i].attrs) marksB[i].attrs = {};
    if (
      marksA[i].type !== marksB[i].type ||
      Object.keys(marksA[i].attrs).length !== Object.keys(marksB[i].attrs).length ||
      !areAttrsEqual(marksA[i].attrs, marksB[i].attrs)
    ) {
      return false;
    }
  }
  return true;
};
const areAttrsEqual = (attrsA = {}, attrsB = {}) => {
  return objectIncludes(attrsA, attrsB);
};
const TrackInsertMarkName = 'trackInsert';
const TrackDeleteMarkName = 'trackDelete';
const TrackFormatMarkName = 'trackFormat';
function parseMarks(property, unknownMarks = [], docx = null) {
  const marks = [];
  const seen = /* @__PURE__ */ new Set();
  const lang = property?.elements?.find((el) => el.name === 'w:lang');
  lang?.attributes || {};
  property?.elements?.forEach((element) => {
    const marksForType = SuperConverter.markTypes.filter((mark) => mark.name === element.name);
    if (!marksForType.length) {
      const missingMarks = [
        'w:shd',
        'w:rStyle',
        'w:pStyle',
        'w:numPr',
        'w:outlineLvl',
        'w:bdr',
        'w:noProof',
        'w:contextualSpacing',
        'w:keepNext',
        'w:tabs',
        'w:keepLines',
      ];
      if (missingMarks.includes(element.name)) {
        unknownMarks.push(element.name);
      }
    }
    let filteredMarksForType = marksForType;
    if (element.name === 'w:spacing') {
      const attrs = element.attributes || {};
      const hasLetterSpacing = attrs['w:val'];
      filteredMarksForType = marksForType.filter((m) => {
        if (hasLetterSpacing) {
          return m.type === 'letterSpacing';
        }
        return m.type === 'lineHeight';
      });
    }
    filteredMarksForType.forEach((m) => {
      if (!m || seen.has(m.type)) return;
      seen.add(m.type);
      const { attributes = {} } = element;
      const newMark = { type: m.type };
      const exceptionMarks = ['w:b', 'w:caps', 'w:strike', 'w:dstrike'];
      if ((attributes['w:val'] === '0' || attributes['w:val'] === 'none') && !exceptionMarks.includes(m.name)) {
        return;
      }
      const requiresValue = ['w:u'];
      if (requiresValue.includes(m.name) && !attributes['w:val']) {
        return;
      }
      if (m.mark) newMark.type = m.mark;
      if (m.name === 'w:caps') {
        newMark.attrs = {};
        if (attributes['w:val'] === '0') {
          newMark.attrs[m.property] = 'none';
        } else {
          newMark.attrs[m.property] = 'uppercase';
        }
        marks.push(newMark);
        return;
      }
      if (Object.keys(attributes).length) {
        const value = getMarkValue(m.type, attributes, docx);
        if (value === null || value === void 0) return;
        newMark.attrs = {};
        newMark.attrs[m.property] = value;
      }
      marks.push(newMark);
    });
  });
  return createImportMarks(marks);
}
function handleStyleChangeMarks(rPr, currentMarks) {
  const styleChangeMark = rPr.elements?.find((el) => el.name === 'w:rPrChange');
  if (!styleChangeMark) {
    return [];
  }
  const { attributes } = styleChangeMark;
  const mappedAttributes = {
    id: attributes['w:id'],
    date: attributes['w:date'],
    author: attributes['w:author'],
    authorEmail: attributes['w:authorEmail'],
  };
  const submarks = parseMarks(styleChangeMark);
  return [{ type: TrackFormatMarkName, attrs: { ...mappedAttributes, before: submarks, after: [...currentMarks] } }];
}
function createImportMarks(marks) {
  const textStyleMarksToCombine = marks.filter((mark) => mark.type === 'textStyle');
  const remainingMarks = marks.filter((mark) => mark.type !== 'textStyle');
  const combinedTextAttrs = {};
  if (textStyleMarksToCombine.length) {
    textStyleMarksToCombine.forEach((mark) => {
      const { attrs = {} } = mark;
      Object.keys(attrs).forEach((attr) => {
        combinedTextAttrs[attr] = attrs[attr];
      });
    });
  }
  const result = [...remainingMarks, { type: 'textStyle', attrs: combinedTextAttrs }];
  return result;
}
function getMarkValue(markType, attributes, docx) {
  if (markType === 'tabs') markType = 'textIndent';
  const markValueMapper = {
    color: () => `#${attributes['w:val']}`,
    fontSize: () => `${attributes['w:val'] / 2}pt`,
    textIndent: () => getIndentValue(attributes),
    fontFamily: () => getFontFamilyValue(attributes, docx),
    lineHeight: () => getLineHeightValue(attributes),
    letterSpacing: () => `${twipsToPt(attributes['w:val'])}pt`,
    textAlign: () => attributes['w:val'],
    link: () => attributes['href'],
    underline: () => attributes['w:val'],
    bold: () => attributes?.['w:val'] || null,
    italic: () => attributes?.['w:val'] || null,
    highlight: () => getHighLightValue(attributes),
    strike: () => getStrikeValue(attributes),
  };
  if (markType in markValueMapper) {
    return markValueMapper[markType]();
  }
}
function getFontFamilyValue(attributes, docx) {
  const ascii = attributes['w:ascii'];
  const themeAscii = attributes['w:asciiTheme'];
  let resolved = ascii;
  if (docx && themeAscii) {
    const theme = docx['word/theme/theme1.xml'];
    if (theme?.elements?.length) {
      const { elements: topElements } = theme;
      const { elements } = topElements[0] || {};
      const themeElements = elements?.find((el) => el.name === 'a:themeElements');
      const fontScheme = themeElements?.elements?.find((el) => el.name === 'a:fontScheme');
      const majorFont = fontScheme?.elements?.find((el) => el.name === 'a:majorFont');
      const latin = majorFont?.elements?.find((el) => el.name === 'a:latin');
      resolved = latin?.attributes?.typeface || resolved;
    }
  }
  if (!resolved) return null;
  return SuperConverter.toCssFontFamily(resolved, docx);
}
function getIndentValue(attributes) {
  let value = attributes['w:left'];
  if (!value) return null;
  return `${twipsToInches(value)}in`;
}
function getLineHeightValue(attributes) {
  const value = attributes['w:line'];
  const lineRule = attributes['w:lineRule'];
  if (!value || value === '0') return null;
  if (lineRule === 'exact') return `${twipsToPt(value)}pt`;
  return `${twipsToLines(value)}`;
}
function getHighLightValue(attributes) {
  const fill = attributes['w:fill'];
  if (fill && fill !== 'auto') return `#${fill}`;
  if (isValidHexColor(attributes?.['w:val'])) return `#${attributes['w:val']}`;
  return getHexColorFromDocxSystem(attributes?.['w:val']) || null;
}
function getStrikeValue(attributes) {
  const raw = attributes?.['w:val'];
  if (raw === void 0 || raw === null) return '1';
  const value = String(raw).trim().toLowerCase();
  if (value === '1' || value === 'true' || value === 'on') return '1';
  if (value === '0' || value === 'false' || value === 'off') return '0';
  return '1';
}
const parseParagraphBorders = (pBdr) => {
  if (!pBdr || !pBdr.elements) return {};
  const sides = ['top', 'bottom', 'left', 'right'];
  const result = {};
  sides.forEach((side) => {
    const el = pBdr.elements.find((e) => e.name === `w:${side}`);
    if (!el || !el.attributes) return;
    const { attributes: a } = el;
    if (a['w:val'] === 'nil' || a['w:val'] === void 0) return;
    let sizePx;
    if (a['w:sz'] !== void 0) sizePx = eighthPointsToPixels(a['w:sz']);
    let spacePx;
    if (a['w:space'] !== void 0) spacePx = eighthPointsToPixels(a['w:space']);
    result[side] = {
      val: a['w:val'],
      size: sizePx,
      space: spacePx,
      color: a['w:color'] ? `#${a['w:color']}` : '#000000',
    };
  });
  return result;
};
const getParagraphIndent = (node, docx, styleId = '') => {
  const indent = {
    left: 0,
    right: 0,
    firstLine: 0,
    hanging: 0,
    textIndent: 0,
    explicitLeft: false,
    explicitRight: false,
    explicitFirstLine: false,
    explicitHanging: false,
  };
  const { indent: pDefaultIndent = {} } = getDefaultParagraphStyle(docx, styleId);
  const pPr = node.elements?.find((el) => el.name === 'w:pPr');
  const inLineIndentTag = pPr?.elements?.find((el) => el.name === 'w:ind');
  const inLineIndent = inLineIndentTag?.attributes || {};
  const inlineLeft = inLineIndent?.['w:left'];
  const inlineRight = inLineIndent?.['w:right'];
  const inlineFirstLine = inLineIndent?.['w:firstLine'];
  const inlineHanging = inLineIndent?.['w:hanging'];
  const leftIndent = inlineLeft ?? pDefaultIndent?.['w:left'];
  const rightIndent = inlineRight ?? pDefaultIndent?.['w:right'];
  const firstLine = inlineFirstLine ?? pDefaultIndent?.['w:firstLine'];
  const hanging = inlineHanging ?? pDefaultIndent?.['w:hanging'];
  if (leftIndent) {
    indent.left = twipsToPixels(leftIndent);
    indent.explicitLeft = inlineLeft !== void 0;
  }
  if (rightIndent) {
    indent.right = twipsToPixels(rightIndent);
    indent.explicitRight = inlineRight !== void 0;
  }
  if (firstLine) {
    indent.firstLine = twipsToPixels(firstLine);
    indent.explicitFirstLine = inlineFirstLine !== void 0;
  }
  if (hanging) {
    indent.hanging = twipsToPixels(hanging);
    indent.explicitHanging = inlineHanging !== void 0;
  }
  const textIndentValue = leftIndent - parseInt(hanging || 0) || 0;
  if (textIndentValue) {
    indent.textIndent = twipsToInches(textIndentValue);
  }
  return indent;
};
const getParagraphSpacing = (node, docx, styleId = '', marks = [], options = {}) => {
  const { insideTable = false } = options;
  const spacing = {};
  const { spacing: pDefaultSpacing = {}, spacingSource } = getDefaultParagraphStyle(docx, styleId);
  let lineSpaceAfter, lineSpaceBefore, line, lineRuleStyle;
  const pPr = node.elements?.find((el) => el.name === 'w:pPr');
  const inLineSpacingTag = pPr?.elements?.find((el) => el.name === 'w:spacing');
  const inLineSpacing = inLineSpacingTag?.attributes || {};
  const hasInlineSpacing = !!Object.keys(inLineSpacing).length;
  const textStyleMark = marks.find((el) => el.type === 'textStyle');
  const fontSize = textStyleMark?.attrs?.fontSize;
  const lineSpacing = inLineSpacing?.['w:line'] || line || pDefaultSpacing?.['w:line'];
  if (lineSpacing) spacing.line = twipsToLines(lineSpacing);
  const lineRule = inLineSpacing?.['w:lineRule'] || lineRuleStyle || pDefaultSpacing?.['w:lineRule'];
  if (lineRule) spacing.lineRule = lineRule;
  if (lineRule === 'exact' && lineSpacing) {
    spacing.line = `${twipsToPt(lineSpacing)}pt`;
  }
  const beforeSpacing = inLineSpacing?.['w:before'] || lineSpaceBefore || pDefaultSpacing?.['w:before'];
  if (beforeSpacing) spacing.lineSpaceBefore = twipsToPixels(beforeSpacing);
  const beforeAutospacing = inLineSpacing?.['w:beforeAutospacing'];
  if (beforeAutospacing === '1' && fontSize) {
    spacing.lineSpaceBefore += Math.round((parseInt(fontSize) * 0.5 * 96) / 72);
  }
  const afterSpacing = inLineSpacing?.['w:after'] || lineSpaceAfter || pDefaultSpacing?.['w:after'];
  if (afterSpacing) spacing.lineSpaceAfter = twipsToPixels(afterSpacing);
  const afterAutospacing = inLineSpacing?.['w:afterAutospacing'];
  if (afterAutospacing === '1' && fontSize) {
    spacing.lineSpaceAfter += Math.round((parseInt(fontSize) * 0.5 * 96) / 72);
  }
  if (insideTable && !hasInlineSpacing && spacingSource === 'docDefault') {
    const hasExplicitSpacing = Object.keys(inLineSpacing).length > 0;
    if (!hasExplicitSpacing) {
      return void 0;
    }
  }
  return spacing;
};
const getDefaultParagraphStyle = (docx, styleId = '') => {
  const styles = docx['word/styles.xml'];
  const rootElements = styles?.elements?.[0]?.elements;
  if (!rootElements?.length) {
    return {};
  }
  const defaults = rootElements.find((el) => el.name === 'w:docDefaults');
  const pDefault = defaults?.elements?.find((el) => el.name === 'w:pPrDefault') || {};
  const pPrDefault = pDefault?.elements?.find((el) => el.name === 'w:pPr');
  const pPrDefaultSpacingTag = pPrDefault?.elements?.find((el) => el.name === 'w:spacing') || {};
  const pPrDefaultIndentTag = pPrDefault?.elements?.find((el) => el.name === 'w:ind') || {};
  const stylesNormal = rootElements.find((el) => el.name === 'w:style' && el.attributes['w:styleId'] === 'Normal');
  const pPrNormal = stylesNormal?.elements?.find((el) => el.name === 'w:pPr');
  const pPrNormalSpacingTag = pPrNormal?.elements?.find((el) => el.name === 'w:spacing') || {};
  const pPrNormalIndentTag = pPrNormal?.elements?.find((el) => el.name === 'w:ind') || {};
  const isNormalAsDefault = stylesNormal?.attributes?.['w:default'] === '1';
  let pPrStyleIdSpacingTag = {};
  let pPrStyleIdIndentTag = {};
  let pPrStyleJc = {};
  if (styleId) {
    const stylesById = rootElements.find((el) => el.name === 'w:style' && el.attributes['w:styleId'] === styleId);
    const pPrById = stylesById?.elements?.find((el) => el.name === 'w:pPr');
    pPrStyleIdSpacingTag = pPrById?.elements?.find((el) => el.name === 'w:spacing') || {};
    pPrStyleIdIndentTag = pPrById?.elements?.find((el) => el.name === 'w:ind') || {};
    pPrStyleJc = pPrById?.elements?.find((el) => el.name === 'w:jc') || {};
  }
  const { attributes: pPrDefaultSpacingAttr } = pPrDefaultSpacingTag;
  const { attributes: pPrNormalSpacingAttr } = pPrNormalSpacingTag;
  const { attributes: pPrByIdSpacingAttr } = pPrStyleIdSpacingTag;
  const { attributes: pPrByIdJcAttr } = pPrStyleJc;
  const { attributes: pPrDefaultIndentAttr } = pPrDefaultIndentTag;
  const { attributes: pPrNormalIndentAttr } = pPrNormalIndentTag;
  const { attributes: pPrByIdIndentAttr } = pPrStyleIdIndentTag;
  const spacingRest = isNormalAsDefault
    ? pPrNormalSpacingAttr || pPrDefaultSpacingAttr
    : pPrDefaultSpacingAttr || pPrNormalSpacingAttr;
  const indentRest = isNormalAsDefault
    ? pPrNormalIndentAttr || pPrDefaultIndentAttr
    : pPrDefaultIndentAttr || pPrNormalIndentAttr;
  let spacingToUse = pPrByIdSpacingAttr || spacingRest;
  let spacingSource = 'docDefault';
  if (pPrByIdSpacingAttr) {
    spacingSource = 'style';
  } else if (spacingRest === pPrNormalSpacingAttr && pPrNormalSpacingAttr) {
    spacingSource = isNormalAsDefault ? 'docDefault' : 'normal';
  } else if (spacingRest === pPrDefaultSpacingAttr && pPrDefaultSpacingAttr) {
    spacingSource = 'docDefault';
  }
  let indentToUse = pPrByIdIndentAttr || indentRest;
  return {
    spacing: spacingToUse,
    spacingSource,
    indent: indentToUse,
    justify: pPrByIdJcAttr,
  };
};
const handleParagraphNode$1 = (params) => {
  const { nodes, docx, nodeListHandler, filename } = params;
  const node = carbonCopy(nodes[0]);
  let schemaNode;
  const handleStandardNode2 = nodeListHandler.handlerEntities.find(
    (e) => e.handlerName === 'standardNodeHandler',
  )?.handler;
  if (!handleStandardNode2) {
    console.error('Standard node handler not found');
    return null;
  }
  const updatedParams = { ...params, nodes: [node] };
  const result = handleStandardNode2(updatedParams);
  if (result.nodes.length === 1) {
    schemaNode = result.nodes[0];
  }
  const pPr = node.elements?.find((el) => el.name === 'w:pPr');
  const pBdr = pPr?.elements?.find((el) => el.name === 'w:pBdr');
  if (pBdr) {
    const borders = parseParagraphBorders(pBdr);
    if (Object.keys(borders).length) {
      schemaNode.attrs.borders = borders;
    }
  }
  const styleTag = pPr?.elements?.find((el) => el.name === 'w:pStyle');
  const nestedRPr = pPr?.elements?.find((el) => el.name === 'w:rPr');
  const framePr = pPr?.elements?.find((el) => el.name === 'w:framePr');
  if (nestedRPr) {
    let marks = parseMarks(nestedRPr, []);
    if (!schemaNode.content?.length) {
      let highlightIndex = marks?.findIndex((i) => i.type === 'highlight');
      if (highlightIndex !== -1) {
        marks.splice(highlightIndex, 1);
      }
    }
    schemaNode.attrs.marksAttrs = marks;
  }
  let styleId;
  if (styleTag) {
    styleId = styleTag.attributes['w:val'];
    schemaNode.attrs['styleId'] = styleId;
  }
  if (docx) {
    const indent = getParagraphIndent(node, docx, styleId);
    if (!schemaNode.attrs.indent) {
      schemaNode.attrs.indent = {};
    }
    if (indent.left || indent.left === 0) {
      schemaNode.attrs.indent.left = indent.left;
    }
    if (indent.right || indent.right === 0) {
      schemaNode.attrs.indent.right = indent.right;
    }
    if (indent.firstLine || indent.firstLine === 0) {
      schemaNode.attrs.indent.firstLine = indent.firstLine;
    }
    if (indent.hanging || indent.hanging === 0) {
      schemaNode.attrs.indent.hanging = indent.hanging;
    }
    if (indent.textIndent || indent.textIndent === 0) {
      schemaNode.attrs.textIndent = `${indent.textIndent}in`;
    }
  }
  const justify = pPr?.elements?.find((el) => el.name === 'w:jc');
  if (justify && justify.attributes) {
    schemaNode.attrs['textAlign'] = justify.attributes['w:val'];
  }
  const keepLines = pPr?.elements?.find((el) => el.name === 'w:keepLines');
  if (keepLines && keepLines.attributes) {
    schemaNode.attrs['keepLines'] = keepLines.attributes['w:val'];
  }
  const keepNext = pPr?.elements?.find((el) => el.name === 'w:keepNext');
  if (keepNext && keepNext.attributes) {
    schemaNode.attrs['keepNext'] = keepNext.attributes['w:val'];
  }
  if (docx) {
    const defaultStyleId = node.attributes?.['w:rsidRDefault'];
    const insideTable = (params.path || []).some((ancestor) => ancestor.name === 'w:tc');
    const spacing = getParagraphSpacing(node, docx, styleId, schemaNode.attrs.marksAttrs, {
      insideTable,
    });
    if (spacing) {
      schemaNode.attrs['spacing'] = spacing;
    }
    schemaNode.attrs['rsidRDefault'] = defaultStyleId;
  }
  if (docx) {
    const { justify: justify2 } = getDefaultParagraphStyle(docx, styleId);
    if (justify2) {
      schemaNode.attrs.justify = {
        val: justify2['w:val'],
      };
    }
  }
  if (framePr && framePr.attributes['w:dropCap']) {
    schemaNode.attrs.dropcap = {
      type: framePr.attributes['w:dropCap'],
      lines: framePr.attributes['w:lines'],
      wrap: framePr.attributes['w:wrap'],
      hAnchor: framePr.attributes['w:hAnchor'],
      vAnchor: framePr.attributes['w:vAnchor'],
    };
  }
  schemaNode.attrs['filename'] = filename;
  const tabs = pPr?.elements?.find((el) => el.name === 'w:tabs');
  if (tabs && tabs.elements) {
    const tabStops = tabs.elements
      .filter((el) => el.name === 'w:tab')
      .map((tab) => {
        let val = tab.attributes['w:val'] || 'start';
        if (val == 'left') {
          val = 'start';
        } else if (val == 'right') {
          val = 'end';
        }
        const rawPos = tab.attributes['w:pos'];
        const tabStop = {
          val,
          pos: twipsToPixels(rawPos),
        };
        if (rawPos !== void 0) {
          tabStop.originalPos = rawPos;
        }
        if (tab.attributes['w:leader']) {
          tabStop.leader = tab.attributes['w:leader'];
        }
        return tabStop;
      });
    if (tabStops.length > 0) {
      schemaNode.attrs.tabStops = tabStops;
    }
  }
  if (schemaNode && schemaNode.content) {
    schemaNode = {
      ...schemaNode,
      content: mergeTextNodes(schemaNode.content),
    };
  }
  const sectPr = pPr?.elements?.find((el) => el.name === 'w:sectPr');
  if (sectPr) {
    if (!schemaNode.attrs.paragraphProperties) schemaNode.attrs.paragraphProperties = {};
    schemaNode.attrs.paragraphProperties.sectPr = sectPr;
    schemaNode.attrs.pageBreakSource = 'sectPr';
  }
  return schemaNode;
};
const encode$13 = (attributes) => {
  return attributes['w:rsidDel'];
};
const decode$X = (attrs) => {
  return attrs.rsidDel;
};
const attrConfig$A = Object.freeze({
  xmlName: 'w:rsidDel',
  sdName: 'rsidDel',
  encode: encode$13,
  decode: decode$X,
});
const encode$12 = (attributes) => {
  return attributes['w:rsidP'];
};
const decode$W = (attrs) => {
  return attrs.rsidP;
};
const attrConfig$z = Object.freeze({
  xmlName: 'w:rsidP',
  sdName: 'rsidP',
  encode: encode$12,
  decode: decode$W,
});
const encode$11 = (attributes) => {
  return attributes['w:rsidR'];
};
const decode$V = (attrs) => {
  return attrs.rsidR;
};
const attrConfig$y = Object.freeze({
  xmlName: 'w:rsidR',
  sdName: 'rsidR',
  encode: encode$11,
  decode: decode$V,
});
const encode$10 = (attributes) => {
  return attributes['w:rsidRPr'];
};
const decode$U = (attrs) => {
  return attrs.rsidRPr;
};
const attrConfig$x = Object.freeze({
  xmlName: 'w:rsidRPr',
  sdName: 'rsidRPr',
  encode: encode$10,
  decode: decode$U,
});
const encode$$ = (attributes) => {
  return attributes['w:rsidRDefault'];
};
const decode$T = (attrs) => {
  return attrs.rsidRDefault;
};
const attrConfig$w = Object.freeze({
  xmlName: 'w:rsidRDefault',
  sdName: 'rsidRDefault',
  encode: encode$$,
  decode: decode$T,
});
const encode$_ = (attributes) => {
  return attributes['w14:paraId'];
};
const decode$S = (attrs) => {
  return attrs.paraId;
};
const attrConfig$v = Object.freeze({
  xmlName: 'w14:paraId',
  sdName: 'paraId',
  encode: encode$_,
  decode: decode$S,
});
const encode$Z = (attributes) => {
  return attributes['w14:textId'];
};
const decode$R = (attrs) => {
  return attrs.textId;
};
const attrConfig$u = Object.freeze({
  xmlName: 'w14:textId',
  sdName: 'textId',
  encode: encode$Z,
  decode: decode$R,
});
const validXmlAttributes$n = [
  attrConfig$v,
  attrConfig$u,
  attrConfig$y,
  attrConfig$w,
  attrConfig$z,
  attrConfig$x,
  attrConfig$A,
];
const XML_NODE_NAME$w = 'w:p';
const SD_NODE_NAME$g = 'paragraph';
const encode$Y = (params, encodedAttrs = {}) => {
  const node = handleParagraphNode$1(params);
  if (!node) return void 0;
  if (encodedAttrs && Object.keys(encodedAttrs).length) {
    node.attrs = { ...node.attrs, ...encodedAttrs };
  }
  return node;
};
const decode$Q = (params, decodedAttrs = {}) => {
  const translated = translateParagraphNode(params);
  if (!translated) return void 0;
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    translated.attributes = { ...(translated.attributes || {}), ...decodedAttrs };
  }
  return translated;
};
const config$v = {
  xmlName: XML_NODE_NAME$w,
  sdNodeOrKeyName: SD_NODE_NAME$g,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$Y,
  decode: decode$Q,
  attributes: validXmlAttributes$n,
};
const translator$1p = NodeTranslator.from(config$v);
const encode$X = (attributes) => {
  const raw = attributes?.['w:val'];
  if (raw === void 0 || raw === null) return void 0;
  if (typeof raw === 'boolean') return raw;
  if (typeof raw === 'number') return raw !== 0;
  const val = String(raw).trim().toLowerCase();
  if (val === '0' || val === 'false' || val === 'off') return false;
  if (val === '1' || val === 'true' || val === 'on') return true;
  return void 0;
};
const decode$P = (runProps) => {
  if (runProps?.bold === false) return '0';
  return void 0;
};
const attrConfig$t = Object.freeze({
  xmlName: 'w:val',
  sdName: 'bold',
  encode: encode$X,
  decode: decode$P,
});
const validXmlAttributes$m = [attrConfig$t];
const XML_NODE_NAME$v = 'w:b';
const SD_ATTR_KEY$e = 'bold';
const encode$W = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes[0];
  if (!node) return void 0;
  const val = encodedAttrs?.[SD_ATTR_KEY$e];
  let attributes;
  if (val === false) attributes = { 'w:val': '0' };
  else if (val === true) attributes = {};
  else attributes = node.attributes || {};
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$v,
    sdNodeOrKeyName: SD_ATTR_KEY$e,
    attributes,
  };
};
const config$u = {
  xmlName: XML_NODE_NAME$v,
  sdNodeOrKeyName: SD_ATTR_KEY$e,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$W,
  attributes: validXmlAttributes$m,
};
const translator$1o = NodeTranslator.from(config$u);
const XML_NODE_NAME$u = 'w:i';
const SD_ATTR_KEY$d = 'italic';
const encode$V = (params) => {
  const { nodes } = params;
  const node = nodes?.[0];
  if (!node) return void 0;
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$u,
    sdNodeOrKeyName: SD_ATTR_KEY$d,
    attributes: {
      'w:val': node.attributes?.['w:val'] ?? null,
    },
  };
};
const config$t = {
  xmlName: XML_NODE_NAME$u,
  sdNodeOrKeyName: SD_ATTR_KEY$d,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$V,
};
const translator$1n = NodeTranslator.from(config$t);
const encode$U = (attributes) => attributes?.['w:val'];
const decode$O = (attrs) => attrs?.underline;
const attrConfig$s = Object.freeze({
  xmlName: 'w:val',
  sdName: 'underline',
  encode: encode$U,
  decode: decode$O,
});
const encode$T = (attributes) => attributes?.['w:color'];
const decode$N = (attrs) => attrs?.color;
const attrConfig$r = Object.freeze({
  xmlName: 'w:color',
  sdName: 'color',
  encode: encode$T,
  decode: decode$N,
});
const encode$S = (attributes) => attributes?.['w:themeColor'];
const decode$M = (attrs) => attrs?.themeColor;
const attrConfig$q = Object.freeze({
  xmlName: 'w:themeColor',
  sdName: 'themeColor',
  encode: encode$S,
  decode: decode$M,
});
const encode$R = (attributes) => attributes?.['w:themeTint'];
const decode$L = (attrs) => attrs?.themeTint;
const attrConfig$p = Object.freeze({
  xmlName: 'w:themeTint',
  sdName: 'themeTint',
  encode: encode$R,
  decode: decode$L,
});
const encode$Q = (attributes) => attributes?.['w:themeShade'];
const decode$K = (attrs) => attrs?.themeShade;
const attrConfig$o = Object.freeze({
  xmlName: 'w:themeShade',
  sdName: 'themeShade',
  encode: encode$Q,
  decode: decode$K,
});
const validXmlAttributes$l = [attrConfig$s, attrConfig$r, attrConfig$q, attrConfig$p, attrConfig$o];
const XML_NODE_NAME$t = 'w:u';
const SD_ATTR_KEY$c = 'underline';
const encode$P = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const sourceAttrs = node?.attributes || {};
  const underlineType = encodedAttrs.underline ?? sourceAttrs['w:val'];
  const color = encodedAttrs.color ?? sourceAttrs['w:color'];
  const themeColor = encodedAttrs.themeColor ?? sourceAttrs['w:themeColor'];
  const themeTint = encodedAttrs.themeTint ?? sourceAttrs['w:themeTint'];
  const themeShade = encodedAttrs.themeShade ?? sourceAttrs['w:themeShade'];
  const attributes = { 'w:val': underlineType ?? null };
  if (color !== void 0 && color !== null) attributes['w:color'] = color;
  if (themeColor !== void 0 && themeColor !== null) attributes['w:themeColor'] = themeColor;
  if (themeTint !== void 0 && themeTint !== null) attributes['w:themeTint'] = themeTint;
  if (themeShade !== void 0 && themeShade !== null) attributes['w:themeShade'] = themeShade;
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$t,
    sdNodeOrKeyName: SD_ATTR_KEY$c,
    attributes,
  };
};
const decode$J = (params) => {
  const attrs = params?.node?.attrs || {};
  const underlineType = attrs.underlineType ?? attrs.underline ?? null;
  const color = attrs.underlineColor ?? attrs.color ?? null;
  const themeColor = attrs.underlineThemeColor ?? attrs.themeColor ?? null;
  const themeTint = attrs.underlineThemeTint ?? attrs.themeTint ?? null;
  const themeShade = attrs.underlineThemeShade ?? attrs.themeShade ?? null;
  if (!underlineType && !color && !themeColor && !themeTint && !themeShade) return void 0;
  const attributes = {};
  if (underlineType) attributes['w:val'] = underlineType;
  if (color) {
    const normalized = normalizeHexColor(color);
    if (normalized) attributes['w:color'] = normalized;
  }
  if (themeColor) attributes['w:themeColor'] = themeColor;
  if (themeTint) attributes['w:themeTint'] = themeTint;
  if (themeShade) attributes['w:themeShade'] = themeShade;
  return {
    name: XML_NODE_NAME$t,
    attributes,
  };
};
const config$s = {
  xmlName: XML_NODE_NAME$t,
  sdNodeOrKeyName: SD_ATTR_KEY$c,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$P,
  decode: decode$J,
  attributes: validXmlAttributes$l,
};
const translator$1m = NodeTranslator.from(config$s);
const encode$O = (attributes) => {
  const raw = attributes?.['w:val'];
  if (raw === void 0 || raw === null) return void 0;
  if (typeof raw === 'boolean') return raw;
  if (typeof raw === 'number') return raw !== 0;
  const val = String(raw).trim().toLowerCase();
  if (val === '0' || val === 'false' || val === 'off') return false;
  if (val === '1' || val === 'true' || val === 'on') return true;
  return void 0;
};
const decode$I = (attrs) => {
  if (attrs?.strike === false) return '0';
  return void 0;
};
const attrConfig$n = Object.freeze({
  xmlName: 'w:val',
  sdName: 'strike',
  encode: encode$O,
  decode: decode$I,
});
const validXmlAttributes$k = [attrConfig$n];
const XML_NODE_NAME$s = 'w:strike';
const SD_ATTR_KEY$b = 'strike';
const encode$N = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  if (!node) return void 0;
  const val = encodedAttrs?.[SD_ATTR_KEY$b];
  let attributes;
  if (val === false) attributes = { 'w:val': '0' };
  else if (val === true) attributes = {};
  else attributes = { ...(node.attributes || {}) };
  if (attributes['w:val'] === void 0 && val !== true) attributes['w:val'] = null;
  else if (val === true && attributes['w:val'] === void 0) delete attributes['w:val'];
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$s,
    sdNodeOrKeyName: SD_ATTR_KEY$b,
    attributes,
  };
};
const config$r = {
  xmlName: XML_NODE_NAME$s,
  sdNodeOrKeyName: SD_ATTR_KEY$b,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$N,
  attributes: validXmlAttributes$k,
};
const translator$1l = NodeTranslator.from(config$r);
const encode$M = (attributes) => attributes?.['w:val'];
const decode$H = (attrs) => attrs?.color;
const attrConfig$m = Object.freeze({
  xmlName: 'w:val',
  sdName: 'color',
  encode: encode$M,
  decode: decode$H,
});
const encode$L = (attributes) => attributes?.['w:themeColor'];
const decode$G = (attrs) => attrs?.themeColor;
const attrConfig$l = Object.freeze({
  xmlName: 'w:themeColor',
  sdName: 'themeColor',
  encode: encode$L,
  decode: decode$G,
});
const encode$K = (attributes) => attributes?.['w:themeTint'];
const decode$F = (attrs) => attrs?.themeTint;
const attrConfig$k = Object.freeze({
  xmlName: 'w:themeTint',
  sdName: 'themeTint',
  encode: encode$K,
  decode: decode$F,
});
const encode$J = (attributes) => attributes?.['w:themeShade'];
const decode$E = (attrs) => attrs?.themeShade;
const attrConfig$j = Object.freeze({
  xmlName: 'w:themeShade',
  sdName: 'themeShade',
  encode: encode$J,
  decode: decode$E,
});
const validXmlAttributes$j = [attrConfig$m, attrConfig$l, attrConfig$k, attrConfig$j];
const XML_NODE_NAME$r = 'w:color';
const SD_ATTR_KEY$a = 'color';
const encode$I = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const sourceAttrs = node?.attributes || {};
  const value = encodedAttrs.color ?? sourceAttrs['w:val'];
  const themeColor = encodedAttrs.themeColor ?? sourceAttrs['w:themeColor'];
  const themeTint = encodedAttrs.themeTint ?? sourceAttrs['w:themeTint'];
  const themeShade = encodedAttrs.themeShade ?? sourceAttrs['w:themeShade'];
  const attributes = {};
  attributes['w:val'] = value ?? null;
  if (themeColor !== void 0 && themeColor !== null) attributes['w:themeColor'] = themeColor;
  if (themeTint !== void 0 && themeTint !== null) attributes['w:themeTint'] = themeTint;
  if (themeShade !== void 0 && themeShade !== null) attributes['w:themeShade'] = themeShade;
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$r,
    sdNodeOrKeyName: SD_ATTR_KEY$a,
    attributes,
  };
};
const config$q = {
  xmlName: XML_NODE_NAME$r,
  sdNodeOrKeyName: SD_ATTR_KEY$a,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$I,
  attributes: validXmlAttributes$j,
};
const translator$1k = NodeTranslator.from(config$q);
const encode$H = (attributes) => attributes?.['w:eastAsia'];
const decode$D = (attrs) => attrs?.eastAsia;
const attrConfig$i = Object.freeze({
  xmlName: 'w:eastAsia',
  sdName: 'eastAsia',
  encode: encode$H,
  decode: decode$D,
});
const encode$G = (attributes) => attributes?.['w:ascii'];
const decode$C = (attrs) => attrs?.ascii;
const attrConfig$h = Object.freeze({
  xmlName: 'w:ascii',
  sdName: 'ascii',
  encode: encode$G,
  decode: decode$C,
});
const encode$F = (attributes) => attributes?.['w:hAnsi'];
const decode$B = (attrs) => attrs?.hAnsi;
const attrConfig$g = Object.freeze({
  xmlName: 'w:hAnsi',
  sdName: 'hAnsi',
  encode: encode$F,
  decode: decode$B,
});
const encode$E = (attributes) => attributes?.['w:cs'];
const decode$A = (attrs) => attrs?.cs;
const attrConfig$f = Object.freeze({
  xmlName: 'w:cs',
  sdName: 'cs',
  encode: encode$E,
  decode: decode$A,
});
const encode$D = (attributes) => attributes?.['w:val'];
const decode$z = (attrs) => attrs?.value;
const attrConfig$e = Object.freeze({
  xmlName: 'w:val',
  sdName: 'value',
  encode: encode$D,
  decode: decode$z,
});
const validXmlAttributes$i = [attrConfig$i, attrConfig$h, attrConfig$g, attrConfig$f, attrConfig$e];
const XML_NODE_NAME$q = 'w:rFonts';
const SD_ATTR_KEY$9 = 'fontFamily';
const encode$C = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const sourceAttrs = node?.attributes || {};
  const attributes = {};
  const setAttr = (xmlName, sdName) => {
    if (encodedAttrs[sdName] !== void 0 && encodedAttrs[sdName] !== null) {
      attributes[xmlName] = encodedAttrs[sdName];
    } else if (sourceAttrs[xmlName] !== void 0) {
      attributes[xmlName] = sourceAttrs[xmlName];
    }
  };
  setAttr('w:eastAsia', 'eastAsia');
  setAttr('w:ascii', 'ascii');
  setAttr('w:hAnsi', 'hAnsi');
  setAttr('w:cs', 'cs');
  setAttr('w:val', 'value');
  Object.keys(sourceAttrs).forEach((key2) => {
    if (attributes[key2] === void 0) attributes[key2] = sourceAttrs[key2];
  });
  if (attributes['w:val'] === void 0 && attributes['w:eastAsia']) {
    attributes['w:val'] = attributes['w:eastAsia'];
  }
  if (attributes['w:val'] === void 0) delete attributes['w:val'];
  if (params.inlineDocumentFonts) {
    const font = attributes['w:ascii'];
    if (font) {
      if (!params.inlineDocumentFonts.includes(font)) {
        params.inlineDocumentFonts.push(font);
      }
    }
  }
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$q,
    sdNodeOrKeyName: SD_ATTR_KEY$9,
    attributes,
  };
};
const config$p = {
  xmlName: XML_NODE_NAME$q,
  sdNodeOrKeyName: SD_ATTR_KEY$9,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$C,
  attributes: validXmlAttributes$i,
};
const translator$1j = NodeTranslator.from(config$p);
const encode$B = (attributes) => attributes?.['w:val'];
const decode$y = (attrs) => attrs?.styleId;
const attrConfig$d = Object.freeze({
  xmlName: 'w:val',
  sdName: 'styleId',
  encode: encode$B,
  decode: decode$y,
});
const validXmlAttributes$h = [attrConfig$d];
const XML_NODE_NAME$p = 'w:rStyle';
const SD_ATTR_KEY$8 = 'styleId';
const encode$A = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const value = encodedAttrs.styleId ?? node?.attributes?.['w:val'];
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$p,
    sdNodeOrKeyName: SD_ATTR_KEY$8,
    attributes: { 'w:val': value ?? null },
  };
};
const config$o = {
  xmlName: XML_NODE_NAME$p,
  sdNodeOrKeyName: SD_ATTR_KEY$8,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$A,
  attributes: validXmlAttributes$h,
};
const translator$1i = NodeTranslator.from(config$o);
const encode$z = (attributes) => attributes?.['w:val'];
const decode$x = (attrs) => attrs?.fontSize;
const attrConfig$c = Object.freeze({
  xmlName: 'w:val',
  sdName: 'fontSize',
  encode: encode$z,
  decode: decode$x,
});
const validXmlAttributes$g = [attrConfig$c];
const XML_NODE_NAME$o = 'w:sz';
const SD_ATTR_KEY$7 = 'fontSize';
const encode$y = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const value = encodedAttrs.fontSize ?? node?.attributes?.['w:val'];
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$o,
    sdNodeOrKeyName: SD_ATTR_KEY$7,
    attributes: { 'w:val': value ?? null },
  };
};
const config$n = {
  xmlName: XML_NODE_NAME$o,
  sdNodeOrKeyName: SD_ATTR_KEY$7,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$y,
  attributes: validXmlAttributes$g,
};
const translator$1h = NodeTranslator.from(config$n);
const encode$x = (attributes) => attributes?.['w:val'];
const decode$w = (attrs) => attrs?.fontSizeCs;
const attrConfig$b = Object.freeze({
  xmlName: 'w:val',
  sdName: 'fontSizeCs',
  encode: encode$x,
  decode: decode$w,
});
const validXmlAttributes$f = [attrConfig$b];
const XML_NODE_NAME$n = 'w:szCs';
const SD_ATTR_KEY$6 = 'fontSizeCs';
const encode$w = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const value = encodedAttrs.fontSizeCs ?? node?.attributes?.['w:val'];
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$n,
    sdNodeOrKeyName: SD_ATTR_KEY$6,
    attributes: { 'w:val': value ?? null },
  };
};
const config$m = {
  xmlName: XML_NODE_NAME$n,
  sdNodeOrKeyName: SD_ATTR_KEY$6,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$w,
  attributes: validXmlAttributes$f,
};
const translator$1g = NodeTranslator.from(config$m);
const generateV2HandlerEntity = (handlerName, translator2) => ({
  handlerName,
  handler: (params) => {
    const { nodes } = params;
    if (nodes.length === 0 || nodes[0].name !== translator2.xmlName) {
      return { nodes: [], consumed: 0 };
    }
    const result = translator2.encode(params);
    if (!result) return { nodes: [], consumed: 0 };
    return {
      nodes: Array.isArray(result) ? result : [result],
      consumed: 1,
    };
  },
});
function createSingleAttrPropertyHandler(
  xmlName,
  sdName = null,
  attrName = 'w:val',
  transformEncode = null,
  transformDecode = null,
) {
  if (!sdName) sdName = xmlName.split(':')[1];
  if (!transformEncode) transformEncode = (v) => v;
  if (!transformDecode) transformDecode = (v) => v;
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    encode: ({ nodes }) => {
      return transformEncode(nodes[0]?.attributes?.[attrName]) ?? void 0;
    },
    decode: ({ node }) => {
      const value = node.attrs?.[sdName] != null ? transformDecode(node.attrs[sdName]) : void 0;
      return value != null ? { name: xmlName, attributes: { [attrName]: value } } : void 0;
    },
  };
}
function createMeasurementPropertyHandler(xmlName, sdName = null) {
  if (!sdName) sdName = xmlName.split(':')[1];
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    attributes: [
      createAttributeHandler('w:w', 'value', parseInteger, integerToString),
      createAttributeHandler('w:type'),
    ],
    encode: (_, encodedAttrs) => {
      return encodedAttrs['value'] != null ? encodedAttrs : void 0;
    },
    decode: function ({ node }) {
      const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs[sdName] || {} } });
      return decodedAttrs['w:w'] != null ? { attributes: decodedAttrs } : void 0;
    },
  };
}
function createBorderPropertyHandler(xmlName, sdName = null) {
  if (!sdName) sdName = xmlName.split(':')[1];
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    attributes: [
      createAttributeHandler(
        'w:val',
        'val',
        (v) => (v === 'nil' ? 'none' : v),
        (v) => (v === 'none' ? 'nil' : v),
      ),
      createAttributeHandler(
        'w:color',
        'color',
        (v) => {
          if (v === 'auto') {
            return null;
          } else if (v) {
            return `#${v}`;
          } else {
            return void 0;
          }
        },
        (v) => {
          if (v) {
            return v.replace('#', '');
          } else {
            return void 0;
          }
        },
      ),
      createAttributeHandler('w:themeColor'),
      createAttributeHandler('w:themeTint'),
      createAttributeHandler('w:themeShade'),
      createAttributeHandler('w:sz', 'size', parseInteger, integerToString),
      createAttributeHandler('w:space', null, parseInteger, integerToString),
      createAttributeHandler('w:shadow', null, parseBoolean, booleanToString),
      createAttributeHandler('w:frame', null, parseBoolean, booleanToString),
    ],
    encode: (params, encodedAttrs) => {
      return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
    },
    decode: function ({ node }, context) {
      const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs[sdName] || {} } });
      return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
    },
  };
}
const createAttributeHandler = (xmlName, sdName = null, transformEncode = null, transformDecode = null) => {
  if (!transformEncode) transformEncode = (v) => v;
  if (!transformDecode) transformDecode = (v) => v;
  if (!sdName) sdName = xmlName.split(':')[1];
  return {
    xmlName,
    sdName,
    encode: (attributes) => transformEncode(attributes[xmlName]),
    decode: (attributes) => transformDecode(attributes[sdName]),
  };
};
function encodeProperties(node, translatorsByXmlName, asArray = false) {
  if (!node?.elements || node.elements.length === 0) {
    return asArray ? [] : {};
  }
  const attributes = asArray ? [] : {};
  node.elements.forEach((el) => {
    const translator2 = translatorsByXmlName[el.name];
    if (translator2) {
      const encodedAttr = translator2.encode({ nodes: [el] });
      if (encodedAttr != null) {
        if (asArray) {
          attributes.push({ [translator2.sdNodeOrKeyName]: encodedAttr });
        } else {
          attributes[translator2.sdNodeOrKeyName] = encodedAttr;
        }
      }
    }
  });
  return attributes;
}
function decodeProperties(translatorsBySdName, properties) {
  if (!properties || typeof properties !== 'object') {
    return [];
  }
  const elements = [];
  Object.keys(properties).forEach((key2) => {
    const translator2 = translatorsBySdName[key2];
    if (translator2) {
      const result = translator2.decode({ node: { attrs: { [key2]: properties[key2] } } });
      if (result != null) {
        result.name = translator2.xmlName;
        elements.push(result);
      }
    }
  });
  return elements;
}
function createNestedPropertiesTranslator(xmlName, sdName, propertyTranslators2, defaultEncodedAttrs = {}) {
  const propertyTranslatorsByXmlName = {};
  const propertyTranslatorsBySdName = {};
  propertyTranslators2.forEach((translator2) => {
    propertyTranslatorsByXmlName[translator2.xmlName] = translator2;
    propertyTranslatorsBySdName[translator2.sdNodeOrKeyName] = translator2;
  });
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    type: NodeTranslator.translatorTypes.NODE,
    attributes: [],
    encode: (params) => {
      const { nodes } = params;
      const node = nodes[0];
      const attributes = { ...defaultEncodedAttrs, ...encodeProperties(node, propertyTranslatorsByXmlName) };
      return Object.keys(attributes).length > 0 ? attributes : void 0;
    },
    decode: (params) => {
      const currentValue = params.node.attrs?.[sdName];
      const elements = decodeProperties(propertyTranslatorsBySdName, currentValue);
      const newNode = {
        name: xmlName,
        type: 'element',
        attributes: {},
        elements,
      };
      return newNode;
    },
  };
}
const parseBoolean = (value) => (value != null ? ['1', 'true'].includes(value) : void 0);
const booleanToString = (value) => (value != null ? (value ? '1' : '0') : void 0);
const parseInteger = (value) => {
  if (value == null) return void 0;
  const intValue = parseInt(value, 10);
  return isNaN(intValue) ? void 0 : intValue;
};
const integerToString = (value) => {
  const intValue = parseInteger(value);
  return intValue != void 0 ? String(intValue) : void 0;
};
const XML_NODE_NAME$m = 'w:caps';
const SD_ATTR_KEY$5 = 'textTransform';
const encode$v = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes[0];
  if (!node) return void 0;
  let result;
  if (!['false', '0'].includes(encodedAttrs.val)) {
    result = 'uppercase';
  } else {
    return void 0;
  }
  return {
    type: 'attr',
    xmlName: XML_NODE_NAME$m,
    sdNodeOrKeyName: SD_ATTR_KEY$5,
    attributes: { [SD_ATTR_KEY$5]: result },
  };
};
const config$l = {
  xmlName: XML_NODE_NAME$m,
  sdNodeOrKeyName: SD_ATTR_KEY$5,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$v,
  attributes: [createAttributeHandler('w:val')],
};
const translator$1f = NodeTranslator.from(config$l);
const runPropertyTranslators = Object.freeze({
  'w:b': translator$1o,
  'w:i': translator$1n,
  'w:u': translator$1m,
  'w:strike': translator$1l,
  'w:color': translator$1k,
  'w:highlight': translator$1r,
  'w:rFonts': translator$1j,
  'w:rStyle': translator$1i,
  'w:sz': translator$1h,
  'w:szCs': translator$1g,
  'w:caps': translator$1f,
});
const rawRunPropertyXmlNames = Object.freeze(['w:lang', 'w:shd']);
const RAW_CHILD_NAME_SET = new Set(rawRunPropertyXmlNames);
const KNOWN_CHILD_XML_NAMES = /* @__PURE__ */ new Set([...Object.keys(runPropertyTranslators), ...RAW_CHILD_NAME_SET]);
const toRunPropertyEntry = (candidate) => {
  if (!candidate || candidate.type !== 'attr') return null;
  const xmlName = candidate.xmlName || candidate.name;
  if (!xmlName) return null;
  return {
    xmlName,
    attributes: { ...(candidate.attributes || {}) },
  };
};
const XML_NODE_NAME$l = 'w:rPr';
const SD_ATTR_KEY$4 = 'runProperties';
const encode$u = (params) => {
  const { nodes } = params;
  const node = nodes?.[0] || {};
  const contents = Array.isArray(node.elements) ? node.elements : [];
  const runPropsArray = contents.reduce(
    (acc, child) => {
      if (!child || typeof child !== 'object') return acc;
      const xmlName = child.name;
      if (!KNOWN_CHILD_XML_NAMES.has(xmlName)) return acc;
      const translator2 = runPropertyTranslators[xmlName];
      let entry = null;
      if (translator2) {
        const encoded = translator2.encode({ ...params, nodes: [child] }) || null;
        entry = toRunPropertyEntry(encoded);
      } else if (RAW_CHILD_NAME_SET.has(xmlName)) {
        entry = toRunPropertyEntry({
          type: 'attr',
          xmlName,
          attributes: { ...(child.attributes || {}) },
        });
      }
      if (entry) acc.push(entry);
      return acc;
    },
    /** @type {{ xmlName: string, attributes: Record<string, any> }[]} */
    [],
  );
  return {
    type: 'attr',
    xmlName: 'w:rPr',
    sdNodeOrKeyName: 'runProperties',
    attributes: runPropsArray,
  };
};
const config$k = {
  xmlName: XML_NODE_NAME$l,
  sdNodeOrKeyName: SD_ATTR_KEY$4,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$u,
};
const translator$1e = NodeTranslator.from(config$k);
const EAST_ASIAN_CHARACTER_REGEX =
  /[\u1100-\u11FF\u2E80-\u2EFF\u2F00-\u2FDF\u3040-\u30FF\u3100-\u312F\u3130-\u318F\u31A0-\u31BF\u3400-\u4DBF\u4E00-\u9FFF\uA960-\uA97F\uAC00-\uD7AF\uF900-\uFAFF\uFF00-\uFFEF]/u;
const containsEastAsianCharacters = (text) => EAST_ASIAN_CHARACTER_REGEX.test(text);
const collectRunProperties = (params, rPrNode, translator2 = translator$1e) => {
  if (!rPrNode) return { entries: [], hadRPr: false, styleChangeMarks: [] };
  const result = translator2.encode({ ...params, nodes: [rPrNode] }) || {};
  let entries = [];
  if (Array.isArray(result.attributes) && result.attributes.length) {
    entries = result.attributes.map((attr) => ({
      xmlName: attr?.xmlName,
      attributes: { ...(attr?.attributes || {}) },
    }));
  } else if (Array.isArray(rPrNode.elements) && rPrNode.elements.length) {
    entries = rPrNode.elements
      .filter((el) => el && typeof el === 'object')
      .map((el) => ({
        xmlName: el.name,
        attributes: { ...(el.attributes || {}) },
      }));
  }
  const legacyMarks = parseMarks(rPrNode, [], params?.docx) || [];
  const styleChangeMarks = handleStyleChangeMarks(rPrNode, legacyMarks) || [];
  return { entries, hadRPr: true, styleChangeMarks };
};
const buildRunAttrs = (encodedAttrs = {}, hadRPr, runProps) => {
  const base = { ...(encodedAttrs || {}) };
  if (hadRPr) {
    base.runProperties = runProps.length ? runProps : null;
  }
  return base;
};
const ensureInlineMarks = (marks, inlineMarks = []) => {
  inlineMarks.forEach(({ type, attrs }) => {
    if (!type) return;
    if (marks.some((mark) => mark?.type === type)) return;
    marks.push(attrs ? { type, attrs: { ...attrs } } : { type });
  });
};
const ensureTextStyleMark = (marks, textStyleAttrs) => {
  if (!textStyleAttrs) return;
  const existingTextStyle = marks.find((mark) => mark?.type === 'textStyle');
  if (existingTextStyle) {
    existingTextStyle.attrs = { ...(existingTextStyle.attrs || {}), ...textStyleAttrs };
    return;
  }
  marks.push({ type: 'textStyle', attrs: { ...textStyleAttrs } });
};
const normalizeTextStyleAttrsForNode = (textStyleAttrs, node) => {
  if (!textStyleAttrs || typeof textStyleAttrs !== 'object') return null;
  const normalized = { ...textStyleAttrs };
  const eastAsiaFont = normalized.eastAsiaFontFamily;
  if (eastAsiaFont) {
    delete normalized.eastAsiaFontFamily;
    const text = typeof node?.text === 'string' ? node.text : null;
    const shouldUseEastAsia = typeof text === 'string' && containsEastAsianCharacters(text);
    if (shouldUseEastAsia) {
      normalized.fontFamily = eastAsiaFont;
    }
  }
  return Object.keys(normalized).length ? normalized : null;
};
const applyRunMarks = (node, inlineMarks, textStyleAttrs) => {
  if (!node || typeof node !== 'object') return node;
  const baseMarks = Array.isArray(node.marks) ? node.marks : [];
  const marks = baseMarks.map((mark) => cloneMark$1(mark));
  ensureInlineMarks(marks, inlineMarks);
  if (node.type === 'text') {
    const normalizedTextStyle = normalizeTextStyleAttrsForNode(textStyleAttrs, node);
    ensureTextStyleMark(marks, normalizedTextStyle);
  }
  return { ...node, marks };
};
const deriveStyleMarks = ({ docx, paragraphStyleId, runStyleId }) => {
  const paragraphStyleMarks = collectStyleMarks(paragraphStyleId, docx);
  if (paragraphStyleId?.startsWith('TOC')) {
    return paragraphStyleMarks;
  }
  let runStyleMarks = collectStyleMarks(runStyleId, docx);
  const inlineMarks = mergeInlineMarkSets(paragraphStyleMarks.inlineMarks, runStyleMarks.inlineMarks);
  const textStyleAttrs = mergeTextStyleAttrs(paragraphStyleMarks.textStyleAttrs, runStyleMarks.textStyleAttrs);
  return { inlineMarks, textStyleAttrs };
};
const collectStyleMarks = (styleId, docx, seen = /* @__PURE__ */ new Set()) => {
  if (!styleId || !docx || seen.has(styleId)) return { inlineMarks: [], textStyleAttrs: null };
  seen.add(styleId);
  const chain = collectStyleChain(styleId, docx, seen);
  if (!chain.length) return { inlineMarks: [], textStyleAttrs: null };
  const inlineMap = /* @__PURE__ */ new Map();
  let textStyleAttrs = {};
  chain.forEach((styleTag) => {
    const marks = extractMarksFromStyle(styleTag, docx);
    marks.inlineMarks.forEach((mark) => {
      inlineMap.set(mark.type, mark.attrs ? { type: mark.type, attrs: { ...mark.attrs } } : { type: mark.type });
    });
    if (marks.textStyleAttrs) textStyleAttrs = { ...textStyleAttrs, ...marks.textStyleAttrs };
  });
  return {
    inlineMarks: Array.from(inlineMap.values()),
    textStyleAttrs: Object.keys(textStyleAttrs).length ? textStyleAttrs : null,
  };
};
const collectStyleChain = (styleId, docx, seen) => {
  if (!styleId || !docx) return [];
  const styleTag = findStyleTag(docx, styleId);
  if (!styleTag || !styleTag.elements) return [];
  const basedOn = styleTag.elements?.find((el) => el.name === 'w:basedOn')?.attributes?.['w:val'];
  let chain = [];
  if (basedOn && !seen.has(basedOn)) {
    seen.add(basedOn);
    chain = collectStyleChain(basedOn, docx, seen);
  }
  chain.push(styleTag);
  return chain;
};
const findStyleTag = (docx, styleId) => {
  const stylesFile = docx?.['word/styles.xml'];
  if (!stylesFile?.elements?.length) return null;
  const candidates = [];
  stylesFile.elements.forEach((el) => {
    if (!el) return;
    if (el.name === 'w:styles' && Array.isArray(el.elements)) {
      el.elements.forEach((child) => {
        if (child?.name === 'w:style') candidates.push(child);
      });
      return;
    }
    if (el.name === 'w:style') {
      candidates.push(el);
      return;
    }
    if (Array.isArray(el.elements)) {
      el.elements.forEach((child) => {
        if (child?.name === 'w:style') candidates.push(child);
      });
    }
  });
  return candidates.find((tag) => tag?.attributes?.['w:styleId'] === styleId) || null;
};
const extractMarksFromStyle = (styleTag, docx) => {
  const rPr = styleTag?.elements?.find((el) => el.name === 'w:rPr');
  if (!rPr) return { inlineMarks: [], textStyleAttrs: null };
  const marks = parseMarks(rPr, [], docx) || [];
  const inlineMarks = [];
  let textStyleAttrs = {};
  marks.forEach((mark) => {
    if (!mark) return;
    if (mark.type === 'textStyle') {
      const attrs = mark.attrs || {};
      if (Object.keys(attrs).length) textStyleAttrs = { ...textStyleAttrs, ...attrs };
      return;
    }
    if (mark.type) inlineMarks.push(mark.attrs ? { type: mark.type, attrs: { ...mark.attrs } } : { type: mark.type });
  });
  return {
    inlineMarks,
    textStyleAttrs: Object.keys(textStyleAttrs).length ? textStyleAttrs : null,
  };
};
const mergeInlineMarkSets = (...markSets) => {
  const map = /* @__PURE__ */ new Map();
  markSets.filter(Boolean).forEach((marks) => {
    marks.forEach((mark) => {
      if (!mark || !mark.type) return;
      map.set(mark.type, mark.attrs ? { type: mark.type, attrs: { ...mark.attrs } } : { type: mark.type });
    });
  });
  return Array.from(map.values());
};
const mergeTextStyleAttrs = (...attrsList) => {
  const merged = attrsList
    .filter((attrs) => attrs && Object.keys(attrs).length)
    .reduce((acc, attrs) => ({ ...acc, ...attrs }), {});
  return Object.keys(merged).length ? merged : null;
};
const cloneRunAttrs = (attrs) => {
  const clone = { ...attrs };
  if (Array.isArray(attrs?.runProperties)) {
    clone.runProperties = attrs.runProperties.map((entry) => ({
      xmlName: entry?.xmlName,
      attributes: { ...(entry?.attributes || {}) },
    }));
  }
  return clone;
};
const cloneMark$1 = (mark) => {
  if (!mark || typeof mark !== 'object') return mark;
  const cloned = { ...mark };
  if (mark.attrs && typeof mark.attrs === 'object') {
    cloned.attrs = { ...mark.attrs };
    if (Array.isArray(mark.attrs.runProperties)) {
      cloned.attrs.runProperties = mark.attrs.runProperties.map((entry) => ({
        xmlName: entry?.xmlName,
        attributes: { ...(entry?.attributes || {}) },
      }));
    }
  }
  return cloned;
};
const normalizeBool = (value) => {
  if (value === void 0 || value === null) return true;
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value !== 0;
  const normalized = String(value).trim().toLowerCase();
  if (normalized === '0' || normalized === 'false' || normalized === 'off') return false;
  if (normalized === '1' || normalized === 'true' || normalized === 'on') return true;
  return true;
};
const createRunPropertiesElement = (entries = []) => {
  if (!Array.isArray(entries) || !entries.length) return null;
  const elements = entries
    .map((entry) => {
      if (!entry || !entry.xmlName) return null;
      return {
        name: entry.xmlName,
        attributes: { ...(entry.attributes || {}) },
      };
    })
    .filter(Boolean);
  if (!elements.length) return null;
  return {
    name: 'w:rPr',
    elements,
  };
};
const cloneXmlNode = (nodeLike) => {
  if (!nodeLike || typeof nodeLike !== 'object') return nodeLike;
  return {
    name: nodeLike.name,
    type: nodeLike.type,
    attributes: nodeLike.attributes ? { ...nodeLike.attributes } : void 0,
    elements: Array.isArray(nodeLike.elements) ? nodeLike.elements.map((el) => cloneXmlNode(el)) : void 0,
    text: nodeLike.text,
  };
};
const applyRunPropertiesTemplate = (runNode, runPropertiesTemplate) => {
  if (!runNode || !runPropertiesTemplate) return;
  if (!Array.isArray(runNode.elements)) runNode.elements = [];
  let runProps = runNode.elements.find((el) => el?.name === 'w:rPr');
  if (!runProps) {
    runProps = { name: 'w:rPr', elements: [] };
    runNode.elements.unshift(runProps);
  }
  if (!Array.isArray(runProps.elements)) runProps.elements = [];
  if (runPropertiesTemplate.attributes) {
    runProps.attributes = {
      ...(runProps.attributes || {}),
      ...runPropertiesTemplate.attributes,
    };
  }
  const isValidRunPropName = (name) => typeof name === 'string' && name.includes(':');
  runProps.elements = runProps.elements.filter((entry) => isValidRunPropName(entry?.name));
  const existingNames = new Set(runProps.elements.map((el) => el?.name));
  (runPropertiesTemplate.elements || []).forEach((entry) => {
    if (!isValidRunPropName(entry?.name) || existingNames.has(entry.name)) return;
    runProps.elements.push(cloneXmlNode(entry));
    existingNames.add(entry.name);
  });
};
const splitRunProperties = (entries = [], docx = null) => {
  const remainingProps = [];
  const inlineMarks = [];
  const textStyleAttrs = {};
  let hasTextStyle = false;
  let highlightColor = null;
  let runStyleId = null;
  entries.forEach((entry) => {
    if (!entry || !entry.xmlName) return;
    const attributes = entry.attributes || {};
    switch (entry.xmlName) {
      case 'w:b': {
        const val = normalizeBool(attributes['w:val']);
        inlineMarks.push(val ? { type: 'bold' } : { type: 'bold', attrs: { value: '0' } });
        break;
      }
      case 'w:i': {
        const val = normalizeBool(attributes['w:val']);
        inlineMarks.push(val ? { type: 'italic' } : { type: 'italic', attrs: { value: '0' } });
        break;
      }
      case 'w:u': {
        const rawVal = attributes['w:val'];
        const underlineType = rawVal == null || rawVal === '' ? 'single' : String(rawVal);
        const attrs = {};
        if (underlineType.toLowerCase() === 'none' || underlineType === '0') {
          attrs.underlineType = 'none';
        } else {
          attrs.underlineType = underlineType;
          const colorRaw = attributes['w:color'];
          if (typeof colorRaw === 'string' && colorRaw.toLowerCase() !== 'auto') {
            const normalizedColor = normalizeHexColor(colorRaw);
            if (normalizedColor) attrs.underlineColor = `#${normalizedColor}`;
          }
        }
        if (attributes['w:themeColor']) attrs.underlineThemeColor = attributes['w:themeColor'];
        if (attributes['w:themeTint']) attrs.underlineThemeTint = attributes['w:themeTint'];
        if (attributes['w:themeShade']) attrs.underlineThemeShade = attributes['w:themeShade'];
        inlineMarks.push({ type: 'underline', attrs });
        break;
      }
      case 'w:color': {
        const raw = attributes['w:val'];
        if (typeof raw === 'string' && raw) {
          hasTextStyle = true;
          textStyleAttrs.color = `#${raw.replace('#', '').toUpperCase()}`;
        }
        break;
      }
      case 'w:caps': {
        if (attributes['textTransform'] != null) {
          hasTextStyle = true;
          textStyleAttrs.textTransform = attributes['textTransform'];
        }
        break;
      }
      case 'w:rFonts': {
        const asciiFamily =
          attributes['w:ascii'] || attributes['w:hAnsi'] || (attributes['w:eastAsia'] ? void 0 : attributes['w:val']);
        const eastAsiaFamily = attributes['w:eastAsia'];
        if (asciiFamily) {
          hasTextStyle = true;
          textStyleAttrs.fontFamily = SuperConverter.toCssFontFamily(asciiFamily, docx);
        }
        if (eastAsiaFamily) {
          hasTextStyle = true;
          const eastAsiaCss = SuperConverter.toCssFontFamily(eastAsiaFamily, docx);
          if (!asciiFamily || eastAsiaCss !== textStyleAttrs.fontFamily) {
            textStyleAttrs.eastAsiaFontFamily = eastAsiaCss;
          }
        }
        break;
      }
      case 'w:sz':
      case 'w:szCs': {
        const rawSize = Number(attributes['w:val']);
        const attrName = entry.xmlName === 'w:sz' ? 'fontSize' : 'fontSizeCs';
        if (Number.isFinite(rawSize) && rawSize > 0) {
          hasTextStyle = true;
          textStyleAttrs[attrName] = `${rawSize / 2}pt`;
        }
        break;
      }
      case 'w:strike': {
        const val = normalizeBool(attributes['w:val']);
        inlineMarks.push(val ? { type: 'strike' } : { type: 'strike', attrs: { value: '0' } });
        break;
      }
      case 'w:highlight': {
        const color = attributes['w:val'];
        if (typeof color === 'string' && color) {
          highlightColor = color.toLowerCase() === 'none' ? 'transparent' : color;
        }
        break;
      }
      case 'w:shd': {
        const fill = attributes['w:fill'];
        const shdVal = attributes['w:val'];
        if (fill && String(fill).toLowerCase() !== 'auto') {
          highlightColor = `#${String(fill).replace('#', '')}`;
        } else if (typeof shdVal === 'string') {
          const normalized = shdVal.toLowerCase();
          if (normalized === 'clear' || normalized === 'nil' || normalized === 'none') {
            highlightColor = 'transparent';
          }
        }
        break;
      }
      case 'w:rStyle': {
        if (typeof attributes['w:val'] === 'string') runStyleId = attributes['w:val'];
        remainingProps.push({ xmlName: entry.xmlName, attributes: { ...attributes } });
        break;
      }
      default: {
        remainingProps.push({ xmlName: entry.xmlName, attributes: { ...attributes } });
      }
    }
  });
  if (highlightColor) inlineMarks.push({ type: 'highlight', attrs: { color: highlightColor } });
  return {
    remainingProps,
    inlineMarks,
    textStyleAttrs: hasTextStyle ? textStyleAttrs : null,
    runStyleId,
  };
};
const cloneMark = (mark) => {
  if (!mark) return mark;
  return {
    ...mark,
    attrs: mark.attrs ? { ...mark.attrs } : void 0,
  };
};
const cloneNode = (node) => {
  if (!node || typeof node !== 'object') return node;
  const cloned = { ...node };
  if (node.marks) cloned.marks = node.marks.map((mark) => cloneMark(mark));
  if (node.content) cloned.content = node.content.map((child) => cloneNode(child));
  if (node.elements) cloned.elements = node.elements.map((el) => cloneNode(el));
  if (node.attributes) cloned.attributes = { ...node.attributes };
  return cloned;
};
const cloneRuns = (runs = []) => runs.map((run2) => cloneNode(run2));
const prepareRunTrackingContext = (node = {}) => {
  const marks = Array.isArray(node.marks) ? node.marks : [];
  const trackingMarks = marks.filter(
    (mark) => mark?.type === TrackInsertMarkName || mark?.type === TrackDeleteMarkName,
  );
  if (!trackingMarks.length) {
    return { runNode: node, trackingMarksByType: /* @__PURE__ */ new Map() };
  }
  const trackingMarksByType = /* @__PURE__ */ new Map();
  trackingMarks.forEach((mark) => {
    if (mark?.type) trackingMarksByType.set(mark.type, cloneMark(mark));
  });
  const preservedMarks = marks
    .filter((mark) => mark?.type !== TrackInsertMarkName && mark?.type !== TrackDeleteMarkName)
    .map((mark) => cloneMark(mark));
  const clonedContent = Array.isArray(node.content)
    ? node.content.map((child) => {
        const childClone = cloneNode(child);
        const childMarks = Array.isArray(childClone.marks) ? childClone.marks.slice() : [];
        trackingMarks.forEach((mark) => {
          childMarks.push(cloneMark(mark));
        });
        childClone.marks = childMarks;
        return childClone;
      })
    : [];
  return {
    runNode: {
      ...cloneNode(node),
      marks: preservedMarks,
      content: clonedContent,
    },
    trackingMarksByType,
  };
};
const mapTrackingAttrs = (mark, attrMap) => {
  const source = mark?.attrs || {};
  const mapped = {};
  attrMap.forEach((targetKey, sourceKey) => {
    if (source[sourceKey] != null) mapped[targetKey] = source[sourceKey];
  });
  return mapped;
};
const renameTextElementsForDeletion = (node) => {
  if (!node || typeof node !== 'object') return;
  if (node.name === 'w:t') node.name = 'w:delText';
  if (Array.isArray(node.elements)) node.elements.forEach(renameTextElementsForDeletion);
};
const ensureTrackedWrapper = (runs, trackingMarksByType = /* @__PURE__ */ new Map()) => {
  if (!Array.isArray(runs) || !runs.length) return runs;
  const firstRun = runs[0];
  if (firstRun?.name === 'w:ins' || firstRun?.name === 'w:del') {
    return runs;
  }
  if (!trackingMarksByType.size) return runs;
  if (trackingMarksByType.has(TrackInsertMarkName)) {
    const mark = trackingMarksByType.get(TrackInsertMarkName);
    const clonedRuns = cloneRuns(runs);
    const wrapper = {
      name: 'w:ins',
      attributes: mapTrackingAttrs(
        mark,
        /* @__PURE__ */ new Map([
          ['id', 'w:id'],
          ['author', 'w:author'],
          ['authorEmail', 'w:authorEmail'],
          ['date', 'w:date'],
        ]),
      ),
      elements: clonedRuns,
    };
    return [wrapper];
  }
  if (trackingMarksByType.has(TrackDeleteMarkName)) {
    const mark = trackingMarksByType.get(TrackDeleteMarkName);
    const clonedRuns = cloneRuns(runs);
    clonedRuns.forEach(renameTextElementsForDeletion);
    const wrapper = {
      name: 'w:del',
      attributes: mapTrackingAttrs(mark, /* @__PURE__ */ new Map([['id', 'w:id']])),
      elements: clonedRuns,
    };
    return [wrapper];
  }
  return runs;
};
const XML_NODE_NAME$k = 'w:hyperlink';
const SD_NODE_NAME$f = 'link';
const _createAttributeHandler = (xmlName, sdName) => ({
  xmlName,
  sdName,
  encode: (attributes) => attributes[xmlName],
  decode: (attributes) => attributes[sdName],
});
const validXmlAttributes$e = [
  _createAttributeHandler('w:anchor', 'anchor'),
  _createAttributeHandler('w:docLocation', 'docLocation'),
  {
    xmlName: 'w:history',
    sdName: 'history',
    encode: (attributes) => attributes['w:history'] === '1' || attributes['w:history'] === 'true',
    decode: (attributes) => (attributes['history'] ? '1' : '0'),
  },
  _createAttributeHandler('w:tooltip', 'tooltip'),
  _createAttributeHandler('r:id', 'rId'),
  _createAttributeHandler('w:tgtFrame', 'target'),
];
const encode$t = (params, encodedAttrs) => {
  const { nodes, docx, nodeListHandler } = params;
  const node = nodes[0];
  let href = _resolveHref(docx, encodedAttrs);
  const linkMark = { type: 'link', attrs: { ...encodedAttrs, href } };
  const referenceNodeTypes = ['sd:pageReference', 'sd:autoPageNumber', 'sd:totalPageNumber'];
  const contentNodes = node.elements.filter((el) => el.name === 'w:r' || referenceNodeTypes.includes(el.name));
  contentNodes.forEach((contentNode) => {
    const existingMarks = Array.isArray(contentNode.marks) ? contentNode.marks : [];
    const marksWithoutLink = existingMarks.filter((mark) => mark?.type !== 'link');
    contentNode.marks = [...marksWithoutLink, linkMark];
  });
  const updatedNode = nodeListHandler.handler({
    ...params,
    nodes: contentNodes,
    path: [...(params.path || []), node],
  });
  return updatedNode;
};
const _resolveHref = (docx, encodedAttrs) => {
  const rels = docx['word/_rels/document.xml.rels'];
  const relationships = rels.elements.find((el) => el.name === 'Relationships');
  const { elements } = relationships;
  const { rId, anchor } = encodedAttrs;
  let href;
  if (!rId && anchor) {
    href = `#${anchor}`;
  } else if (rId) {
    const rel = elements.find((el) => el.attributes['Id'] === rId) || {};
    const { attributes: relAttributes = {} } = rel;
    href = relAttributes['Target'];
  }
  return href;
};
function decode$v(params) {
  const { hyperlinkGroup = [params.node] } = params.extraParams || {};
  const node = hyperlinkGroup[0];
  const linkMark = node.marks.find((m) => m.type === 'link');
  const linkAttrs = this.decodeAttributes({ ...params, node: linkMark });
  let { href: link, anchor } = linkMark.attrs;
  if (!linkAttrs['r:id'] && !anchor) {
    linkAttrs['r:id'] = _addNewLinkRelationship(params, link);
  }
  let contentNodes = [];
  hyperlinkGroup.forEach((linkNode) => {
    if ('marks' in linkNode) {
      linkNode.marks = linkNode.marks.filter((m) => m.type !== 'link');
    } else {
      linkNode.attrs.marksAsAttrs = linkNode.attrs.marksAsAttrs.filter((m) => m.type !== 'link');
    }
    const outputNode = exportSchemaToJson({ ...params, node: linkNode });
    if (outputNode) {
      if (outputNode instanceof Array) contentNodes.push(...outputNode);
      else contentNodes.push(outputNode);
    }
  });
  const newNode = {
    name: 'w:hyperlink',
    type: 'element',
    attributes: {
      ...linkAttrs,
    },
    elements: contentNodes,
  };
  return newNode;
}
function _addNewLinkRelationship(params, link) {
  let id = generateDocxRandomId();
  if (!params.relationships || !Array.isArray(params.relationships)) {
    params.relationships = [];
  }
  params.relationships.push({
    type: 'element',
    name: 'Relationship',
    attributes: {
      Id: id,
      Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
      Target: link,
      TargetMode: 'External',
    },
  });
  return id;
}
const config$j = {
  xmlName: XML_NODE_NAME$k,
  sdNodeOrKeyName: SD_NODE_NAME$f,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$t,
  decode: decode$v,
  attributes: validXmlAttributes$e,
};
const translator$1d = NodeTranslator.from(config$j);
const encode$s = (attributes) => {
  return attributes['w:rsidR'];
};
const decode$u = (attrs) => {
  return attrs.rsidR;
};
const attrConfig$a = Object.freeze({
  xmlName: 'w:rsidR',
  sdName: 'rsidR',
  encode: encode$s,
  decode: decode$u,
});
const encode$r = (attributes) => {
  return attributes['w:rsidRPr'];
};
const decode$t = (attrs) => {
  return attrs.rsidRPr;
};
const attrConfig$9 = Object.freeze({
  xmlName: 'w:rsidRPr',
  sdName: 'rsidRPr',
  encode: encode$r,
  decode: decode$t,
});
const encode$q = (attributes) => {
  return attributes['w:rsidDel'];
};
const decode$s = (attrs) => {
  return attrs.rsidDel;
};
const attrConfig$8 = Object.freeze({
  xmlName: 'w:rsidDel',
  sdName: 'rsidDel',
  encode: encode$q,
  decode: decode$s,
});
const validXmlAttributes$d = [attrConfig$a, attrConfig$9, attrConfig$8];
const XML_NODE_NAME$j = 'w:r';
const SD_KEY_NAME = 'run';
const encode$p = (params, encodedAttrs = {}) => {
  const { nodes = [], nodeListHandler } = params || {};
  const runNode = nodes[0];
  if (!runNode) return void 0;
  const elements = Array.isArray(runNode.elements) ? runNode.elements : [];
  const rPrNode = elements.find((child) => child?.name === 'w:rPr');
  const contentElements = rPrNode ? elements.filter((el) => el !== rPrNode) : elements;
  const { entries: runPropEntries, hadRPr, styleChangeMarks } = collectRunProperties(params, rPrNode);
  const { remainingProps, inlineMarks, textStyleAttrs, runStyleId } = splitRunProperties(runPropEntries, params?.docx);
  const styleMarks = deriveStyleMarks({
    docx: params?.docx,
    paragraphStyleId: params?.parentStyleId,
    runStyleId,
  });
  const mergedInlineMarks = mergeInlineMarkSets(styleMarks.inlineMarks, inlineMarks);
  let mergedTextStyleAttrs = mergeTextStyleAttrs(styleMarks.textStyleAttrs, textStyleAttrs);
  if (runStyleId) {
    mergedTextStyleAttrs = mergedTextStyleAttrs
      ? { ...mergedTextStyleAttrs, styleId: runStyleId }
      : { styleId: runStyleId };
  }
  const runAttrs = buildRunAttrs(encodedAttrs, hadRPr, remainingProps);
  let runLevelMarks = Array.isArray(runNode.marks) ? runNode.marks.map((mark) => cloneMark$1(mark)) : [];
  if (styleChangeMarks?.length) {
    runLevelMarks = [...runLevelMarks, ...styleChangeMarks.map((mark) => cloneMark$1(mark))];
  }
  const childParams = { ...params, nodes: contentElements };
  const content = nodeListHandler?.handler(childParams) || [];
  const contentWithRunMarks = content.map((child) => {
    if (!child || typeof child !== 'object') return child;
    const baseMarks = Array.isArray(child.marks) ? child.marks.map((mark) => cloneMark$1(mark)) : [];
    if (!runLevelMarks.length) return child;
    return { ...child, marks: [...baseMarks, ...runLevelMarks.map((mark) => cloneMark$1(mark))] };
  });
  const marked2 = contentWithRunMarks.map((child) => applyRunMarks(child, mergedInlineMarks, mergedTextStyleAttrs));
  const filtered = marked2.filter(Boolean);
  const runNodeResult = {
    type: SD_KEY_NAME,
    content: filtered,
  };
  const attrs = cloneRunAttrs(runAttrs);
  if (attrs && Object.keys(attrs).length) {
    if (attrs.runProperties == null) delete attrs.runProperties;
    if (Object.keys(attrs).length) runNodeResult.attrs = attrs;
  }
  if (runLevelMarks.length) {
    runNodeResult.marks = runLevelMarks.map((mark) => cloneMark$1(mark));
  }
  return runNodeResult;
};
const decode$r = (params, decodedAttrs = {}) => {
  const { node } = params || {};
  if (!node) return void 0;
  const isLinkNode = node.marks?.some((m) => m.type === 'link');
  if (isLinkNode) {
    const extraParams = {
      ...params.extraParams,
      linkProcessed: true,
    };
    return translator$1d.decode({ ...params, extraParams });
  }
  const { runNode: runNodeForExport, trackingMarksByType } = prepareRunTrackingContext(node);
  const runAttrs = runNodeForExport.attrs || {};
  const runProperties = Array.isArray(runAttrs.runProperties) ? runAttrs.runProperties : [];
  const exportParams = { ...params, node: runNodeForExport };
  if (!exportParams.editor) {
    exportParams.editor = { extensionService: { extensions: [] } };
  }
  const childElements = translateChildNodes(exportParams) || [];
  let runPropertiesElement = createRunPropertiesElement(runProperties);
  const markElements = processOutputMarks(Array.isArray(runNodeForExport.marks) ? runNodeForExport.marks : []);
  if (markElements.length) {
    if (!runPropertiesElement) {
      runPropertiesElement = generateRunProps(markElements);
    } else {
      if (!Array.isArray(runPropertiesElement.elements)) runPropertiesElement.elements = [];
      const existingNames = new Set(
        runPropertiesElement.elements.map((el) => el?.name).filter((name) => typeof name === 'string'),
      );
      markElements.forEach((element) => {
        if (!element || !element.name || existingNames.has(element.name)) return;
        runPropertiesElement.elements.push({ ...element, attributes: { ...(element.attributes || {}) } });
        existingNames.add(element.name);
      });
    }
  }
  const runPropsTemplate = runPropertiesElement ? cloneXmlNode(runPropertiesElement) : null;
  const applyBaseRunProps = (runNode) => applyRunPropertiesTemplate(runNode, runPropsTemplate);
  const runs = [];
  childElements.forEach((child) => {
    if (!child) return;
    if (child.name === 'w:r') {
      const clonedRun = cloneXmlNode(child);
      applyBaseRunProps(clonedRun);
      runs.push(clonedRun);
      return;
    }
    if (child.name === 'w:hyperlink') {
      const hyperlinkClone = cloneXmlNode(child);
      if (Array.isArray(hyperlinkClone.elements)) {
        hyperlinkClone.elements.forEach((run2) => applyBaseRunProps(run2));
      }
      runs.push(hyperlinkClone);
      return;
    }
    if (child.name === 'w:ins' || child.name === 'w:del') {
      const trackedClone = cloneXmlNode(child);
      if (Array.isArray(trackedClone.elements)) {
        trackedClone.elements.forEach((element) => {
          if (element?.name === 'w:r') applyBaseRunProps(element);
        });
      }
      runs.push(trackedClone);
      return;
    }
    const runWrapper = { name: XML_NODE_NAME$j, elements: [] };
    applyBaseRunProps(runWrapper);
    if (!Array.isArray(runWrapper.elements)) runWrapper.elements = [];
    runWrapper.elements.push(cloneXmlNode(child));
    runs.push(runWrapper);
  });
  const trackedRuns = ensureTrackedWrapper(runs, trackingMarksByType);
  if (!trackedRuns.length) {
    const emptyRun = { name: XML_NODE_NAME$j, elements: [] };
    applyBaseRunProps(emptyRun);
    trackedRuns.push(emptyRun);
  }
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    trackedRuns.forEach((run2) => {
      run2.attributes = { ...(run2.attributes || {}), ...decodedAttrs };
    });
  }
  if (trackedRuns.length === 1) {
    return trackedRuns[0];
  }
  return trackedRuns;
};
const config$i = {
  xmlName: XML_NODE_NAME$j,
  sdNodeOrKeyName: SD_KEY_NAME,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$p,
  decode: decode$r,
  attributes: validXmlAttributes$d,
};
const translator$1c = NodeTranslator.from(config$i);
const translator$1b = NodeTranslator.from({
  xmlName: 'w:cnfStyle',
  sdNodeOrKeyName: 'cnfStyle',
  attributes: [
    'w:evenHBand',
    'w:evenVBand',
    'w:firstColumn',
    'w:firstRow',
    'w:firstRowFirstColumn',
    'w:firstRowLastColumn',
    'w:lastColumn',
    'w:lastRow',
    'w:lastRowFirstColumn',
    'w:lastRowLastColumn',
    'w:oddHBand',
    'w:oddVBand',
  ]
    .map((attr) => createAttributeHandler(attr, null, parseBoolean, booleanToString))
    .concat([createAttributeHandler('w:val')]),
  encode: (_, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function ({ node }) {
    if (!node.attrs?.cnfStyle) return;
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.cnfStyle || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  },
});
const translator$1a = NodeTranslator.from({
  xmlName: 'w:shd',
  sdNodeOrKeyName: 'shading',
  attributes: [
    'w:color',
    'w:fill',
    'w:themeColor',
    'w:themeFill',
    'w:themeFillShade',
    'w:themeFillTint',
    'w:themeShade',
    'w:themeTint',
    'w:val',
  ].map((attr) => createAttributeHandler(attr)),
  encode: (params, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function ({ node }, context) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.shading || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  },
});
const translator$19 = NodeTranslator.from(createMeasurementPropertyHandler('w:tcW', 'cellWidth'));
const translator$18 = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    'w:gridSpan',
    null,
    'w:val',
    (v) => parseInteger(v) ?? void 0,
    (v) => integerToString(v),
  ),
);
const translator$17 = NodeTranslator.from(createSingleAttrPropertyHandler('w:vMerge'));
const translator$16 = NodeTranslator.from(createBorderPropertyHandler('w:bottom'));
const translator$15 = NodeTranslator.from(createMeasurementPropertyHandler('w:bottom', 'marginBottom'));
const translator$14 = NodeTranslator.from(createBorderPropertyHandler('w:end'));
const translator$13 = NodeTranslator.from(createMeasurementPropertyHandler('w:end', 'marginEnd'));
const translator$12 = NodeTranslator.from(createBorderPropertyHandler('w:insideH'));
const translator$11 = NodeTranslator.from(createBorderPropertyHandler('w:insideV'));
const translator$10 = NodeTranslator.from(createBorderPropertyHandler('w:left'));
const translator$$ = NodeTranslator.from(createMeasurementPropertyHandler('w:left', 'marginLeft'));
const translator$_ = NodeTranslator.from(createBorderPropertyHandler('w:right'));
const translator$Z = NodeTranslator.from(createMeasurementPropertyHandler('w:right', 'marginRight'));
const translator$Y = NodeTranslator.from(createBorderPropertyHandler('w:start'));
const translator$X = NodeTranslator.from(createMeasurementPropertyHandler('w:start', 'marginStart'));
const translator$W = NodeTranslator.from(createBorderPropertyHandler('w:top'));
const translator$V = NodeTranslator.from(createMeasurementPropertyHandler('w:top', 'marginTop'));
const translator$U = NodeTranslator.from(createBorderPropertyHandler('w:tl2br'));
const translator$T = NodeTranslator.from(createBorderPropertyHandler('w:tr2bl'));
const propertyTranslators$6 = [
  translator$W,
  translator$Y,
  translator$10,
  translator$16,
  translator$14,
  translator$_,
  translator$12,
  translator$11,
  translator$U,
  translator$T,
];
const translator$S = NodeTranslator.from(
  createNestedPropertiesTranslator('w:tcBorders', 'borders', propertyTranslators$6),
);
const translator$R = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    'w:noWrap',
    null,
    'w:val',
    (v) => parseBoolean(v ?? 'true'),
    (v) => booleanToString(v),
  ),
);
const propertyTranslators$5 = [translator$15, translator$13, translator$$, translator$Z, translator$X, translator$V];
const translator$Q = NodeTranslator.from(
  createNestedPropertiesTranslator('w:tcMar', 'cellMargins', propertyTranslators$5),
);
const translator$P = NodeTranslator.from(createSingleAttrPropertyHandler('w:textDirection'));
const translator$O = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    'w:tcFitText',
    null,
    'w:val',
    (v) => parseBoolean(v ?? 'true'),
    (v) => booleanToString(v),
  ),
);
const translator$N = NodeTranslator.from(createSingleAttrPropertyHandler('w:vAlign'));
const translator$M = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    'w:hideMark',
    null,
    'w:val',
    (v) => parseBoolean(v ?? 'true'),
    (v) => booleanToString(v),
  ),
);
const translator$L = NodeTranslator.from(createSingleAttrPropertyHandler('w:header'));
const XML_NODE_NAME$i = 'w:headers';
const SD_ATTR_KEY$3 = 'headers';
const encode$o = (params) => {
  const { nodes } = params;
  const node = nodes[0];
  const attributes = encodeProperties(node, { [translator$L.xmlName]: translator$L }, true);
  return {
    xmlName: XML_NODE_NAME$i,
    sdNodeOrKeyName: SD_ATTR_KEY$3,
    attributes,
  };
};
const decode$q = (params) => {
  const { headers = [] } = params.node.attrs || {};
  const newNode = {
    name: XML_NODE_NAME$i,
    attributes: {},
    elements: headers.map((header) =>
      translator$L.decode({
        node: { type: 'header', attrs: header },
      }),
    ),
  };
  return newNode;
};
const config$h = {
  xmlName: XML_NODE_NAME$i,
  sdNodeOrKeyName: SD_ATTR_KEY$3,
  encode: encode$o,
  decode: decode$q,
};
const translator$K = NodeTranslator.from(config$h);
const propertyTranslators$4 = [
  translator$1b,
  translator$19,
  translator$18,
  translator$17,
  translator$S,
  translator$1a,
  translator$R,
  translator$Q,
  translator$P,
  translator$O,
  translator$N,
  translator$M,
  translator$K,
];
const translator$J = NodeTranslator.from(
  createNestedPropertiesTranslator('w:tcPr', 'tableCellProperties', propertyTranslators$4),
);
function handleTableCellNode({
  params,
  node,
  table,
  row,
  rowBorders,
  columnIndex,
  columnWidth = null,
  allColumnWidths = [],
  _referencedStyles,
}) {
  const { nodeListHandler } = params;
  const attributes = {};
  const referencedStyles = _referencedStyles ?? { fontSize: null, fonts: {}, cellMargins: {} };
  const tcPr = node.elements.find((el) => el.name === 'w:tcPr');
  const tableCellProperties = tcPr ? (translator$J.encode({ ...params, nodes: [tcPr] }) ?? {}) : {};
  attributes['tableCellProperties'] = tableCellProperties;
  if (rowBorders?.insideH) {
    rowBorders['bottom'] = rowBorders.insideH;
    delete rowBorders.insideH;
  }
  if (rowBorders?.insideV) {
    rowBorders['right'] = rowBorders.insideV;
    delete rowBorders?.insideV;
  }
  if (rowBorders) attributes['borders'] = { ...rowBorders };
  const inlineBorders = processInlineCellBorders(tableCellProperties.borders, rowBorders);
  if (inlineBorders) attributes['borders'] = Object.assign(attributes['borders'] || {}, inlineBorders);
  const colspan = tableCellProperties.gridSpan;
  if (colspan && !isNaN(parseInt(colspan, 10))) attributes['colspan'] = parseInt(colspan, 10);
  let width = tableCellProperties.cellWidth?.value ? twipsToPixels(tableCellProperties.cellWidth?.value) : null;
  const widthType = tableCellProperties.cellWidth?.type;
  if (widthType) attributes['widthType'] = widthType;
  if (!width && columnWidth) width = columnWidth;
  if (width) {
    attributes['colwidth'] = [width];
    attributes['widthUnit'] = 'px';
    const defaultColWidths = allColumnWidths;
    const hasDefaultColWidths = allColumnWidths && allColumnWidths.length > 0;
    const colspanNum = parseInt(colspan || 1, 10);
    if (colspanNum && colspanNum > 1 && hasDefaultColWidths) {
      let colwidth = [];
      for (let i = 0; i < colspanNum; i++) {
        let colwidthValue = defaultColWidths[columnIndex + i];
        let defaultColwidth = 100;
        if (typeof colwidthValue !== 'undefined') {
          colwidth.push(colwidthValue);
        } else {
          colwidth.push(defaultColwidth);
        }
      }
      if (colwidth.length) {
        attributes['colwidth'] = [...colwidth];
      }
    }
  }
  const background = {
    color: tableCellProperties.shading?.fill,
  };
  if (background.color) attributes['background'] = background;
  const verticalAlign = tableCellProperties.vAlign;
  if (verticalAlign) attributes['verticalAlign'] = verticalAlign;
  attributes.cellMargins = getTableCellMargins(tableCellProperties.cellMargins, referencedStyles);
  const { fontSize, fonts = {} } = referencedStyles;
  const fontFamily = fonts['ascii'];
  if (fontSize) attributes['fontSize'] = fontSize;
  if (fontFamily) attributes['fontFamily'] = fontFamily;
  if (tableCellProperties.vMerge === 'restart') {
    const rows = table.elements.filter((el) => el.name === 'w:tr');
    const currentRowIndex = rows.findIndex((r2) => r2 === row);
    const remainingRows = rows.slice(currentRowIndex + 1);
    const cellsInRow = row.elements.filter((el) => el.name === 'w:tc');
    let cellIndex = cellsInRow.findIndex((el) => el === node);
    let rowspan = 1;
    for (let remainingRow of remainingRows) {
      const firstCell = remainingRow.elements.findIndex((el) => el.name === 'w:tc');
      const cellAtIndex = remainingRow.elements[firstCell + cellIndex];
      if (!cellAtIndex) break;
      const vMerge = getTableCellVMerge(cellAtIndex);
      if (!vMerge || vMerge === 'restart') {
        break;
      }
      rowspan++;
      remainingRow.elements.splice(firstCell + cellIndex, 1);
    }
    attributes['rowspan'] = rowspan;
  }
  return {
    type: 'tableCell',
    content: normalizeTableCellContent(
      nodeListHandler.handler({
        ...params,
        nodes: node.elements,
        path: [...(params.path || []), node],
      }),
      params.editor,
    ),
    attrs: attributes,
  };
}
function normalizeTableCellContent(content, editor) {
  if (!Array.isArray(content) || content.length === 0) return content;
  const normalized = [];
  const pendingForNextBlock = [];
  const schema = editor?.schema;
  const cloneBlock = (node) => {
    if (!node) return node;
    const cloned = { ...node };
    if (Array.isArray(node.content)) {
      cloned.content = [...node.content];
    }
    return cloned;
  };
  const ensureArray = (node) => {
    if (!Array.isArray(node.content)) {
      node.content = [];
    }
    return node.content;
  };
  const isInlineNode = (node) => {
    if (!node || typeof node.type !== 'string') return false;
    if (node.type === 'text') return true;
    if (node.type === 'bookmarkStart' || node.type === 'bookmarkEnd') return true;
    const nodeType = schema?.nodes?.[node.type];
    if (nodeType) {
      if (typeof nodeType.isInline === 'boolean') return nodeType.isInline;
      if (nodeType.spec?.group && typeof nodeType.spec.group === 'string') {
        return nodeType.spec.group.split(' ').includes('inline');
      }
    }
    return false;
  };
  for (const node of content) {
    if (!node || typeof node.type !== 'string') {
      normalized.push(node);
      continue;
    }
    if (!isInlineNode(node)) {
      const blockNode = cloneBlock(node);
      if (pendingForNextBlock.length) {
        const blockContent = ensureArray(blockNode);
        const leadingInline = pendingForNextBlock.splice(0);
        blockNode.content = [...leadingInline, ...blockContent];
      } else if (Array.isArray(blockNode.content)) {
        blockNode.content = [...blockNode.content];
      }
      normalized.push(blockNode);
      continue;
    }
    const targetIsNextBlock = node.type === 'bookmarkStart' || normalized.length === 0;
    if (targetIsNextBlock) {
      pendingForNextBlock.push(node);
    } else {
      const lastIndex = normalized.length - 1;
      const lastNode = normalized[lastIndex];
      if (!lastNode || typeof lastNode.type !== 'string' || isInlineNode(lastNode)) {
        pendingForNextBlock.push(node);
        continue;
      }
      const blockContent = ensureArray(lastNode);
      if (pendingForNextBlock.length) {
        blockContent.push(...pendingForNextBlock.splice(0));
      }
      blockContent.push(node);
    }
  }
  if (pendingForNextBlock.length) {
    if (normalized.length) {
      const lastIndex = normalized.length - 1;
      const lastNode = normalized[lastIndex];
      if (lastNode && typeof lastNode.type === 'string' && !isInlineNode(lastNode)) {
        const blockContent = ensureArray(lastNode);
        blockContent.push(...pendingForNextBlock);
        pendingForNextBlock.length = 0;
      }
    }
    if (pendingForNextBlock.length) {
      normalized.push({
        type: 'paragraph',
        attrs: {},
        content: [...pendingForNextBlock],
      });
      pendingForNextBlock.length = 0;
    }
  }
  return normalized;
}
const processInlineCellBorders = (borders, rowBorders) => {
  if (!borders) return null;
  return ['bottom', 'top', 'left', 'right'].reduce((acc, direction) => {
    const borderAttrs = borders[direction];
    const rowBorderAttrs = rowBorders[direction];
    if (borderAttrs && borderAttrs['val'] !== 'nil') {
      const color = borderAttrs['color'];
      let size = borderAttrs['size'];
      if (size) size = eighthPointsToPixels(size);
      acc[direction] = { color, size, val: borderAttrs['val'] };
      return acc;
    }
    if (borderAttrs && borderAttrs['val'] === 'nil') {
      const border = Object.assign({}, rowBorderAttrs || {});
      if (!Object.keys(border).length) {
        return acc;
      } else {
        border['val'] = 'none';
        acc[direction] = border;
        return acc;
      }
    }
    return acc;
  }, {});
};
const getTableCellVMerge = (node) => {
  const tcPr = node.elements.find((el) => el.name === 'w:tcPr');
  const vMerge = tcPr?.elements?.find((el) => el.name === 'w:vMerge');
  if (!vMerge) return null;
  return vMerge.attributes?.['w:val'] || 'continue';
};
const getTableCellMargins = (inlineMargins, referencedStyles) => {
  const { cellMargins = {} } = referencedStyles;
  return ['left', 'right', 'top', 'bottom'].reduce((acc, direction) => {
    const key2 = `margin${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
    const inlineValue = inlineMargins ? inlineMargins?.[key2]?.value : null;
    const styleValue = cellMargins ? cellMargins[key2] : null;
    if (inlineValue != null) {
      acc[direction] = twipsToPixels(inlineValue);
    } else if (styleValue == null) {
      acc[direction] = void 0;
    } else if (typeof styleValue === 'object') {
      acc[direction] = twipsToPixels(styleValue.value);
    } else {
      acc[direction] = twipsToPixels(styleValue);
    }
    return acc;
  }, {});
};
function translateTableCell(params) {
  const elements = translateChildNodes({
    ...params,
    tableCell: params.node,
  });
  const cellProps = generateTableCellProperties(params.node);
  elements.unshift(cellProps);
  return {
    name: 'w:tc',
    elements,
  };
}
function generateTableCellProperties(node) {
  const tableCellProperties = { ...(node.attrs?.tableCellProperties || {}) };
  const { attrs } = node;
  const { colwidth = [], cellWidthType = 'dxa', widthUnit } = attrs;
  const colwidthSum = colwidth.reduce((acc, curr) => acc + curr, 0);
  const propertiesWidthPixels = twipsToPixels(tableCellProperties.cellWidth?.value);
  if (propertiesWidthPixels !== colwidthSum) {
    tableCellProperties['cellWidth'] = {
      value: widthUnit === 'px' ? pixelsToTwips(colwidthSum) : inchesToTwips(colwidthSum),
      type: cellWidthType,
    };
  }
  const { colspan } = attrs;
  if (colspan > 1 && tableCellProperties.gridSpan !== colspan) {
    tableCellProperties['gridSpan'] = colspan;
  } else if (!colspan || tableCellProperties?.gridSpan === 1) {
    delete tableCellProperties.gridSpan;
  }
  const { background = {} } = attrs;
  if (background?.color && tableCellProperties.shading?.fill !== background?.color) {
    tableCellProperties['shading'] = { fill: background.color };
  } else if (!background?.color && tableCellProperties?.shading?.fill) {
    delete tableCellProperties.shading;
  }
  const { cellMargins } = attrs;
  if (cellMargins) {
    ['left', 'right', 'top', 'bottom'].forEach((side) => {
      const key2 = `margin${side.charAt(0).toUpperCase() + side.slice(1)}`;
      if (cellMargins[side] != null) {
        if (!tableCellProperties.cellMargins) tableCellProperties['cellMargins'] = {};
        let currentPropertyValuePixels = twipsToPixels(tableCellProperties.cellMargins?.[key2]?.value);
        if (currentPropertyValuePixels !== cellMargins[side]) {
          tableCellProperties.cellMargins[key2] = { value: pixelsToTwips(cellMargins[side]), type: 'dxa' };
        }
      } else if (tableCellProperties?.cellMargins?.[key2]) {
        delete tableCellProperties.cellMargins[key2];
      }
    });
  }
  const { verticalAlign } = attrs;
  if (verticalAlign && verticalAlign !== tableCellProperties.vAlign) {
    tableCellProperties['vAlign'] = verticalAlign;
  } else if (!verticalAlign && tableCellProperties?.vAlign) {
    delete tableCellProperties.vAlign;
  }
  const { rowspan } = attrs;
  if (rowspan && rowspan > 1 && tableCellProperties.vMerge !== 'restart') {
    tableCellProperties['vMerge'] = 'restart';
  } else if (attrs.continueMerge) {
    tableCellProperties['vMerge'] = 'continue';
  } else if (tableCellProperties?.vMerge) {
    delete tableCellProperties.vMerge;
  }
  const { borders = {} } = attrs;
  if (!!borders && Object.keys(borders).length) {
    ['top', 'bottom', 'left', 'right'].forEach((side) => {
      if (borders[side]) {
        let currentPropertyValue = tableCellProperties.borders?.[side];
        let currentPropertySizePixels = eighthPointsToPixels(currentPropertyValue?.size);
        let color = borders[side].color;
        if (borders[side].color && color === '#000000') {
          color = 'auto';
        }
        if (
          currentPropertySizePixels !== borders[side].size ||
          currentPropertyValue?.color !== color ||
          borders[side].val !== currentPropertyValue?.val
        ) {
          if (!tableCellProperties.borders) tableCellProperties['borders'] = {};
          tableCellProperties.borders[side] = {
            size: pixelsToEightPoints(borders[side].size || 0),
            color,
            space: borders[side].space || 0,
            val: borders[side].val || 'single',
          };
        }
      } else if (tableCellProperties.borders?.[side]) {
        delete tableCellProperties.borders[side];
      }
    });
  } else if (tableCellProperties?.borders) {
    delete tableCellProperties.borders;
  }
  const result = translator$J.decode({ node: { ...node, attrs: { ...node.attrs, tableCellProperties } } });
  return result;
}
const XML_NODE_NAME$h = 'w:tc';
const SD_NODE_NAME$e = 'tableCell';
const validXmlAttributes$c = [];
function encode$n(params, encodedAttrs) {
  const {
    node,
    table,
    row,
    rowBorders,
    columnIndex,
    columnWidth,
    columnWidths: allColumnWidths,
    _referencedStyles,
  } = params.extraParams;
  const schemaNode = handleTableCellNode({
    params,
    node,
    table,
    row,
    rowBorders,
    columnIndex,
    columnWidth,
    allColumnWidths,
    _referencedStyles,
  });
  if (encodedAttrs && Object.keys(encodedAttrs).length) {
    schemaNode.attrs = { ...schemaNode.attrs, ...encodedAttrs };
  }
  return schemaNode;
}
function decode$p(params, decodedAttrs) {
  const translated = translateTableCell(params);
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    translated.attributes = { ...(translated.attributes || {}), ...decodedAttrs };
  }
  return translated;
}
const config$g = {
  xmlName: XML_NODE_NAME$h,
  sdNodeOrKeyName: SD_NODE_NAME$e,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$n,
  decode: decode$p,
  attributes: validXmlAttributes$c,
};
const translator$I = NodeTranslator.from(config$g);
const translator$H = NodeTranslator.from({
  xmlName: 'w:cantSplit',
  sdNodeOrKeyName: 'cantSplit',
  encode: ({ nodes }) => ['1', 'true'].includes(nodes[0].attributes?.['w:val'] ?? '1'),
  decode: ({ node }) => (node.attrs?.cantSplit ? { attributes: {} } : void 0),
});
const translator$G = NodeTranslator.from(createSingleAttrPropertyHandler('w:divId'));
const translator$F = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    'w:gridAfter',
    null,
    'w:val',
    (v) => parseInteger(v) ?? void 0,
    (v) => integerToString(v),
  ),
);
const translator$E = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    'w:gridBefore',
    null,
    'w:val',
    (v) => parseInteger(v) ?? void 0,
    (v) => integerToString(v),
  ),
);
const translator$D = NodeTranslator.from({
  xmlName: 'w:hidden',
  sdNodeOrKeyName: 'hidden',
  encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.['w:val'] ?? '1'),
  decode: ({ node }) => (node.attrs.hidden ? { attributes: {} } : void 0),
});
const translator$C = NodeTranslator.from(createSingleAttrPropertyHandler('w:jc', 'justification'));
const translator$B = NodeTranslator.from(createMeasurementPropertyHandler('w:tblCellSpacing', 'tableCellSpacing'));
const translator$A = NodeTranslator.from({
  xmlName: 'w:tblHeader',
  sdNodeOrKeyName: 'repeatHeader',
  encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.['w:val'] ?? '1'),
  decode: ({ node }) => (node.attrs.repeatHeader ? { attributes: {} } : void 0),
});
const translator$z = NodeTranslator.from({
  xmlName: 'w:trHeight',
  sdNodeOrKeyName: 'rowHeight',
  encode: ({ nodes }) => {
    const heightAttrs = {};
    const val = nodes[0].attributes['w:val'];
    if (val) {
      heightAttrs['value'] = parseInt(val, 10);
    }
    const rule = nodes[0].attributes['w:hRule'];
    if (rule) {
      heightAttrs['rule'] = rule;
    }
    return Object.keys(heightAttrs).length > 0 ? heightAttrs : void 0;
  },
  decode: ({ node }) => {
    if (!node.attrs?.rowHeight) return;
    const heightAttrs = {};
    if (typeof node.attrs.rowHeight.value === 'number' && !isNaN(node.attrs.rowHeight.value)) {
      heightAttrs['w:val'] = String(node.attrs.rowHeight.value);
    }
    if (node.attrs.rowHeight.rule) {
      heightAttrs['w:hRule'] = node.attrs.rowHeight.rule;
    }
    return Object.keys(heightAttrs).length > 0 ? { attributes: heightAttrs } : void 0;
  },
});
const translator$y = NodeTranslator.from(createMeasurementPropertyHandler('w:wAfter'));
const translator$x = NodeTranslator.from(createMeasurementPropertyHandler('w:wBefore'));
const propertyTranslators$3 = [
  translator$H,
  translator$1b,
  translator$G,
  translator$F,
  translator$E,
  translator$D,
  translator$C,
  translator$B,
  translator$A,
  translator$z,
  translator$y,
  translator$x,
];
const translator$w = NodeTranslator.from(
  createNestedPropertiesTranslator('w:trPr', 'tableRowProperties', propertyTranslators$3, {
    cantSplit: false,
    hidden: false,
    repeatHeader: false,
  }),
);
const createPlaceholderCell = (gridWidth, reason) => {
  const safeWidth = Number.isFinite(gridWidth) ? gridWidth : 0;
  const noBorder = { val: 'none', size: 0 };
  return {
    type: 'tableCell',
    attrs: {
      colspan: 1,
      rowspan: 1,
      colwidth: [safeWidth],
      __placeholder: reason,
      borders: {
        top: { ...noBorder },
        right: { ...noBorder },
        bottom: { ...noBorder },
        left: { ...noBorder },
      },
    },
    content: [{ type: 'paragraph', content: [] }],
  };
};
const advancePastRowSpans = (pendingRowSpans, startIndex, totalColumns) => {
  let index = startIndex;
  while (index < totalColumns && pendingRowSpans[index] > 0) {
    pendingRowSpans[index] -= 1;
    index += 1;
  }
  return index;
};
const fillPlaceholderColumns = ({
  content,
  pendingRowSpans,
  currentIndex,
  targetIndex,
  totalColumns,
  gridColumnWidths,
  reason,
}) => {
  let index = currentIndex;
  while (index < targetIndex && index < totalColumns) {
    if (pendingRowSpans[index] > 0) {
      pendingRowSpans[index] -= 1;
      index += 1;
      continue;
    }
    const width = Array.isArray(gridColumnWidths) ? (gridColumnWidths[index] ?? 0) : 0;
    content.push(createPlaceholderCell(width, reason));
    index += 1;
  }
  return index;
};
const isPlaceholderCell = (cell) => {
  if (!cell) return false;
  if (cell.attrs?.__placeholder) return true;
  const widths = cell.attrs?.colwidth;
  if (Array.isArray(widths) && widths.length > 0) {
    const hasMeaningfulWidth = widths.some(
      (value) => typeof value === 'number' && Number.isFinite(value) && Math.abs(value) > 1,
    );
    if (!hasMeaningfulWidth) return true;
  }
  return false;
};
const XML_NODE_NAME$g = 'w:tr';
const SD_NODE_NAME$d = 'tableRow';
const validXmlAttributes$b = ['w:rsidDel', 'w:rsidR', 'w:rsidRPr', 'w:rsidTr', 'w14:paraId', 'w14:textId'].map(
  (xmlName) => createAttributeHandler(xmlName),
);
const encode$m = (params, encodedAttrs) => {
  const { row } = params.extraParams;
  let tableRowProperties = {};
  const tPr = row.elements.find((el) => el.name === 'w:trPr');
  if (tPr) {
    tableRowProperties = translator$w.encode({
      ...params,
      nodes: [tPr],
    });
  }
  const gridBeforeRaw = tableRowProperties?.['gridBefore'];
  const safeGridBefore =
    typeof gridBeforeRaw === 'number' && Number.isFinite(gridBeforeRaw) && gridBeforeRaw > 0 ? gridBeforeRaw : 0;
  encodedAttrs['tableRowProperties'] = Object.freeze(tableRowProperties);
  encodedAttrs['rowHeight'] = twipsToPixels(tableRowProperties['rowHeight']?.value);
  encodedAttrs['cantSplit'] = tableRowProperties['cantSplit'];
  const { columnWidths: gridColumnWidths, activeRowSpans = [] } = params.extraParams;
  const totalColumns = Array.isArray(gridColumnWidths) ? gridColumnWidths.length : 0;
  const pendingRowSpans = Array.isArray(activeRowSpans) ? activeRowSpans.slice() : [];
  while (pendingRowSpans.length < totalColumns) pendingRowSpans.push(0);
  const cellNodes = row.elements.filter((el) => el.name === 'w:tc');
  const content = [];
  let currentColumnIndex = 0;
  const fillUntil = (target, reason) => {
    currentColumnIndex = fillPlaceholderColumns({
      content,
      pendingRowSpans,
      currentIndex: currentColumnIndex,
      targetIndex: target,
      totalColumns,
      gridColumnWidths,
      reason,
    });
  };
  const skipOccupiedColumns = () => {
    currentColumnIndex = advancePastRowSpans(pendingRowSpans, currentColumnIndex, totalColumns);
  };
  fillUntil(safeGridBefore, 'gridBefore');
  skipOccupiedColumns();
  cellNodes?.forEach((node) => {
    skipOccupiedColumns();
    const startColumn = currentColumnIndex;
    const columnWidth = gridColumnWidths?.[startColumn] || null;
    const result = translator$I.encode({
      ...params,
      extraParams: {
        ...params.extraParams,
        node,
        columnIndex: startColumn,
        columnWidth,
      },
    });
    if (result) {
      content.push(result);
      const colspan = Math.max(1, result.attrs?.colspan || 1);
      const rowspan = Math.max(1, result.attrs?.rowspan || 1);
      if (rowspan > 1) {
        for (let offset = 0; offset < colspan; offset += 1) {
          const target = startColumn + offset;
          if (target < pendingRowSpans.length) {
            pendingRowSpans[target] = Math.max(pendingRowSpans[target], rowspan - 1);
          }
        }
      }
      currentColumnIndex = startColumn + colspan;
    }
  });
  skipOccupiedColumns();
  fillUntil(totalColumns, 'gridAfter');
  const newNode = {
    type: 'tableRow',
    content,
    attrs: encodedAttrs,
  };
  return newNode;
};
const decode$o = (params, decodedAttrs) => {
  const { node } = params;
  const cells = node.content || [];
  let leadingPlaceholders = 0;
  while (leadingPlaceholders < cells.length && isPlaceholderCell(cells[leadingPlaceholders])) {
    leadingPlaceholders += 1;
  }
  let trailingPlaceholders = 0;
  while (
    trailingPlaceholders < cells.length - leadingPlaceholders &&
    isPlaceholderCell(cells[cells.length - 1 - trailingPlaceholders])
  ) {
    trailingPlaceholders += 1;
  }
  const trimmedSlice = cells.slice(leadingPlaceholders, cells.length - trailingPlaceholders);
  const sanitizedCells = trimmedSlice.map((cell) => {
    if (cell?.attrs && '__placeholder' in cell.attrs) {
      const { __placeholder, ...rest } = cell.attrs;
      return { ...cell, attrs: rest };
    }
    return cell;
  });
  const trimmedContent = sanitizedCells.filter((_, index) => !isPlaceholderCell(trimmedSlice[index]));
  const translateParams = {
    ...params,
    node: { ...node, content: trimmedContent },
  };
  const elements = translateChildNodes(translateParams);
  if (node.attrs?.tableRowProperties) {
    const tableRowProperties = { ...node.attrs.tableRowProperties };
    if (leadingPlaceholders > 0) {
      tableRowProperties.gridBefore = leadingPlaceholders;
    }
    if (trailingPlaceholders > 0) {
      tableRowProperties.gridAfter = trailingPlaceholders;
    }
    if (node.attrs.rowHeight != null) {
      const rowHeightPixels = twipsToPixels(node.attrs.tableRowProperties['rowHeight']?.value);
      if (rowHeightPixels !== node.attrs.rowHeight) {
        tableRowProperties['rowHeight'] = { value: String(pixelsToTwips(node.attrs['rowHeight'])) };
      }
    }
    tableRowProperties['cantSplit'] = node.attrs['cantSplit'];
    const trPr = translator$w.decode({
      ...params,
      node: { ...node, attrs: { ...node.attrs, tableRowProperties } },
    });
    if (trPr) elements.unshift(trPr);
  }
  return {
    name: 'w:tr',
    attributes: decodedAttrs || {},
    elements,
  };
};
const config$f = {
  xmlName: XML_NODE_NAME$g,
  sdNodeOrKeyName: SD_NODE_NAME$d,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$m,
  decode: decode$o,
  attributes: validXmlAttributes$b,
};
const translator$v = NodeTranslator.from(config$f);
function parseTagValueJSON(json) {
  if (typeof json !== 'string') {
    return {};
  }
  const trimmed = json.trim();
  if (!trimmed) {
    return {};
  }
  try {
    return JSON.parse(trimmed);
  } catch {
    return {};
  }
}
function handleAnnotationNode(params) {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:sdt') {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === 'w:sdtPr');
  const sdtContent = node.elements.find((el) => el.name === 'w:sdtContent');
  const sdtId = sdtPr?.elements?.find((el) => el.name === 'w:id');
  const alias = sdtPr?.elements.find((el) => el.name === 'w:alias');
  const tag = sdtPr?.elements.find((el) => el.name === 'w:tag');
  const tagValue = tag?.attributes['w:val'];
  const shouldProcessAsJson = tagValue?.startsWith('{') && tagValue?.endsWith('}');
  let attrs = {};
  const aliasLabel = getSafeString(alias?.attributes?.['w:val']);
  if (shouldProcessAsJson) {
    const parsedAttrs = parseTagValueJSON(tagValue);
    attrs = {
      type: parsedAttrs.fieldTypeShort,
      fieldId: parsedAttrs.fieldId,
      displayLabel: parsedAttrs.displayLabel,
      defaultDisplayLabel: parsedAttrs.defaultDisplayLabel,
      fieldType: parsedAttrs.fieldType,
      fieldColor: parsedAttrs.fieldColor,
      multipleImage: parsedAttrs.fieldMultipleImage,
      fontFamily: parsedAttrs.fieldFontFamily,
      fontSize: parsedAttrs.fieldFontSize,
      textColor: parsedAttrs.fieldTextColor,
      textHighlight: parsedAttrs.fieldTextHighlight,
      hash: parsedAttrs.hash,
    };
  } else {
    attrs = getAttrsFromElements({ sdtPr, tag, alias, sdtId });
  }
  const initialDisplayLabel = getSafeString(attrs.displayLabel);
  const extractedContent = getTextFromSdtContent(sdtContent);
  if (!attrs.defaultDisplayLabel) {
    if (initialDisplayLabel) {
      attrs.defaultDisplayLabel = initialDisplayLabel;
    } else if (aliasLabel) {
      attrs.defaultDisplayLabel = aliasLabel;
    }
  }
  const placeholderLabel = getPlaceholderLabel(attrs, aliasLabel);
  const placeholderText = ensurePlaceholderFormat(placeholderLabel);
  const isAnnotationsEnabled = Boolean(params.editor?.options?.annotations);
  const contentIsDistinct = shouldUseSdtContent(extractedContent, placeholderText);
  const shouldUseContent =
    !isAnnotationsEnabled && contentIsDistinct && (hasMoustache(extractedContent) || !placeholderText);
  if (contentIsDistinct) {
    attrs.displayLabel = extractedContent;
  } else if (!attrs.displayLabel && placeholderLabel) {
    attrs.displayLabel = placeholderLabel;
  }
  const { attrs: marksAsAttrs, marks } = parseAnnotationMarks(sdtContent);
  const allAttrs = { ...attrs, ...marksAsAttrs };
  if (!allAttrs.hash) allAttrs.hash = generateDocxRandomId(4);
  if (!attrs.fieldId || !attrs.type) {
    return null;
  }
  const textContent2 = shouldUseContent ? extractedContent : placeholderText;
  let result = {
    type: 'text',
    text: textContent2,
    attrs: allAttrs,
    marks,
  };
  if (isAnnotationsEnabled) {
    result = {
      type: 'fieldAnnotation',
      attrs: allAttrs,
    };
  }
  return result;
}
const parseAnnotationMarks = (content = {}) => {
  let mainContent = content;
  const run2 = mainContent.elements?.find((el) => el.name === 'w:r');
  const rPr = run2?.elements?.find((el) => el.name === 'w:rPr');
  if (!rPr) return {};
  const unknownMarks = [];
  const marks = parseMarks(rPr, unknownMarks) || [];
  const marksWithFlatFontStyles = [];
  marks.forEach((mark) => {
    const { type } = mark;
    if (type === 'textStyle') {
      const { attrs: attrs2 } = mark;
      Object.keys(attrs2).forEach((key2) => {
        marksWithFlatFontStyles.push({ type: key2, attrs: attrs2[key2] });
      });
    } else {
      marksWithFlatFontStyles.push(mark);
    }
  });
  const attrs = {};
  marksWithFlatFontStyles?.forEach((mark) => {
    const { type } = mark;
    attrs[type] = mark.attrs || true;
  });
  return {
    attrs,
    marks,
  };
};
function getAttrsFromElements({ sdtPr, tag, alias, sdtId }) {
  const type = sdtPr?.elements.find((el) => el.name === 'w:fieldTypeShort')?.attributes['w:val'];
  const fieldType = sdtPr?.elements.find((el) => el.name === 'w:fieldType')?.attributes['w:val'];
  const fieldColor = sdtPr?.elements.find((el) => el.name === 'w:fieldColor')?.attributes['w:val'];
  const isMultipleImage = sdtPr?.elements.find((el) => el.name === 'w:fieldMultipleImage')?.attributes['w:val'];
  const fontFamily = sdtPr?.elements.find((el) => el.name === 'w:fieldFontFamily')?.attributes['w:val'];
  const fontSize = sdtPr?.elements.find((el) => el.name === 'w:fieldFontSize')?.attributes['w:val'];
  const textColor = sdtPr?.elements.find((el) => el.name === 'w:fieldTextColor')?.attributes['w:val'];
  const textHighlight = sdtPr?.elements.find((el) => el.name === 'w:fieldTextHighlight')?.attributes['w:val'];
  const attrs = {
    type,
    fieldId: tag?.attributes['w:val'],
    displayLabel: alias?.attributes['w:val'],
    fieldType,
    fieldColor,
    multipleImage: isMultipleImage === 'true',
    fontFamily: fontFamily !== 'null' ? fontFamily : null,
    fontSize: fontSize !== 'null' ? fontSize : null,
    textColor: textColor !== 'null' ? textColor : null,
    textHighlight: textHighlight !== 'null' ? textHighlight : null,
    sdtId: sdtId?.attributes['w:val'],
  };
  return attrs;
}
function getTextFromSdtContent(sdtContent) {
  if (!sdtContent?.elements?.length) return '';
  const chunks = [];
  collectTextChunks(sdtContent.elements, chunks);
  if (chunks.length && chunks[chunks.length - 1] === '\n') {
    chunks.pop();
  }
  const text = chunks.join('');
  return text.replace(/\u00a0/g, ' ');
}
function getPlaceholderLabel(attrs, aliasValue) {
  const displayLabel = trimSafeString(attrs.displayLabel);
  if (displayLabel) return displayLabel;
  const defaultLabel = trimSafeString(attrs.defaultDisplayLabel);
  if (defaultLabel) return defaultLabel;
  return trimSafeString(aliasValue);
}
function shouldUseSdtContent(extractedContent, placeholderText) {
  const normalizedContent = normalizePlaceholderText(extractedContent);
  if (!normalizedContent) return false;
  const normalizedPlaceholder = normalizePlaceholderText(placeholderText);
  return normalizedContent !== normalizedPlaceholder;
}
function ensurePlaceholderFormat(label) {
  const trimmed = trimSafeString(label);
  if (!trimmed) return '';
  if (trimmed.startsWith('{{') && trimmed.endsWith('}}')) {
    return trimmed;
  }
  return `{{${trimmed}}}`;
}
function normalizePlaceholderText(value = '') {
  const trimmed = trimSafeString(value);
  if (!trimmed) return '';
  return stripPlaceholderBraces(trimmed).toLowerCase();
}
function stripPlaceholderBraces(value = '') {
  if (value.startsWith('{{') && value.endsWith('}}')) {
    return trimSafeString(value.slice(2, -2));
  }
  return value;
}
function hasMoustache(value = '') {
  return /\{\{\s*.+?\s*\}\}/.test(getSafeString(value));
}
function collectTextChunks(elements, chunks) {
  if (!elements) return;
  elements.forEach((element) => {
    if (!element) return;
    if (element.type === 'text') {
      chunks.push(element.text || '');
      return;
    }
    if (element.name === 'w:tab') {
      chunks.push('	');
      return;
    }
    if (element.name === 'w:br') {
      chunks.push('\n');
      return;
    }
    const isParagraph = element.name === 'w:p';
    const initialLength = chunks.length;
    if (element.elements?.length) {
      collectTextChunks(element.elements, chunks);
    }
    if (isParagraph && chunks.length > initialLength) {
      chunks.push('\n');
    }
  });
}
function getSafeString(value) {
  if (typeof value !== 'string') return '';
  return value;
}
function trimSafeString(value) {
  return getSafeString(value)
    .replace(/\u00a0/g, ' ')
    .trim();
}
function handleDocPartObj(params) {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:sdt') {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === 'w:sdtPr');
  const docPartObj = sdtPr?.elements.find((el) => el.name === 'w:docPartObj');
  const docPartGallery = docPartObj?.elements.find((el) => el.name === 'w:docPartGallery');
  const docPartGalleryType = docPartGallery?.attributes['w:val'];
  if (!docPartGalleryType || !validGalleryTypeMap[docPartGalleryType]) {
    return null;
  }
  const content = node?.elements.find((el) => el.name === 'w:sdtContent');
  const handler2 = validGalleryTypeMap[docPartGalleryType];
  const result = handler2({
    ...params,
    nodes: [content],
    extraParams: { ...(params.extraParams || {}), sdtPr },
  });
  return result;
}
const tableOfContentsHandler = (params) => {
  const node = params.nodes[0];
  const translatedContent = params.nodeListHandler.handler({
    ...params,
    nodes: node.elements,
    path: [...(params.path || []), node],
  });
  const sdtPr = params.extraParams.sdtPr;
  const id = sdtPr.elements?.find((el) => el.name === 'w:id')?.attributes['w:val'] || '';
  const result = {
    type: 'documentPartObject',
    content: translatedContent,
    attrs: {
      id,
      docPartGallery: 'Table of Contents',
      docPartUnique: true,
    },
  };
  return result;
};
const validGalleryTypeMap = {
  'Table of Contents': tableOfContentsHandler,
};
function handleDocumentSectionNode(params) {
  const { nodes, nodeListHandler } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:sdt') {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === 'w:sdtPr');
  const tag = sdtPr?.elements.find((el) => el.name === 'w:tag');
  const tagValue = parseTagValueJSON(tag?.attributes?.['w:val']);
  const idTag = sdtPr?.elements.find((el) => el.name === 'w:id');
  const id = idTag?.attributes?.['w:val'] || tagValue.id || null;
  const titleTag = sdtPr?.elements.find((el) => el.name === 'w:alias');
  const title = titleTag?.attributes?.['w:val'] || tagValue.title || null;
  const { description } = tagValue;
  const sdtContent = node.elements.find((el) => el.name === 'w:sdtContent');
  const translatedContent = nodeListHandler.handler({
    ...params,
    nodes: sdtContent?.elements,
    path: [...(params.path || []), node],
  });
  const result = {
    type: 'documentSection',
    content: translatedContent,
    attrs: {
      id,
      title,
      description,
    },
  };
  return result;
}
function handleStructuredContentNode(params) {
  const { nodes, nodeListHandler } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:sdt') {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === 'w:sdtPr');
  const sdtContent = node.elements.find((el) => el.name === 'w:sdtContent');
  const id = sdtPr?.elements?.find((el) => el.name === 'w:id');
  const tag = sdtPr?.elements?.find((el) => el.name === 'w:tag');
  const alias = sdtPr?.elements?.find((el) => el.name === 'w:alias');
  if (!sdtContent) {
    return null;
  }
  const paragraph = sdtContent.elements?.find((el) => el.name === 'w:p');
  const table = sdtContent.elements?.find((el) => el.name === 'w:tbl');
  const { marks } = parseAnnotationMarks(sdtContent);
  const translatedContent = nodeListHandler.handler({
    ...params,
    nodes: sdtContent.elements,
    path: [...(params.path || []), sdtContent],
  });
  const isBlockNode = paragraph || table;
  const sdtContentType = isBlockNode ? 'structuredContentBlock' : 'structuredContent';
  let result = {
    type: sdtContentType,
    content: translatedContent,
    marks,
    attrs: {
      id: id?.attributes?.['w:val'] || null,
      tag: tag?.attributes?.['w:val'] || null,
      alias: alias?.attributes?.['w:val'] || null,
      sdtPr,
    },
  };
  return result;
}
function sdtNodeTypeStrategy(node) {
  const sdtContent = node.elements.find((el) => el.name === 'w:sdtContent');
  const sdtPr = node.elements.find((el) => el.name === 'w:sdtPr');
  const tag = sdtPr?.elements.find((el) => el.name === 'w:tag');
  const tagValue = tag?.attributes?.['w:val'];
  const docPartObj = sdtPr?.elements.find((el) => el.name === 'w:docPartObj');
  if (docPartObj) {
    return { type: 'docPartObj', handler: handleDocPartObj };
  }
  if (tagValue) {
    const shouldProcessAsJson = tagValue.startsWith('{') && tagValue.endsWith('}');
    if (shouldProcessAsJson) {
      const parsedTag = parseTagValueJSON(tagValue);
      if (parsedTag.type === 'documentSection') {
        return { type: 'documentSection', handler: handleDocumentSectionNode };
      }
      if (parsedTag.fieldId && parsedTag.fieldTypeShort) {
        return { type: 'fieldAnnotation', handler: handleAnnotationNode };
      }
    } else {
      const fieldTypeShort = sdtPr.elements.find((el) => el.name === 'w:fieldTypeShort');
      const fieldTypeShortValue = fieldTypeShort?.attributes['w:val'];
      if (tagValue && fieldTypeShortValue) {
        return { type: 'fieldAnnotation', handler: handleAnnotationNode };
      }
    }
  }
  if (sdtContent) {
    return { type: 'structuredContent', handler: handleStructuredContentNode };
  }
  return { type: 'unknown', handler: null };
}
function getThemeColor(name) {
  const colors = {
    accent1: '#5b9bd5',
    accent2: '#ed7d31',
    accent3: '#a5a5a5',
    accent4: '#ffc000',
    accent5: '#4472c4',
    accent6: '#70ad47',
    dk1: '#000000',
    lt1: '#ffffff',
    dk2: '#1f497d',
    lt2: '#eeece1',
    text1: '#000000',
    text2: '#1f497d',
    background1: '#ffffff',
    background2: '#eeece1',
  };
  return colors[name] ?? '#000000';
}
function applyColorModifier(hexColor, modifier, value) {
  const r2 = parseInt(hexColor.slice(1, 3), 16);
  const g = parseInt(hexColor.slice(3, 5), 16);
  const b = parseInt(hexColor.slice(5, 7), 16);
  const percent = parseInt(value) / 1e5;
  let newR, newG, newB;
  if (modifier === 'shade' || modifier === 'lumMod') {
    newR = r2 * percent;
    newG = g * percent;
    newB = b * percent;
  } else if (modifier === 'tint') {
    newR = r2 + (255 - r2) * percent;
    newG = g + (255 - g) * percent;
    newB = b + (255 - b) * percent;
  } else if (modifier === 'lumOff') {
    const offset = 255 * percent;
    newR = r2 + offset;
    newG = g + offset;
    newB = b + offset;
  } else {
    return hexColor;
  }
  const clamp2 = (n) => Math.max(0, Math.min(255, Math.round(n)));
  const toHex2 = (n) => n.toString(16).padStart(2, '0');
  newR = clamp2(newR);
  newG = clamp2(newG);
  newB = clamp2(newB);
  const result = `#${toHex2(newR)}${toHex2(newG)}${toHex2(newB)}`;
  return result;
}
function extractStrokeWidth(spPr) {
  const ln = spPr?.elements?.find((el) => el.name === 'a:ln');
  const w = ln?.attributes?.['w'];
  return w ? emuToPixels(w) : 1;
}
function extractStrokeColor(spPr, style) {
  const ln = spPr?.elements?.find((el) => el.name === 'a:ln');
  if (ln) {
    const noFill = ln.elements?.find((el) => el.name === 'a:noFill');
    if (noFill) return null;
    const solidFill = ln.elements?.find((el) => el.name === 'a:solidFill');
    if (solidFill) {
      const schemeClr2 = solidFill.elements?.find((el) => el.name === 'a:schemeClr');
      if (schemeClr2) {
        const themeName2 = schemeClr2.attributes?.['val'];
        let color2 = getThemeColor(themeName2);
        const modifiers2 = schemeClr2.elements || [];
        modifiers2.forEach((mod) => {
          if (mod.name === 'a:shade') {
            color2 = applyColorModifier(color2, 'shade', mod.attributes['val']);
          } else if (mod.name === 'a:tint') {
            color2 = applyColorModifier(color2, 'tint', mod.attributes['val']);
          } else if (mod.name === 'a:lumMod') {
            color2 = applyColorModifier(color2, 'lumMod', mod.attributes['val']);
          }
        });
        return color2;
      }
      const srgbClr = solidFill.elements?.find((el) => el.name === 'a:srgbClr');
      if (srgbClr) {
        return '#' + srgbClr.attributes?.['val'];
      }
    }
  }
  if (!style) return '#000000';
  const lnRef = style.elements?.find((el) => el.name === 'a:lnRef');
  if (!lnRef) return '#000000';
  const schemeClr = lnRef.elements?.find((el) => el.name === 'a:schemeClr');
  if (!schemeClr) return '#000000';
  const themeName = schemeClr.attributes?.['val'];
  let color = getThemeColor(themeName);
  const modifiers = schemeClr.elements || [];
  modifiers.forEach((mod) => {
    if (mod.name === 'a:shade') {
      color = applyColorModifier(color, 'shade', mod.attributes['val']);
    } else if (mod.name === 'a:tint') {
      color = applyColorModifier(color, 'tint', mod.attributes['val']);
    } else if (mod.name === 'a:lumMod') {
      color = applyColorModifier(color, 'lumMod', mod.attributes['val']);
    } else if (mod.name === 'a:lumOff') {
      color = applyColorModifier(color, 'lumOff', mod.attributes['val']);
    }
  });
  return color;
}
function extractFillColor(spPr, style) {
  const noFill = spPr?.elements?.find((el) => el.name === 'a:noFill');
  if (noFill) return null;
  const solidFill = spPr?.elements?.find((el) => el.name === 'a:solidFill');
  if (solidFill) {
    const schemeClr2 = solidFill.elements?.find((el) => el.name === 'a:schemeClr');
    if (schemeClr2) {
      const themeName2 = schemeClr2.attributes?.['val'];
      let color2 = getThemeColor(themeName2);
      const modifiers2 = schemeClr2.elements || [];
      modifiers2.forEach((mod) => {
        if (mod.name === 'a:shade') {
          color2 = applyColorModifier(color2, 'shade', mod.attributes['val']);
        } else if (mod.name === 'a:tint') {
          color2 = applyColorModifier(color2, 'tint', mod.attributes['val']);
        } else if (mod.name === 'a:lumMod') {
          color2 = applyColorModifier(color2, 'lumMod', mod.attributes['val']);
        } else if (mod.name === 'a:lumOff') {
          color2 = applyColorModifier(color2, 'lumOff', mod.attributes['val']);
        }
      });
      return color2;
    }
    const srgbClr = solidFill.elements?.find((el) => el.name === 'a:srgbClr');
    if (srgbClr) {
      return '#' + srgbClr.attributes?.['val'];
    }
  }
  const gradFill = spPr?.elements?.find((el) => el.name === 'a:gradFill');
  if (gradFill) {
    return '#cccccc';
  }
  const blipFill = spPr?.elements?.find((el) => el.name === 'a:blipFill');
  if (blipFill) {
    return '#cccccc';
  }
  if (!style) return '#5b9bd5';
  const fillRef = style.elements?.find((el) => el.name === 'a:fillRef');
  if (!fillRef) return '#5b9bd5';
  const schemeClr = fillRef.elements?.find((el) => el.name === 'a:schemeClr');
  if (!schemeClr) return '#5b9bd5';
  const themeName = schemeClr.attributes?.['val'];
  let color = getThemeColor(themeName);
  const modifiers = schemeClr.elements || [];
  modifiers.forEach((mod) => {
    if (mod.name === 'a:shade') {
      color = applyColorModifier(color, 'shade', mod.attributes['val']);
    } else if (mod.name === 'a:tint') {
      color = applyColorModifier(color, 'tint', mod.attributes['val']);
    } else if (mod.name === 'a:lumMod') {
      color = applyColorModifier(color, 'lumMod', mod.attributes['val']);
    }
  });
  return color;
}
const DRAWING_XML_TAG = 'w:drawing';
const SHAPE_URI = 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape';
const GROUP_URI = 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup';
function handleImageNode(node, params, isAnchor) {
  const { docx, filename } = params;
  const { attributes } = node;
  const padding = {
    top: emuToPixels(attributes['distT']),
    bottom: emuToPixels(attributes['distB']),
    left: emuToPixels(attributes['distL']),
    right: emuToPixels(attributes['distR']),
  };
  const extent = node.elements.find((el) => el.name === 'wp:extent');
  const size = {
    width: emuToPixels(extent?.attributes?.cx),
    height: emuToPixels(extent?.attributes?.cy),
  };
  let transformData = {};
  const effectExtent = node.elements.find((el) => el.name === 'wp:effectExtent');
  if (effectExtent) {
    const sanitizeEmuValue = (value) => {
      if (value === null || value === void 0) return 0;
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : 0;
    };
    transformData.sizeExtension = {
      left: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.['l'])),
      top: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.['t'])),
      right: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.['r'])),
      bottom: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.['b'])),
    };
  }
  const positionHTag = node.elements.find((el) => el.name === 'wp:positionH');
  const positionH = positionHTag?.elements.find((el) => el.name === 'wp:posOffset');
  const positionHValue = emuToPixels(positionH?.elements[0]?.text);
  const hRelativeFrom = positionHTag?.attributes?.relativeFrom;
  const alignH = positionHTag?.elements.find((el) => el.name === 'wp:align')?.elements?.[0]?.text;
  const positionVTag = node.elements.find((el) => el.name === 'wp:positionV');
  const positionV = positionVTag?.elements?.find((el) => el.name === 'wp:posOffset');
  const positionVValue = emuToPixels(positionV?.elements[0]?.text);
  const vRelativeFrom = positionVTag?.attributes?.relativeFrom;
  const alignV = positionVTag?.elements?.find((el) => el.name === 'wp:align')?.elements?.[0]?.text;
  const marginOffset = {
    horizontal: positionHValue,
    top: positionVValue,
  };
  const simplePos = node.elements.find((el) => el.name === 'wp:simplePos');
  const wrapNode = isAnchor
    ? node.elements.find((el) =>
        ['wp:wrapNone', 'wp:wrapSquare', 'wp:wrapThrough', 'wp:wrapTight', 'wp:wrapTopAndBottom'].includes(el.name),
      )
    : null;
  const wrap = isAnchor ? { type: wrapNode?.name.slice(7) || 'None', attrs: {} } : { type: 'Inline' };
  switch (wrap.type) {
    case 'Square':
      if (wrapNode?.attributes?.wrapText) {
        wrap.attrs.wrapText = wrapNode.attributes.wrapText;
      }
      if ('distB' in (wrapNode?.attributes || {})) {
        wrap.attrs.distBottom = emuToPixels(wrapNode.attributes.distB);
      }
      if ('distL' in (wrapNode?.attributes || {})) {
        wrap.attrs.distLeft = emuToPixels(wrapNode.attributes.distL);
      }
      if ('distR' in (wrapNode?.attributes || {})) {
        wrap.attrs.distRight = emuToPixels(wrapNode.attributes.distR);
      }
      if ('distT' in (wrapNode?.attributes || {})) {
        wrap.attrs.distTop = emuToPixels(wrapNode.attributes.distT);
      }
      break;
    case 'Tight':
    case 'Through': {
      if ('distL' in (wrapNode?.attributes || {})) {
        wrap.attrs.distLeft = emuToPixels(wrapNode.attributes.distL);
      }
      if ('distR' in (wrapNode?.attributes || {})) {
        wrap.attrs.distRight = emuToPixels(wrapNode.attributes.distR);
      }
      if ('distT' in (wrapNode?.attributes || {})) {
        wrap.attrs.distTop = emuToPixels(wrapNode.attributes.distT);
      }
      if ('distB' in (wrapNode?.attributes || {})) {
        wrap.attrs.distBottom = emuToPixels(wrapNode.attributes.distB);
      }
      if ('wrapText' in (wrapNode?.attributes || {})) {
        wrap.attrs.wrapText = wrapNode.attributes.wrapText;
      }
      const polygon = wrapNode?.elements?.find((el) => el.name === 'wp:wrapPolygon');
      if (polygon) {
        wrap.attrs.polygon = polygonToObj(polygon);
        if (polygon.attributes?.edited !== void 0) {
          wrap.attrs.polygonEdited = polygon.attributes.edited;
        }
      }
      break;
    }
    case 'TopAndBottom':
      if ('distB' in (wrapNode?.attributes || {})) {
        wrap.attrs.distBottom = emuToPixels(wrapNode.attributes.distB);
      }
      if ('distT' in (wrapNode?.attributes || {})) {
        wrap.attrs.distTop = emuToPixels(wrapNode.attributes.distT);
      }
      break;
    case 'None':
      wrap.attrs.behindDoc = node.attributes?.behindDoc === '1';
      break;
  }
  const docPr = node.elements.find((el) => el.name === 'wp:docPr');
  let anchorData = null;
  if (hRelativeFrom || alignH || vRelativeFrom || alignV) {
    anchorData = {
      hRelativeFrom,
      vRelativeFrom,
      alignH,
      alignV,
    };
  }
  const graphic = node.elements.find((el) => el.name === 'a:graphic');
  const graphicData = graphic?.elements.find((el) => el.name === 'a:graphicData');
  const { uri } = graphicData?.attributes || {};
  if (uri === SHAPE_URI) {
    const shapeMarginOffset = {
      left: positionHValue,
      horizontal: positionHValue,
      top: positionVValue,
    };
    return handleShapeDrawing(params, node, graphicData, size, padding, shapeMarginOffset);
  }
  if (uri === GROUP_URI) {
    const shapeMarginOffset = {
      left: positionHValue,
      horizontal: positionHValue,
      top: positionVValue,
    };
    return handleShapeGroup(params, node, graphicData, size, padding, shapeMarginOffset);
  }
  const picture = graphicData?.elements.find((el) => el.name === 'pic:pic');
  if (!picture || !picture.elements) return null;
  const blipFill = picture.elements.find((el) => el.name === 'pic:blipFill');
  const blip = blipFill?.elements.find((el) => el.name === 'a:blip');
  if (!blip) return null;
  const spPr = picture.elements.find((el) => el.name === 'pic:spPr');
  if (spPr) {
    const xfrm = spPr.elements.find((el) => el.name === 'a:xfrm');
    if (xfrm?.attributes) {
      transformData = {
        ...transformData,
        rotation: rotToDegrees(xfrm.attributes['rot']),
        verticalFlip: xfrm.attributes['flipV'] === '1',
        horizontalFlip: xfrm.attributes['flipH'] === '1',
      };
    }
  }
  const { attributes: blipAttributes = {} } = blip;
  const rEmbed = blipAttributes['r:embed'];
  if (!rEmbed) return null;
  const currentFile = filename || 'document.xml';
  let rels = docx[`word/_rels/${currentFile}.rels`];
  if (!rels) rels = docx[`word/_rels/document.xml.rels`];
  const relationships = rels?.elements.find((el) => el.name === 'Relationships');
  const { elements } = relationships || [];
  const rel = elements?.find((el) => el.attributes['Id'] === rEmbed);
  if (!rel) return null;
  const { attributes: relAttributes } = rel;
  const targetPath = relAttributes['Target'];
  let path = `word/${targetPath}`;
  if (targetPath.startsWith('/word') || targetPath.startsWith('/media')) path = targetPath.substring(1);
  const extension = targetPath.substring(targetPath.lastIndexOf('.') + 1);
  return {
    type: 'image',
    attrs: {
      src: path,
      alt: ['emf', 'wmf'].includes(extension) ? 'Unable to render EMF/WMF image' : docPr?.attributes?.name || 'Image',
      extension,
      id: docPr?.attributes?.id || '',
      title: docPr?.attributes?.descr || 'Image',
      inline: true,
      padding,
      marginOffset,
      size,
      anchorData,
      isAnchor,
      transformData,
      ...(simplePos && {
        simplePos: {
          x: simplePos.attributes.x,
          y: simplePos.attributes.y,
        },
      }),
      wrap,
      ...(wrap.type === 'Square' && wrap.attrs.wrapText
        ? {
            wrapText: wrap.attrs.wrapText,
          }
        : {}),
      wrapTopAndBottom: wrap.type === 'TopAndBottom',
      originalPadding: {
        distT: attributes['distT'],
        distB: attributes['distB'],
        distL: attributes['distL'],
        distR: attributes['distR'],
      },
      originalAttributes: node.attributes,
      rId: relAttributes['Id'],
    },
  };
}
const handleShapeDrawing = (params, node, graphicData, size, padding, marginOffset) => {
  const wsp = graphicData.elements.find((el) => el.name === 'wps:wsp');
  const textBox = wsp.elements.find((el) => el.name === 'wps:txbx');
  const textBoxContent = textBox?.elements?.find((el) => el.name === 'w:txbxContent');
  node.elements.find((el) => el.name === 'wp:docPr');
  const spPr = wsp.elements.find((el) => el.name === 'wps:spPr');
  const prstGeom = spPr?.elements.find((el) => el.name === 'a:prstGeom');
  const shapeType = prstGeom?.attributes['prst'];
  if (shapeType === 'rect' && !textBoxContent) {
    return getRectangleShape(params, spPr);
  }
  if (shapeType && !textBoxContent) {
    const result = getVectorShape({ params, graphicData });
    if (result) return result;
  }
  if (!textBoxContent) {
    return buildShapePlaceholder(node, size, padding, marginOffset, 'drawing');
  }
  return buildShapePlaceholder(node, size, padding, marginOffset, 'textbox');
};
const handleShapeGroup = (params, node, graphicData, size, padding, marginOffset) => {
  const wgp = graphicData.elements.find((el) => el.name === 'wpg:wgp');
  if (!wgp) {
    return buildShapePlaceholder(node, size, padding, marginOffset, 'group');
  }
  const grpSpPr = wgp.elements.find((el) => el.name === 'wpg:grpSpPr');
  const xfrm = grpSpPr?.elements?.find((el) => el.name === 'a:xfrm');
  const groupTransform = {};
  if (xfrm) {
    const off = xfrm.elements?.find((el) => el.name === 'a:off');
    const ext = xfrm.elements?.find((el) => el.name === 'a:ext');
    const chOff = xfrm.elements?.find((el) => el.name === 'a:chOff');
    const chExt = xfrm.elements?.find((el) => el.name === 'a:chExt');
    if (off) {
      groupTransform.x = emuToPixels(off.attributes?.['x'] || 0);
      groupTransform.y = emuToPixels(off.attributes?.['y'] || 0);
    }
    if (ext) {
      groupTransform.width = emuToPixels(ext.attributes?.['cx'] || 0);
      groupTransform.height = emuToPixels(ext.attributes?.['cy'] || 0);
    }
    if (chOff) {
      groupTransform.childX = emuToPixels(chOff.attributes?.['x'] || 0);
      groupTransform.childY = emuToPixels(chOff.attributes?.['y'] || 0);
      groupTransform.childOriginXEmu = parseFloat(chOff.attributes?.['x'] || 0);
      groupTransform.childOriginYEmu = parseFloat(chOff.attributes?.['y'] || 0);
    }
    if (chExt) {
      groupTransform.childWidth = emuToPixels(chExt.attributes?.['cx'] || 0);
      groupTransform.childHeight = emuToPixels(chExt.attributes?.['cy'] || 0);
    }
  }
  const childShapes = wgp.elements.filter((el) => el.name === 'wps:wsp');
  const shapes = childShapes
    .map((wsp) => {
      const spPr = wsp.elements?.find((el) => el.name === 'wps:spPr');
      if (!spPr) return null;
      const prstGeom = spPr.elements?.find((el) => el.name === 'a:prstGeom');
      const shapeKind = prstGeom?.attributes?.['prst'];
      const shapeXfrm = spPr.elements?.find((el) => el.name === 'a:xfrm');
      const shapeOff = shapeXfrm?.elements?.find((el) => el.name === 'a:off');
      const shapeExt = shapeXfrm?.elements?.find((el) => el.name === 'a:ext');
      const rawX = shapeOff?.attributes?.['x'] ? parseFloat(shapeOff.attributes['x']) : 0;
      const rawY = shapeOff?.attributes?.['y'] ? parseFloat(shapeOff.attributes['y']) : 0;
      const rawWidth = shapeExt?.attributes?.['cx'] ? parseFloat(shapeExt.attributes['cx']) : 914400;
      const rawHeight = shapeExt?.attributes?.['cy'] ? parseFloat(shapeExt.attributes['cy']) : 914400;
      let x, y, width, height;
      if (groupTransform.childWidth && groupTransform.childHeight) {
        const scaleX = groupTransform.width / groupTransform.childWidth;
        const scaleY = groupTransform.height / groupTransform.childHeight;
        const childOriginX = groupTransform.childOriginXEmu || 0;
        const childOriginY = groupTransform.childOriginYEmu || 0;
        x = groupTransform.x + emuToPixels((rawX - childOriginX) * scaleX);
        y = groupTransform.y + emuToPixels((rawY - childOriginY) * scaleY);
        width = emuToPixels(rawWidth * scaleX);
        height = emuToPixels(rawHeight * scaleY);
      } else {
        x = emuToPixels(rawX);
        y = emuToPixels(rawY);
        width = emuToPixels(rawWidth);
        height = emuToPixels(rawHeight);
      }
      const rotation = shapeXfrm?.attributes?.['rot'] ? rotToDegrees(shapeXfrm.attributes['rot']) : 0;
      const flipH = shapeXfrm?.attributes?.['flipH'] === '1';
      const flipV = shapeXfrm?.attributes?.['flipV'] === '1';
      const style = wsp.elements?.find((el) => el.name === 'wps:style');
      const fillColor = extractFillColor(spPr, style);
      const strokeColor = extractStrokeColor(spPr, style);
      const strokeWidth = extractStrokeWidth(spPr);
      const cNvPr = wsp.elements?.find((el) => el.name === 'wps:cNvPr');
      const shapeId = cNvPr?.attributes?.['id'];
      const shapeName = cNvPr?.attributes?.['name'];
      return {
        shapeType: 'vectorShape',
        attrs: {
          kind: shapeKind,
          x,
          y,
          width,
          height,
          rotation,
          flipH,
          flipV,
          fillColor,
          strokeColor,
          strokeWidth,
          shapeId,
          shapeName,
        },
      };
    })
    .filter(Boolean);
  const schemaAttrs = {};
  const drawingNode = params.nodes?.[0];
  if (drawingNode?.name === DRAWING_XML_TAG) {
    schemaAttrs.drawingContent = drawingNode;
  }
  const result = {
    type: 'shapeGroup',
    attrs: {
      ...schemaAttrs,
      groupTransform,
      shapes,
      size,
      padding,
      marginOffset,
    },
  };
  return result;
};
const getRectangleShape = (params, node) => {
  const schemaAttrs = {};
  const [drawingNode] = params.nodes;
  if (drawingNode?.name === DRAWING_XML_TAG) {
    schemaAttrs.drawingContent = drawingNode;
  }
  const xfrm = node.elements.find((el) => el.name === 'a:xfrm');
  const start = xfrm.elements.find((el) => el.name === 'a:off');
  const size = xfrm.elements.find((el) => el.name === 'a:ext');
  const solidFill = node.elements.find((el) => el.name === 'a:solidFill');
  node.elements.find((el) => el.name === 'a:ln');
  const rectangleSize = {
    top: emuToPixels(start.attributes['y']),
    left: emuToPixels(start.attributes['x']),
    width: emuToPixels(size.attributes['cx']),
    height: emuToPixels(size.attributes['cy']),
  };
  schemaAttrs.size = rectangleSize;
  const background = solidFill?.elements[0]?.attributes['val'];
  if (background) {
    schemaAttrs.background = '#' + background;
  }
  return {
    type: 'contentBlock',
    attrs: schemaAttrs,
  };
};
const buildShapePlaceholder = (node, size, padding, marginOffset, shapeType) => {
  const attrs = {
    drawingContent: {
      name: DRAWING_XML_TAG,
      elements: [carbonCopy(node)],
    },
    attributes: {
      'data-shape-type': shapeType,
    },
  };
  if (size && (Number.isFinite(size.width) || Number.isFinite(size.height))) {
    attrs.size = {
      ...(Number.isFinite(size.width) ? { width: size.width } : {}),
      ...(Number.isFinite(size.height) ? { height: size.height } : {}),
    };
  }
  if (padding) {
    const paddingData = {};
    if (Number.isFinite(padding.top)) paddingData['data-padding-top'] = padding.top;
    if (Number.isFinite(padding.right)) paddingData['data-padding-right'] = padding.right;
    if (Number.isFinite(padding.bottom)) paddingData['data-padding-bottom'] = padding.bottom;
    if (Number.isFinite(padding.left)) paddingData['data-padding-left'] = padding.left;
    if (Object.keys(paddingData).length) {
      attrs.attributes = {
        ...attrs.attributes,
        ...paddingData,
      };
    }
  }
  if (marginOffset) {
    const offsetData = {};
    const horizontal = Number.isFinite(marginOffset.horizontal)
      ? marginOffset.horizontal
      : Number.isFinite(marginOffset.left)
        ? marginOffset.left
        : void 0;
    if (Number.isFinite(horizontal)) offsetData['data-offset-x'] = horizontal;
    if (Number.isFinite(marginOffset.top)) offsetData['data-offset-y'] = marginOffset.top;
    if (Object.keys(offsetData).length) {
      attrs.attributes = {
        ...attrs.attributes,
        ...offsetData,
      };
    }
  }
  return {
    type: 'contentBlock',
    attrs,
  };
};
function getVectorShape({ params, graphicData }) {
  const schemaAttrs = {};
  const drawingNode = params.nodes?.[0];
  if (drawingNode?.name === 'w:drawing') {
    schemaAttrs.drawingContent = drawingNode;
  }
  const wsp = graphicData.elements?.find((el) => el.name === 'wps:wsp');
  if (!wsp) {
    return null;
  }
  const spPr = wsp.elements?.find((el) => el.name === 'wps:spPr');
  if (!spPr) {
    return null;
  }
  const prstGeom = spPr.elements?.find((el) => el.name === 'a:prstGeom');
  const shapeKind = prstGeom?.attributes?.['prst'];
  if (!shapeKind) {
    console.warn('Shape kind not found');
  }
  schemaAttrs.kind = shapeKind;
  const xfrm = spPr.elements?.find((el) => el.name === 'a:xfrm');
  const extent = xfrm?.elements?.find((el) => el.name === 'a:ext');
  const width = extent?.attributes?.['cx'] ? emuToPixels(extent.attributes['cx']) : 100;
  const height = extent?.attributes?.['cy'] ? emuToPixels(extent.attributes['cy']) : 100;
  const rotation = xfrm?.attributes?.['rot'] ? rotToDegrees(xfrm.attributes['rot']) : 0;
  const flipH = xfrm?.attributes?.['flipH'] === '1';
  const flipV = xfrm?.attributes?.['flipV'] === '1';
  const style = wsp.elements?.find((el) => el.name === 'wps:style');
  const fillColor = extractFillColor(spPr, style);
  const strokeColor = extractStrokeColor(spPr, style);
  const strokeWidth = extractStrokeWidth(spPr);
  return {
    type: 'vectorShape',
    attrs: {
      ...schemaAttrs,
      width,
      height,
      rotation,
      flipH,
      flipV,
      fillColor,
      strokeColor,
      strokeWidth,
    },
  };
}
function handleAnchorNode(params) {
  const { node } = params.extraParams;
  if (node.name !== 'wp:anchor') {
    return null;
  }
  return handleImageNode(node, params, true);
}
const sanitizeDocxMediaName = (value, fallback = 'image') => {
  if (!value) return fallback;
  const sanitized = value.replace(/[^a-zA-Z0-9_-]/g, '_');
  return sanitized || fallback;
};
const getFallbackImageNameFromDataUri = (src = '', fallback = 'image') => {
  if (!src || typeof src !== 'string') return fallback;
  const [prefix] = src.split(';');
  const [, maybeType] = prefix.split('/');
  const extension = maybeType?.toLowerCase();
  return extension ? `${fallback}.${extension}` : fallback;
};
const translateImageNode = (params) => {
  const {
    node: { attrs = {} },
    tableCell,
    imageSize,
  } = params;
  let imageId = attrs.rId;
  const src = attrs.src || attrs.imageSrc;
  const { originalWidth, originalHeight } = getPngDimensions(src);
  let imageName;
  if (params.node.type === 'image') {
    if (src?.startsWith('data:')) {
      imageName = getFallbackImageNameFromDataUri(src);
    } else {
      imageName = src?.split('/').pop();
    }
  } else {
    imageName = attrs.fieldId;
  }
  imageName = sanitizeDocxMediaName(imageName);
  let size = attrs.size
    ? {
        w: pixelsToEmu(attrs.size.width),
        h: pixelsToEmu(attrs.size.height),
      }
    : imageSize;
  if (originalWidth && originalHeight) {
    const boxWidthPx = emuToPixels(size.w);
    const boxHeightPx = emuToPixels(size.h);
    const { scaledWidth, scaledHeight } = getScaledSize(originalWidth, originalHeight, boxWidthPx, boxHeightPx);
    size = {
      w: pixelsToEmu(scaledWidth),
      h: pixelsToEmu(scaledHeight),
    };
  }
  if (tableCell) {
    const colwidthSum = tableCell.attrs.colwidth.reduce((acc, curr) => acc + curr, 0);
    const leftMargin = tableCell.attrs.cellMargins?.left || 8;
    const rightMargin = tableCell.attrs.cellMargins?.right || 8;
    const maxWidthEmu = pixelsToEmu(colwidthSum - (leftMargin + rightMargin));
    const { width: w, height: h } = resizeKeepAspectRatio(size.w, size.h, maxWidthEmu);
    if (w && h) size = { w, h };
  }
  if (imageId) {
    const docx = params.converter?.convertedXml || {};
    const rels = docx['word/_rels/document.xml.rels'];
    const relsTag = rels?.elements?.find((el) => el.name === 'Relationships');
    const hasRelation = relsTag?.elements.find((el) => el.attributes.Id === imageId);
    const path = src?.split('word/')[1];
    if (!hasRelation) {
      addImageRelationshipForId(params, imageId, path);
    }
  } else if (params.node.type === 'image' && !imageId) {
    const path = src?.split('word/')[1];
    imageId = addNewImageRelationship(params, path);
  } else if (params.node.type === 'fieldAnnotation' && !imageId) {
    const type = src?.split(';')[0].split('/')[1];
    if (!type) {
      return prepareTextAnnotation(params);
    }
    const sanitizedHash = sanitizeDocxMediaName(attrs.hash, generateDocxRandomId(4));
    const fileName = `${imageName}_${sanitizedHash}.${type}`;
    const relationshipTarget = `media/${fileName}`;
    const packagePath = `word/${relationshipTarget}`;
    imageId = addNewImageRelationship(params, relationshipTarget);
    params.media[packagePath] = src;
  }
  const inlineAttrs = attrs.originalPadding || {
    distT: 0,
    distB: 0,
    distL: 0,
    distR: 0,
  };
  const xfrmAttrs = {};
  const effectExtentAttrs = {
    l: 0,
    t: 0,
    r: 0,
    b: 0,
  };
  const transformData = attrs.transformData;
  if (transformData) {
    if (transformData.rotation) {
      xfrmAttrs.rot = degreesToRot(transformData.rotation);
    }
    if (transformData.verticalFlip) {
      xfrmAttrs.flipV = '1';
    }
    if (transformData.horizontalFlip) {
      xfrmAttrs.flipH = '1';
    }
    if (transformData.sizeExtension) {
      effectExtentAttrs.l = pixelsToEmu(transformData.sizeExtension.left);
      effectExtentAttrs.t = pixelsToEmu(transformData.sizeExtension.top);
      effectExtentAttrs.r = pixelsToEmu(transformData.sizeExtension.right);
      effectExtentAttrs.b = pixelsToEmu(transformData.sizeExtension.bottom);
    }
  }
  const drawingXmlns = 'http://schemas.openxmlformats.org/drawingml/2006/main';
  const pictureXmlns = 'http://schemas.openxmlformats.org/drawingml/2006/picture';
  return {
    attributes: inlineAttrs,
    elements: [
      {
        name: 'wp:extent',
        attributes: {
          cx: size.w,
          cy: size.h,
        },
      },
      {
        name: 'wp:effectExtent',
        attributes: effectExtentAttrs,
      },
      {
        name: 'wp:docPr',
        attributes: {
          id: attrs.id || 0,
          name: attrs.alt || `Picture ${imageName}`,
        },
      },
      {
        name: 'wp:cNvGraphicFramePr',
        elements: [
          {
            name: 'a:graphicFrameLocks',
            attributes: {
              'xmlns:a': drawingXmlns,
              noChangeAspect: 1,
            },
          },
        ],
      },
      {
        name: 'a:graphic',
        attributes: { 'xmlns:a': drawingXmlns },
        elements: [
          {
            name: 'a:graphicData',
            attributes: { uri: pictureXmlns },
            elements: [
              {
                name: 'pic:pic',
                attributes: { 'xmlns:pic': pictureXmlns },
                elements: [
                  {
                    name: 'pic:nvPicPr',
                    elements: [
                      {
                        name: 'pic:cNvPr',
                        attributes: {
                          id: attrs.id || 0,
                          name: attrs.title || `Picture ${imageName}`,
                        },
                      },
                      {
                        name: 'pic:cNvPicPr',
                        elements: [
                          {
                            name: 'a:picLocks',
                            attributes: {
                              noChangeAspect: 1,
                              noChangeArrowheads: 1,
                            },
                          },
                        ],
                      },
                    ],
                  },
                  {
                    name: 'pic:blipFill',
                    elements: [
                      {
                        name: 'a:blip',
                        attributes: {
                          'r:embed': imageId,
                        },
                      },
                      {
                        name: 'a:stretch',
                        elements: [{ name: 'a:fillRect' }],
                      },
                    ],
                  },
                  {
                    name: 'pic:spPr',
                    attributes: {
                      bwMode: 'auto',
                    },
                    elements: [
                      {
                        name: 'a:xfrm',
                        attributes: xfrmAttrs,
                        elements: [
                          {
                            name: 'a:ext',
                            attributes: {
                              cx: size.w,
                              cy: size.h,
                            },
                          },
                          {
                            name: 'a:off',
                            attributes: {
                              x: 0,
                              y: 0,
                            },
                          },
                        ],
                      },
                      {
                        name: 'a:prstGeom',
                        attributes: { prst: 'rect' },
                        elements: [{ name: 'a:avLst' }],
                      },
                      {
                        name: 'a:noFill',
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
  };
};
function getPngDimensions(base64) {
  if (!base64) return {};
  const type = base64.split(';')[0].split('/')[1];
  if (!base64 || type !== 'png') {
    return {
      originalWidth: void 0,
      originalHeight: void 0,
    };
  }
  let header = base64.split(',')[1].slice(0, 50);
  let uint8 = Uint8Array.from(atob(header), (c) => c.charCodeAt(0));
  let dataView = new DataView(uint8.buffer, 0, 28);
  return {
    originalWidth: dataView.getInt32(16),
    originalHeight: dataView.getInt32(20),
  };
}
function getScaledSize(originalWidth, originalHeight, maxWidth, maxHeight) {
  let scaledWidth = originalWidth;
  let scaledHeight = originalHeight;
  let ratio = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
  scaledWidth = Math.round(scaledWidth * ratio);
  scaledHeight = Math.round(scaledHeight * ratio);
  return { scaledWidth, scaledHeight };
}
function resizeKeepAspectRatio(width, height, maxWidth) {
  if (width > maxWidth) {
    let scale = maxWidth / width;
    let newHeight = Math.round(height * scale);
    return { width: maxWidth, height: newHeight };
  }
  return { width, height };
}
function addNewImageRelationship(params, imagePath) {
  const newId = 'rId' + generateDocxRandomId();
  const newRel = {
    type: 'element',
    name: 'Relationship',
    attributes: {
      Id: newId,
      Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
      Target: imagePath,
    },
  };
  params.relationships.push(newRel);
  return newId;
}
function addImageRelationshipForId(params, id, imagePath) {
  const newRel = {
    type: 'element',
    name: 'Relationship',
    attributes: {
      Id: id,
      Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
      Target: imagePath,
    },
  };
  params.relationships.push(newRel);
}
function translateVectorShape(params) {
  const { node } = params;
  const { drawingContent } = node.attrs;
  const drawing = {
    name: 'w:drawing',
    elements: [...(drawingContent ? [...(drawingContent.elements || [])] : [])],
  };
  const choice = {
    name: 'mc:Choice',
    attributes: { Requires: 'wps' },
    elements: [drawing],
  };
  const alternateContent = {
    name: 'mc:AlternateContent',
    elements: [choice],
  };
  return wrapTextInRun(alternateContent);
}
function translateShapeGroup(params) {
  const { node } = params;
  const { drawingContent } = node.attrs;
  if (drawingContent) {
    const drawing = {
      name: 'w:drawing',
      elements: [...(drawingContent.elements || [])],
    };
    const choice = {
      name: 'mc:Choice',
      attributes: { Requires: 'wpg' },
      elements: [drawing],
    };
    const alternateContent = {
      name: 'mc:AlternateContent',
      elements: [choice],
    };
    return wrapTextInRun(alternateContent);
  }
  return wrapTextInRun({
    name: 'w:drawing',
    elements: [],
  });
}
function translateAnchorNode(params) {
  const { attrs } = params.node;
  const anchorElements = [];
  if (attrs.simplePos) {
    anchorElements.push({
      name: 'wp:simplePos',
      attributes: {
        x: 0,
        y: 0,
      },
    });
  }
  if (attrs.anchorData) {
    const hElements = [];
    if (attrs.marginOffset.horizontal !== void 0) {
      hElements.push({
        name: 'wp:posOffset',
        elements: [{ type: 'text', text: pixelsToEmu(attrs.marginOffset.horizontal).toString() }],
      });
    }
    if (attrs.anchorData.alignH) {
      hElements.push({
        name: 'wp:align',
        elements: [{ type: 'text', text: attrs.anchorData.alignH }],
      });
    }
    anchorElements.push({
      name: 'wp:positionH',
      attributes: { relativeFrom: attrs.anchorData.hRelativeFrom },
      ...(hElements.length && { elements: hElements }),
    });
    const vElements = [];
    if (attrs.marginOffset.top !== void 0) {
      vElements.push({
        name: 'wp:posOffset',
        elements: [{ type: 'text', text: pixelsToEmu(attrs.marginOffset.top).toString() }],
      });
    }
    if (attrs.anchorData.alignV) {
      vElements.push({
        name: 'wp:align',
        elements: [{ type: 'text', text: attrs.anchorData.alignV }],
      });
    }
    anchorElements.push({
      name: 'wp:positionV',
      attributes: { relativeFrom: attrs.anchorData.vRelativeFrom },
      ...(vElements.length && { elements: vElements }),
    });
  }
  const nodeElements = translateImageNode(params);
  const inlineAttrs = {
    ...(attrs.originalAttributes || {}),
    ...(nodeElements.attributes || {}),
  };
  if (inlineAttrs.relativeHeight == null) {
    inlineAttrs.relativeHeight = 1;
  }
  if (attrs.originalAttributes?.simplePos !== void 0) {
    inlineAttrs.simplePos = attrs.originalAttributes.simplePos;
  } else if (attrs.simplePos !== void 0) {
    inlineAttrs.simplePos = attrs.simplePos;
  }
  if (attrs.originalAttributes?.locked !== void 0) {
    inlineAttrs.locked = attrs.originalAttributes.locked;
  }
  if (attrs.originalAttributes?.layoutInCell !== void 0) {
    inlineAttrs.layoutInCell = attrs.originalAttributes.layoutInCell;
  }
  if (attrs.originalAttributes?.allowOverlap !== void 0) {
    inlineAttrs.allowOverlap = attrs.originalAttributes.allowOverlap;
  }
  const wrapElement = {
    name: `wp:wrap${attrs.wrap?.type || 'None'}`,
    // Important: wp:anchor will break if no wrapping is specified. We need to use wrapNone.
  };
  switch (attrs.wrap?.type) {
    case 'Square':
      wrapElement.attributes = {
        wrapText: attrs.wrap.attrs.wrapText,
      };
      if ('distBottom' in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distB = pixelsToEmu(attrs.wrap.attrs.distBottom);
      }
      if ('distLeft' in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distL = pixelsToEmu(attrs.wrap.attrs.distLeft);
      }
      if ('distRight' in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distR = pixelsToEmu(attrs.wrap.attrs.distRight);
      }
      if ('distTop' in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distT = pixelsToEmu(attrs.wrap.attrs.distTop);
      }
      break;
    case 'TopAndBottom': {
      const attributes = {};
      let hasKeys = false;
      if ('distBottom' in (attrs.wrap.attrs || {})) {
        attributes.distB = pixelsToEmu(attrs.wrap.attrs.distBottom);
        hasKeys = true;
      }
      if ('distTop' in (attrs.wrap.attrs || {})) {
        attributes.distT = pixelsToEmu(attrs.wrap.attrs.distTop);
        hasKeys = true;
      }
      if (hasKeys) {
        wrapElement.attributes = attributes;
      }
      break;
    }
    case 'Through':
    case 'Tight': {
      const attributes = {};
      if ('distLeft' in (attrs.wrap.attrs || {})) {
        attributes.distL = pixelsToEmu(attrs.wrap.attrs.distLeft);
      }
      if ('distRight' in (attrs.wrap.attrs || {})) {
        attributes.distR = pixelsToEmu(attrs.wrap.attrs.distRight);
      }
      if ('distTop' in (attrs.wrap.attrs || {})) {
        attributes.distT = pixelsToEmu(attrs.wrap.attrs.distTop);
      }
      if ('distBottom' in (attrs.wrap.attrs || {})) {
        attributes.distB = pixelsToEmu(attrs.wrap.attrs.distBottom);
      }
      const wrapText = attrs.wrap.attrs?.wrapText || 'bothSides';
      {
        attributes.wrapText = wrapText;
      }
      if (Object.keys(attributes).length) {
        wrapElement.attributes = attributes;
      }
      if (attrs.wrap.attrs?.polygon) {
        const polygonNode = objToPolygon(attrs.wrap.attrs.polygon);
        if (polygonNode) {
          if (attrs.wrap.attrs?.polygonEdited !== void 0) {
            polygonNode.attributes = {
              ...(polygonNode.attributes || {}),
              edited: String(attrs.wrap.attrs.polygonEdited),
            };
          }
          wrapElement.elements = [polygonNode];
        }
      }
      break;
    }
    case 'None':
      inlineAttrs.behindDoc = attrs.wrap.attrs?.behindDoc ? '1' : '0';
      break;
  }
  const effectIndex = nodeElements.elements.findIndex((el) => el.name === 'wp:effectExtent');
  const elementsWithWrap = [
    ...nodeElements.elements.slice(0, effectIndex + 1),
    wrapElement,
    ...nodeElements.elements.slice(effectIndex + 1),
  ];
  return {
    name: 'wp:anchor',
    attributes: inlineAttrs,
    elements: [...anchorElements, ...elementsWithWrap],
  };
}
const XML_NODE_NAME$f = 'wp:anchor';
const SD_NODE_NAME$c = ['image', 'shapeGroup', 'vectorShape', 'contentBlock'];
const validXmlAttributes$a = ['distT', 'distB', 'distL', 'distR'].map((xmlName) => createAttributeHandler(xmlName));
function encode$l(params) {
  const { node } = params.extraParams;
  if (!node || !node.name) {
    return null;
  }
  return handleAnchorNode(params);
}
function decode$n(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  return translateAnchorNode(params);
}
const config$e = {
  xmlName: XML_NODE_NAME$f,
  sdNodeOrKeyName: SD_NODE_NAME$c,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$l,
  decode: decode$n,
  attributes: validXmlAttributes$a,
};
const translator$u = NodeTranslator.from(config$e);
function handleInlineNode(params) {
  const { node } = params.extraParams;
  if (node.name !== 'wp:inline') {
    return null;
  }
  return handleImageNode(node, params, false);
}
function translateInlineNode(params) {
  const nodeElements = translateImageNode(params);
  return {
    name: 'wp:inline',
    attributes: nodeElements.attributes,
    elements: nodeElements.elements,
  };
}
const XML_NODE_NAME$e = 'wp:inline';
const SD_NODE_NAME$b = ['image', 'shapeGroup', 'vectorShape', 'contentBlock'];
const validXmlAttributes$9 = ['distT', 'distB', 'distL', 'distR'].map((xmlName) => createAttributeHandler(xmlName));
function encode$k(params) {
  const { node } = params.extraParams;
  if (!node || !node.name) {
    return null;
  }
  return handleInlineNode(params);
}
function decode$m(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  return translateInlineNode(params);
}
const config$d = {
  xmlName: XML_NODE_NAME$e,
  sdNodeOrKeyName: SD_NODE_NAME$b,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$k,
  decode: decode$m,
  attributes: validXmlAttributes$9,
};
const translator$t = NodeTranslator.from(config$d);
const XML_NODE_NAME$d = 'w:drawing';
const SD_NODE_NAME$a = [];
const validXmlAttributes$8 = [];
function encode$j(params) {
  const nodes = params.nodes;
  const node = nodes[0];
  const translatorByChildName = {
    'wp:anchor': translator$u,
    'wp:inline': translator$t,
  };
  return node.elements.reduce((acc, child) => {
    if (acc) return acc;
    const translator2 = translatorByChildName[child.name];
    if (!translator2) return acc;
    return translator2.encode({ ...params, extraParams: { node: child } }) || acc;
  }, null);
}
function decode$l(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const childTranslator = node.attrs.isAnchor ? translator$u : translator$t;
  const resultNode = childTranslator.decode(params);
  return wrapTextInRun(
    {
      name: 'w:drawing',
      elements: [resultNode],
    },
    [],
  );
}
const config$c = {
  xmlName: XML_NODE_NAME$d,
  sdNodeOrKeyName: SD_NODE_NAME$a,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$j,
  decode: decode$l,
  attributes: validXmlAttributes$8,
};
const translator$s = NodeTranslator.from(config$c);
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement('div');
  container.appendChild(documentFragment);
  return container.innerHTML;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = '';
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    const chunk =
      node.type.spec.toText?.({
        node,
        pos,
        parent,
        index,
      }) ||
      node.textContent ||
      '%leaf%';
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
const extractListLevelStyles = (cssText, listId, level, numId) => {
  const pattern = new RegExp(`@list\\s+l${listId}:level${level}(?:\\s+lfo${numId})?\\s*\\{([^}]+)\\}`, 'i');
  const match = cssText.match(pattern);
  if (!match) return null;
  const rawStyles = match[1]
    .split(';')
    .map((line) => line.trim())
    .filter(Boolean);
  const styleMap = {};
  for (const style of rawStyles) {
    const [key2, value] = style.split(':').map((s2) => s2.trim());
    styleMap[key2] = value;
  }
  return styleMap;
};
const numDefMap = /* @__PURE__ */ new Map([
  ['decimal', 'decimal'],
  ['alpha-lower', 'lowerLetter'],
  ['alpha-upper', 'upperLetter'],
  ['roman-lower', 'lowerRoman'],
  ['roman-upper', 'upperRoman'],
  ['bullet', 'bullet'],
]);
const numDefByTypeMap = /* @__PURE__ */ new Map([
  ['1', 'decimal'],
  ['a', 'lowerLetter'],
  ['A', 'upperLetter'],
  ['I', 'upperRoman'],
  ['i', 'lowerRoman'],
]);
function getStartNumber(lvlText) {
  const match = lvlText.match(/^(\d+)/);
  if (match) return parseInt(match[1], 10);
  return null;
}
function letterToNumber(letter) {
  return letter.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1;
}
function getStartNumberFromAlpha(lvlText) {
  const match = lvlText.match(/^([a-zA-Z])/);
  if (match) return letterToNumber(match[1]);
  return null;
}
function romanToNumber(roman) {
  const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1e3 };
  let num = 0,
    prev = 0;
  for (let i = roman.length - 1; i >= 0; i--) {
    const curr = map[roman[i].toUpperCase()] || 0;
    if (curr < prev) num -= curr;
    else num += curr;
    prev = curr;
  }
  return num;
}
function getStartNumberFromRoman(lvlText) {
  const match = lvlText.match(/^([ivxlcdmIVXLCDM]+)/);
  if (match) return romanToNumber(match[1]);
  return null;
}
const startHelperMap = /* @__PURE__ */ new Map([
  ['decimal', getStartNumber],
  ['lowerLetter', getStartNumberFromAlpha],
  ['upperLetter', getStartNumberFromAlpha],
  ['lowerRoman', getStartNumberFromRoman],
  ['upperRoman', getStartNumberFromRoman],
  ['bullet', () => 1],
]);
const googleNumDefMap = /* @__PURE__ */ new Map([
  ['decimal', 'decimal'],
  ['decimal-leading-zero', 'decimal'],
  ['lower-alpha', 'lowerLetter'],
  ['upper-alpha', 'upperLetter'],
  ['lower-roman', 'lowerRoman'],
  ['upper-roman', 'upperRoman'],
  ['bullet', 'bullet'],
]);
const getLvlTextForGoogleList = (fmt, level, editor) => {
  const bulletListDef = editor.converter.numbering.abstracts[0];
  const bulletDefForLevel = bulletListDef.elements.find(
    (el) => el.name === 'w:lvl' && el.attributes?.['w:ilvl'] === (level - 1).toString(),
  );
  const bulletLvlText = bulletDefForLevel.elements.find((el) => el.name === 'w:lvlText')?.attributes?.['w:val'];
  switch (fmt) {
    case 'decimal-leading-zero':
      return `0%${level}.`;
    case 'bullet':
      return bulletLvlText;
    default:
      return `%${level}.`;
  }
};
const handleDocxPaste = (html, editor, view) => {
  const { converter } = editor;
  if (!converter || !converter.convertedXml) return handleHtmlPaste(html, editor);
  let cleanedHtml = convertEmToPt(html);
  cleanedHtml = cleanHtmlUnnecessaryTags(cleanedHtml);
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = cleanedHtml;
  const data = tempDiv.querySelectorAll('p, li');
  const startMap = {};
  data.forEach((item) => {
    let type;
    if (item.localName === 'li') {
      type = 'listItem';
    } else {
      const html2 = item.innerHTML;
      type = 'p';
      if (!html2.includes('<!--[if !supportLists]')) return;
    }
    const styleAttr = item.getAttribute('style') || '';
    const msoListMatch = styleAttr.match(/mso-list:\s*l(\d+)\s+level(\d+)\s+lfo(\d+)/);
    const css = tempDiv.querySelector('style').innerHTML;
    if (msoListMatch) {
      const [, abstractId, level, numId] = msoListMatch;
      const styles = extractListLevelStyles(css, abstractId, level, numId) || {};
      let start, numFmt, lvlText;
      if (type === 'listItem') {
        const listType = item.parentNode.getAttribute('type');
        const startAttr = item.parentNode.getAttribute('start');
        if (!startMap[numId]) startMap[numId] = startAttr;
        start = startMap[numId];
        numFmt = numDefByTypeMap.get(listType);
        lvlText = `%${level}.`;
      } else {
        const msoNumFormat = styles['mso-level-number-format'] || 'decimal';
        numFmt = numDefMap.get(msoNumFormat);
        const punc = item.innerText?.match(/^\s*[a-zA-Z0-9]+([.()])/i)?.[1] || '.';
        lvlText = numFmt === 'bullet' ? normalizeLvlTextChar(styles['mso-level-text']) : `%${level}${punc}`;
        const startGetter = startHelperMap.get(numFmt);
        if (!startMap[numId]) startMap[numId] = startGetter(item.children[0]?.innerText || '1');
        start = startMap[numId];
      }
      item.setAttribute('data-num-id', numId);
      item.setAttribute('data-list-level', parseInt(level) - 1);
      item.setAttribute('data-start', start);
      item.setAttribute('data-lvl-text', lvlText);
      item.setAttribute('data-num-fmt', numFmt);
      const ptToPxRatio = 1.333;
      const indent = parseInt(styles['margin-left']) * ptToPxRatio || 0;
      if (indent > 0) item.setAttribute('data-left-indent', indent);
    }
    extractAndRemoveConditionalPrefix(item);
  });
  transformWordLists(tempDiv, editor);
  const doc = DOMParser$1.fromSchema(editor.schema).parse(tempDiv);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc, true));
  return true;
};
const transformWordLists = (container, editor) => {
  const listItems = Array.from(container.querySelectorAll('[data-num-id]'));
  const lists = {};
  const mappedLists = {};
  for (const item of listItems) {
    const level = parseInt(item.getAttribute('data-list-level'));
    const numFmt = item.getAttribute('data-num-fmt');
    const start = item.getAttribute('data-start');
    const lvlText = item.getAttribute('data-lvl-text');
    const indent = item.getAttribute('data-left-indent');
    const importedId = item.getAttribute('data-num-id');
    if (!mappedLists[importedId]) mappedLists[importedId] = ListHelpers.getNewListId(editor);
    const id = mappedLists[importedId];
    const listType = numFmt === 'bullet' ? 'bulletList' : 'orderedList';
    ListHelpers.generateNewListDefinition({
      numId: id,
      listType,
      level: level.toString(),
      start,
      fmt: numFmt,
      text: lvlText,
      editor,
    });
    if (!lists[id]) lists[id] = { levels: {} };
    const currentListByNumId = lists[id];
    if (!currentListByNumId.levels[level]) currentListByNumId.levels[level] = Number(start) || 1;
    else currentListByNumId.levels[level]++;
    Object.keys(currentListByNumId.levels).forEach((key2) => {
      const level1 = Number(key2);
      if (level1 > level) {
        delete currentListByNumId.levels[level1];
      }
    });
    const path = generateListPath(level, currentListByNumId.levels, start);
    if (!path.length) path.push(currentListByNumId.levels[level]);
    const li = document.createElement('li');
    li.innerHTML = item.innerHTML;
    li.setAttribute('data-num-id', id);
    li.setAttribute('data-list-level', JSON.stringify(path));
    li.setAttribute('data-level', level);
    li.setAttribute('data-lvl-text', lvlText);
    li.setAttribute('data-num-fmt', numFmt);
    if (indent) li.setAttribute('data-indent', JSON.stringify({ left: indent }));
    if (item.hasAttribute('data-font-family')) {
      li.setAttribute('data-font-family', item.getAttribute('data-font-family'));
    }
    if (item.hasAttribute('data-font-size')) {
      li.setAttribute('data-font-size', item.getAttribute('data-font-size'));
    }
    const parentNode = item.parentNode;
    let listForLevel;
    const newList = numFmt === 'bullet' ? document.createElement('ul') : document.createElement('ol');
    newList.setAttribute('data-list-id', id);
    newList.level = level;
    parentNode.insertBefore(newList, item);
    listForLevel = newList;
    listForLevel.appendChild(li);
    item.remove();
  }
};
const generateListPath = (level, levels, start) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      if (!levels[i]) levels[i] = Number(start);
      path.unshift(levels[i]);
    }
  }
  return path;
};
function extractAndRemoveConditionalPrefix(item) {
  const nodes = Array.from(item.childNodes);
  let fontFamily = null;
  let fontSize = null;
  let start = -1,
    end = -1;
  nodes.forEach((node, index) => {
    if (node.nodeType === Node.COMMENT_NODE && node.nodeValue.includes('[if !supportLists]')) {
      start = index;
    }
    if (start !== -1 && node.nodeType === Node.COMMENT_NODE && node.nodeValue.includes('[endif]')) {
      end = index;
    }
  });
  if (start !== -1 && end !== -1) {
    for (let i = start + 1; i < end; i++) {
      const node = nodes[i];
      if (node.nodeType === Node.ELEMENT_NODE && node.style) {
        fontFamily = fontFamily || node.style.fontFamily;
        fontSize = fontSize || node.style.fontSize;
      }
    }
    for (let i = end; i >= start; i--) {
      item.removeChild(item.childNodes[i]);
    }
    if (fontFamily) item.setAttribute('data-font-family', fontFamily);
    if (fontSize) item.setAttribute('data-font-size', fontSize);
  }
}
function flattenListsInHtml$1(html, editor) {
  let parser, NodeInterface;
  if (editor.options?.mockDocument) {
    const win = editor.options.mockDocument.defaultView;
    parser = new win.DOMParser();
    NodeInterface = win.Node;
  } else {
    parser = new DOMParser();
    NodeInterface = window.Node;
  }
  const doc = parser.parseFromString(html, 'text/html');
  let foundList;
  while ((foundList = findListToFlatten$1(doc))) {
    flattenFoundList$1(foundList, editor, NodeInterface);
  }
  return doc.body.innerHTML;
}
function findListToFlatten$1(doc) {
  let list = doc.querySelector('ol:not([data-list-id]), ul:not([data-list-id])');
  if (list) return list;
  const allLists = doc.querySelectorAll('ol[data-list-id], ul[data-list-id]');
  for (const list2 of allLists) {
    const liChildren = Array.from(list2.children).filter((c) => c.tagName.toLowerCase() === 'li');
    if (liChildren.length > 1) {
      return list2;
    }
    const nestedLists = list2.querySelectorAll('ol, ul');
    if (nestedLists.length > 0) {
      return list2;
    }
  }
  return null;
}
function flattenFoundList$1(listElem, editor, NodeInterface) {
  const localDoc = listElem.ownerDocument;
  const tag = listElem.tagName.toLowerCase();
  let rootNumId = listElem.getAttribute('data-list-id');
  if (!rootNumId) {
    rootNumId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId: rootNumId,
      listType: tag === 'ol' ? 'orderedList' : 'bulletList',
      editor,
    });
  }
  let level = Number(listElem.getAttribute('data-level'));
  if (Number.isNaN(level)) {
    level = 0;
  }
  let ancestor = listElem.parentElement;
  while (ancestor && ancestor !== localDoc.body) {
    if (ancestor.tagName && ancestor.tagName.toLowerCase() === 'li') {
      level++;
    }
    ancestor = ancestor.parentElement;
  }
  const items = Array.from(listElem.children).filter((c) => c.tagName.toLowerCase() === 'li');
  const newLists = [];
  items.forEach((li) => {
    const nestedLists = Array.from(li.querySelectorAll('ol, ul'));
    const nestedListsData = nestedLists.map((nl) => ({
      element: nl.cloneNode(true),
      parent: nl.parentNode,
    }));
    nestedLists.forEach((nl) => nl.parentNode.removeChild(nl));
    const newList = createSingleItemList({ li, tag, rootNumId, level, editor, NodeInterface });
    newLists.push(newList);
    nestedListsData.forEach((data) => {
      data.element.setAttribute('data-level', level + 1);
      newLists.push(data.element);
    });
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function createSingleItemList({ li, tag, rootNumId, level, listLevel, editor, NodeInterface }) {
  const localDoc = li.ownerDocument;
  const ELEMENT_NODE = NodeInterface.ELEMENT_NODE;
  const TEXT_NODE = NodeInterface.TEXT_NODE;
  const newList = localDoc.createElement(tag);
  const newLi = localDoc.createElement('li');
  Array.from(li.attributes).forEach((attr) => {
    if (
      !attr.name.startsWith('data-num-') &&
      !attr.name.startsWith('data-level') &&
      !attr.name.startsWith('data-list-')
    ) {
      newLi.setAttribute(attr.name, attr.value);
    }
  });
  newList.setAttribute('data-list-id', rootNumId);
  newLi.setAttribute('data-num-id', rootNumId);
  newLi.setAttribute('data-level', String(level));
  const { listNumberingType, lvlText } = ListHelpers.getListDefinitionDetails({
    numId: rootNumId,
    level,
    editor,
  });
  newLi.setAttribute('data-num-fmt', listNumberingType);
  newLi.setAttribute('data-lvl-text', lvlText || '');
  newLi.setAttribute('data-list-level', JSON.stringify(listLevel || [level + 1]));
  Array.from(li.childNodes).forEach((node) => {
    if (node.nodeType === ELEMENT_NODE || (node.nodeType === TEXT_NODE && node.textContent.trim())) {
      newLi.appendChild(node.cloneNode(true));
    }
  });
  if (newLi.childNodes.length === 0 || (newLi.childNodes.length === 1 && newLi.childNodes[0].nodeType === TEXT_NODE)) {
    const textContent2 = newLi.textContent.trim();
    if (textContent2) {
      newLi.innerHTML = '';
      const p = localDoc.createElement('p');
      p.textContent = textContent2;
      newLi.appendChild(p);
    }
  }
  newList.appendChild(newLi);
  return newList;
}
function unflattenListsInHtml(html) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  const allNodes = [...doc.body.children];
  const listSequences = [];
  let currentSequence = null;
  allNodes.forEach((node, index) => {
    const isFlattenList =
      node.tagName && (node.tagName === 'OL' || node.tagName === 'UL') && node.hasAttribute('data-list-id');
    if (isFlattenList) {
      const listId = node.getAttribute('data-list-id');
      if (currentSequence && currentSequence.id === listId) {
        currentSequence.lists.push({ element: node, index });
      } else {
        currentSequence = {
          id: listId,
          lists: [{ element: node, index }],
        };
        listSequences.push(currentSequence);
      }
    } else {
      currentSequence = null;
    }
  });
  listSequences.reverse().forEach((sequence) => {
    const sequenceLists = sequence.lists;
    if (sequenceLists.length === 0) {
      return;
    }
    const items = sequenceLists
      .map(({ element: list }) => {
        const liElement = list.querySelector('li');
        if (!liElement) return null;
        return {
          element: liElement,
          level: parseInt(liElement.getAttribute('data-level') || '0'),
          numFmt: liElement.getAttribute('data-num-fmt') || 'bullet',
          listLevel: JSON.parse(liElement.getAttribute('data-list-level') || '[1]'),
        };
      })
      .filter((item) => item !== null);
    if (items.length === 0) {
      return;
    }
    const rootList = buildNestedList({ items });
    const firstOriginalList = sequenceLists[0].element;
    firstOriginalList?.parentNode?.insertBefore(rootList, firstOriginalList);
    sequenceLists.forEach(({ element: list }) => {
      if (list.parentNode) list.parentNode.removeChild(list);
    });
  });
  return doc.body.innerHTML;
}
function buildNestedList({ items }) {
  if (!items.length) {
    return null;
  }
  const [rootItem] = items;
  const doc = rootItem.element.ownerDocument;
  const isOrderedList = rootItem.numFmt && !['bullet', 'none'].includes(rootItem.numFmt);
  const rootList = doc.createElement(isOrderedList ? 'ol' : 'ul');
  if (isOrderedList && rootItem.listLevel?.[0] && rootItem.listLevel[0] > 1) {
    rootList.setAttribute('start', rootItem.listLevel[0]);
  }
  const lastLevelItem = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    const { element: liElement, level, numFmt } = item;
    const cleanLi = cleanListItem(liElement.cloneNode(true));
    if (level === 0) {
      rootList.append(cleanLi);
      lastLevelItem.set(0, cleanLi);
    } else {
      const parentLi = lastLevelItem.get(level - 1);
      if (!parentLi) {
        rootList.append(cleanLi);
        lastLevelItem.set(level, cleanLi);
        return;
      }
      let nestedList = null;
      [...parentLi.children].forEach((child) => {
        if (child.tagName && (child.tagName === 'OL' || child.tagName === 'UL')) {
          nestedList = child;
        }
      });
      if (!nestedList) {
        const listType = numFmt && !['bullet', 'none'].includes(numFmt) ? 'ol' : 'ul';
        nestedList = doc.createElement(listType);
        parentLi.append(nestedList);
      }
      nestedList.append(cleanLi);
      lastLevelItem.set(level, cleanLi);
    }
  });
  return rootList;
}
function cleanListItem(listItem) {
  const attrs = [
    'data-num-id',
    'data-level',
    'data-num-fmt',
    'data-lvl-text',
    'data-list-level',
    'data-marker-type',
    'aria-label',
  ];
  attrs.forEach((attr) => {
    listItem.removeAttribute(attr);
  });
  return listItem;
}
const handleGoogleDocsHtml = (html, editor, view) => {
  const htmlWithPtSizing = convertEmToPt(html);
  const cleanedHtml = sanitizeHtml(htmlWithPtSizing).innerHTML;
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = cleanedHtml;
  const htmlWithMergedLists = mergeSeparateLists(tempDiv);
  const flattenHtml = flattenListsInHtml(htmlWithMergedLists, editor);
  const doc = DOMParser$1.fromSchema(editor.schema).parse(flattenHtml);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc, true));
  return true;
};
function flattenListsInHtml(container, editor) {
  let foundList;
  while ((foundList = findListToFlatten(container))) {
    flattenFoundList(foundList, editor);
  }
  return container;
}
function findListToFlatten(container) {
  let list = container.querySelector('ol:not([data-list-id]), ul:not([data-list-id])');
  if (list) return list;
  return null;
}
function flattenFoundList(listElem, editor) {
  let NodeInterface;
  if (editor.options.mockDocument) {
    const win = editor.options.mockDocument.defaultView;
    NodeInterface = win.Node;
  } else {
    NodeInterface = window.Node;
  }
  const tag = listElem.tagName.toLowerCase();
  const rootListLevel = Number(listElem.children[0].getAttribute('aria-level'));
  const rootListFmt = listElem.children[0].style['list-style-type'] || 'decimal';
  const start = listElem.getAttribute('start') || 1;
  const rootNumId = ListHelpers.getNewListId(editor);
  ListHelpers.generateNewListDefinition({
    numId: rootNumId,
    listType: tag === 'ol' ? 'orderedList' : 'bulletList',
    editor,
    fmt: googleNumDefMap.get(rootListFmt),
    level: (rootListLevel - 1).toString(),
    start,
    text: getLvlTextForGoogleList(rootListFmt, rootListLevel, editor),
  });
  const newLists = [];
  const items = Array.from(listElem.children).filter((c) => c.tagName.toLowerCase() === 'li');
  items.forEach((li) => {
    const level = Number(li.getAttribute('aria-level')) - 1;
    const listLevel = [level + 1];
    const nestedLists = getNestedLists([li.nextSibling]);
    const newList = createSingleItemList({ li, tag, rootNumId, level, listLevel, editor, NodeInterface });
    newLists.push(newList);
    if (nestedLists.length > 0) {
      newLists.push(nestedLists[0].cloneNode(true));
    }
    if (nestedLists.length && ['OL', 'UL'].includes(li.nextSibling.tagName)) {
      li.nextSibling?.remove();
    }
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function getNestedLists(nodes) {
  let result = [];
  const nodesArray = Array.from(nodes).filter((n) => n !== null);
  for (let item of nodesArray) {
    if (item.tagName === 'OL' || item.tagName === 'UL') {
      result.push(item);
      result.push(...getNestedLists(item.children));
    }
  }
  return result;
}
function mergeSeparateLists(container) {
  const tempCont = container.cloneNode(true);
  const rootLevelLists = Array.from(tempCont.querySelectorAll('ol:not(ol ol):not(ul ol)') || []);
  const mainList = rootLevelLists.find((list) => !list.getAttribute('start'));
  const hasStartAttr = rootLevelLists.some((list) => list.getAttribute('start') !== null);
  if (hasStartAttr) {
    const listsWithStartAttr = rootLevelLists.filter((list) => list.getAttribute('start') !== null);
    for (let [index, item] of listsWithStartAttr.entries()) {
      if (item.getAttribute('start') === (index + 2).toString()) {
        mainList.append(...item.childNodes);
        item.remove();
      }
    }
  }
  return tempCont;
}
class InputRule {
  constructor(config2) {
    __publicField(this, 'match');
    __publicField(this, 'handler');
    this.match = config2.match;
    this.handler = config2.handler;
  }
}
const inputRuleMatcherHandler = (text, match) => {
  if (isRegExp$1(match)) {
    return match.exec(text);
  }
  const inputRuleMatch = match(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[super-editor warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
const run = (config2) => {
  const { editor, from, to, text, rules, plugin } = config2;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from);
  if (
    $from.parent.type.spec.code ||
    !!($from.nodeBefore || $from.nodeAfter)?.marks.find((mark) => mark.type.spec.code)
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.match);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state = chainableEditorState(tr, view.state);
    const range = {
      from: from - (match[0].length - text.length),
      to,
    };
    const {
      commands: commands2,
      chain,
      can,
    } = new CommandService({
      editor,
      state,
    });
    const handler2 = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain,
      can,
    });
    if (handler2 === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from,
      to,
      text,
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
};
const inputRulesPlugin = ({ editor, rules }) => {
  const plugin = new Plugin({
    key: new PluginKey('inputRulesPlugin'),
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta('applyInputRules');
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text !== 'string') {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from } = simulatedInputMeta;
            const to = from + text.length;
            run({
              editor,
              from,
              to,
              text,
              rules,
              plugin,
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      },
    },
    props: {
      handleTextInput(view, from, to, text) {
        return run({
          editor,
          from,
          to,
          text,
          rules,
          plugin,
        });
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== 'Enter') {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: '\n',
            rules,
            plugin,
          });
        }
        return false;
      },
      // Paste handler
      handlePaste(view, event, slice) {
        const clipboard = event.clipboardData;
        const html = clipboard.getData('text/html');
        const fieldAnnotationContent = slice.content.content.filter((item) => item.type.name === 'fieldAnnotation');
        if (fieldAnnotationContent.length) {
          return false;
        }
        return handleClipboardPaste({ editor, view }, html);
      },
    },
    isInputRules: true,
  });
  return plugin;
};
function isWordHtml(html) {
  return /class=["']?Mso|xmlns:o=["']?urn:schemas-microsoft-com|<!--\[if gte mso|<meta[^>]+name=["']?Generator["']?[^>]+Word/i.test(
    html,
  );
}
function isGoogleDocsHtml(html) {
  return /docs-internal-guid-/.test(html);
}
function handleHtmlPaste(html, editor, source) {
  let cleanedHtml;
  cleanedHtml = htmlHandler(html, editor);
  const doc = DOMParser$1.fromSchema(editor.schema).parse(cleanedHtml);
  const { dispatch, state } = editor.view;
  if (!dispatch) return false;
  const { $from } = state.selection;
  const isInParagraph = $from.parent.type.name === 'paragraph';
  const isSingleParagraph = doc.childCount === 1 && doc.firstChild.type.name === 'paragraph';
  if (isInParagraph && isSingleParagraph) {
    const paragraphContent = doc.firstChild.content;
    const tr = state.tr.replaceSelectionWith(paragraphContent, false);
    dispatch(tr);
  } else if (isInParagraph && state.doc.textContent) {
    const allContent = [];
    doc.content.forEach((node, index) => {
      if (node.type.name === 'paragraph') {
        allContent.push(...node.content.content);
        if (index < doc.content.childCount - 1) {
          allContent.push(editor.schema.text('\n'));
        }
      }
    });
    if (allContent.length > 0) {
      const fragment = Fragment.from(allContent);
      const tr = state.tr.replaceSelectionWith(fragment, false);
      dispatch(tr);
    } else {
      dispatch(state.tr.replaceSelectionWith(doc, true));
    }
  } else {
    dispatch(state.tr.replaceSelectionWith(doc, true));
  }
  return true;
}
function htmlHandler(html, editor) {
  const flatHtml = flattenListsInHtml$1(html, editor);
  const htmlWithPtSizing = convertEmToPt(flatHtml);
  return sanitizeHtml(htmlWithPtSizing);
}
const convertEmToPt = (html) => {
  return html.replace(/font-size\s*:\s*([\d.]+)em/gi, (_, emValue) => {
    const em = parseFloat(emValue);
    const pt = Math.round(em * 12 * 100) / 100;
    return `font-size: ${pt}pt`;
  });
};
function cleanHtmlUnnecessaryTags(html) {
  return html
    .replace(/<o:p>.*?<\/o:p>/gi, '')
    .replace(/&nbsp;/gi, ' ')
    .replace(/<span[^>]*>\s*<\/span>/gi, '')
    .replace(/<p[^>]*>\s*<\/p>/gi, '')
    .trim();
}
function sanitizeHtml(html, forbiddenTags = ['meta', 'svg', 'script', 'style', 'button']) {
  const container = document.createElement('div');
  container.innerHTML = html;
  const walkAndClean = (node) => {
    for (const child of [...node.children]) {
      if (forbiddenTags.includes(child.tagName.toLowerCase())) {
        child.remove();
        continue;
      }
      if (child.hasAttribute('linebreaktype')) {
        child.removeAttribute('linebreaktype');
      }
      walkAndClean(child);
    }
  };
  walkAndClean(container);
  return container;
}
function handleClipboardPaste({ editor, view }, html) {
  let source;
  if (!html) {
    source = 'plain-text';
  } else if (isWordHtml(html)) {
    source = 'word-html';
  } else if (isGoogleDocsHtml(html)) {
    source = 'google-docs';
  } else {
    source = 'browser-html';
  }
  switch (source) {
    case 'plain-text':
      return false;
    case 'word-html':
      if (editor.options.mode === 'docx') {
        return handleDocxPaste(html, editor, view);
      }
      break;
    case 'google-docs':
      return handleGoogleDocsHtml(html, editor, view);
    // falls through to browser-html handling when not in DOCX mode
    case 'browser-html':
      return handleHtmlPaste(html, editor);
  }
  return false;
}
function translateFieldAnnotation(params) {
  const { node, isFinalDoc, fieldsHighlightColor } = params;
  const { attrs = {} } = node;
  const annotationHandler = getTranslationByAnnotationType(attrs.type, attrs.fieldType);
  if (!annotationHandler) return {};
  let processedNode;
  let sdtContentElements;
  let id = attrs.sdtId;
  if ((attrs.type === 'image' || attrs.type === 'signature') && !attrs.hash) {
    attrs.hash = generateDocxRandomId(4);
  }
  if (!attrs.sdtId) {
    id = generateRandomSigned32BitIntStrId();
  }
  if (isFinalDoc) {
    return annotationHandler(params);
  } else {
    processedNode = annotationHandler(params);
    sdtContentElements = [processedNode];
    if (attrs.type === 'html') {
      const runElements = processedNode.elements[0].elements.filter((el) => el.name === 'w:r');
      sdtContentElements = [...runElements];
    }
  }
  sdtContentElements = [...sdtContentElements];
  const fieldBackgroundTag = getFieldHighlightJson(fieldsHighlightColor);
  if (fieldBackgroundTag) {
    sdtContentElements.unshift(fieldBackgroundTag);
  }
  const annotationAttrs = {
    displayLabel: attrs.displayLabel,
    defaultDisplayLabel: attrs.defaultDisplayLabel,
    fieldId: attrs.fieldId,
    fieldType: attrs.fieldType,
    fieldTypeShort: attrs.type,
    fieldColor: attrs.fieldColor,
    fieldMultipleImage: attrs.multipleImage,
    fieldFontFamily: attrs.fontFamily,
    fieldFontSize: attrs.fontSize,
    fieldTextColor: attrs.textColor,
    fieldTextHighlight: attrs.textHighlight,
    hash: attrs.hash,
  };
  const annotationAttrsJson = JSON.stringify(annotationAttrs);
  const result = {
    name: 'w:sdt',
    elements: [
      {
        name: 'w:sdtPr',
        elements: [
          { name: 'w:alias', attributes: { 'w:val': attrs.displayLabel } },
          { name: 'w:tag', attributes: { 'w:val': annotationAttrsJson } },
          { name: 'w:id', attributes: { 'w:val': id } },
        ],
      },
      {
        name: 'w:sdtContent',
        elements: sdtContentElements,
      },
    ],
  };
  return result;
}
function getTranslationByAnnotationType(annotationType, annotationFieldType) {
  if (annotationType === 'text' && annotationFieldType === 'FILEUPLOADER') {
    return null;
  }
  const imageEmuSize = {
    w: 4286250,
    h: 4286250,
  };
  const signatureEmuSize = {
    w: 99e4,
    h: 495e3,
  };
  const dictionary = {
    text: prepareTextAnnotation,
    image: (params) => prepareImageAnnotation(params, imageEmuSize),
    signature: (params) => prepareImageAnnotation(params, signatureEmuSize),
    checkbox: prepareCheckboxAnnotation,
    html: prepareHtmlAnnotation,
    link: prepareUrlAnnotation,
  };
  return dictionary[annotationType];
}
function prepareTextAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] },
  } = params;
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  return getTextNodeForExport(attrs.displayLabel, [...marks, ...marksFromAttrs], params);
}
function prepareImageAnnotation(params, imageSize) {
  return translator$s.decode({
    ...params,
    imageSize,
  });
}
function prepareCheckboxAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] },
  } = params;
  const content = he.decode(attrs.displayLabel);
  return getTextNodeForExport(content, marks, params);
}
function prepareHtmlAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] },
    editorSchema,
  } = params;
  let html = attrs.rawHtml || attrs.displayLabel;
  const paragraphHtmlContainer = sanitizeHtml(html);
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  const allMarks = [...marks, ...marksFromAttrs];
  let state = EditorState.create({
    doc: DOMParser$1.fromSchema(editorSchema).parse(paragraphHtmlContainer),
  });
  if (allMarks.length) {
    state = applyMarksToHtmlAnnotation(state, allMarks);
  }
  const htmlAnnotationNode = state.doc.toJSON();
  const listTypes = ['bulletList', 'orderedList'];
  const { editor } = params;
  const seenLists = /* @__PURE__ */ new Map();
  state.doc.descendants((node) => {
    if (listTypes.includes(node.type.name)) {
      const listItem = node.firstChild;
      const { attrs: attrs2 } = listItem;
      const { level, numId } = attrs2;
      if (!seenLists.has(numId)) {
        const newNumId = ListHelpers.changeNumIdSameAbstract(numId, level, node.type.name, editor);
        listItem.attrs.numId = newNumId;
        seenLists.set(numId, newNumId);
      } else {
        const newNumId = seenLists.get(numId);
        listItem.attrs.numId = newNumId;
      }
    }
  });
  const elements = translateChildNodes({
    ...params,
    node: htmlAnnotationNode,
  });
  return {
    name: 'htmlAnnotation',
    elements,
  };
}
function prepareUrlAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] },
  } = params;
  if (!attrs.linkUrl) return prepareTextAnnotation(params);
  const newId = addNewLinkRelationship(params, attrs.linkUrl);
  const linkTextNode = getTextNodeForExport(attrs.linkUrl, marks, params);
  const contentNode = processLinkContentNode(linkTextNode);
  return {
    name: 'w:hyperlink',
    type: 'element',
    attributes: {
      'r:id': newId,
      'w:history': 1,
    },
    elements: [contentNode],
  };
}
function translateFieldAttrsToMarks(attrs = {}) {
  const { fontFamily, fontSize, bold, underline, italic, textColor, textHighlight } = attrs;
  const marks = [];
  if (fontFamily) marks.push({ type: 'fontFamily', attrs: { fontFamily } });
  if (fontSize) marks.push({ type: 'fontSize', attrs: { fontSize } });
  if (bold) marks.push({ type: 'bold', attrs: {} });
  if (underline) marks.push({ type: 'underline', attrs: {} });
  if (italic) marks.push({ type: 'italic', attrs: {} });
  if (textColor) marks.push({ type: 'color', attrs: { color: textColor } });
  if (textHighlight) marks.push({ type: 'highlight', attrs: { color: textHighlight } });
  return marks;
}
function applyMarksToHtmlAnnotation(state, marks) {
  const { tr, doc, schema } = state;
  const allowedMarks = ['fontFamily', 'fontSize', 'highlight'];
  if (!marks.some((m) => allowedMarks.includes(m.type))) {
    return state;
  }
  const fontFamily = marks.find((m) => m.type === 'fontFamily');
  const fontSize = marks.find((m) => m.type === 'fontSize');
  const highlight = marks.find((m) => m.type === 'highlight');
  const textStyleType = schema.marks.textStyle;
  const highlightType = schema.marks.highlight;
  doc.descendants((node, pos) => {
    if (!node.isText) return;
    const foundTextStyle = node.marks.find((m) => m.type.name === 'textStyle');
    const foundHighlight = node.marks.find((m) => m.type.name === 'highlight');
    if (!foundTextStyle) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        textStyleType.create({
          ...fontFamily?.attrs,
          ...fontSize?.attrs,
        }),
      );
    } else if (!foundTextStyle?.attrs.fontFamily && fontFamily) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontFamily.attrs,
        }),
      );
    } else if (!foundTextStyle?.attrs.fontSize && fontSize) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontSize.attrs,
        }),
      );
    }
    if (!foundHighlight) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        highlightType.create({
          ...highlight?.attrs,
        }),
      );
    }
  });
  return state.apply(tr);
}
function getFieldHighlightJson(fieldsHighlightColor) {
  if (!fieldsHighlightColor) return null;
  let parsedColor = fieldsHighlightColor.trim();
  const hexRegex = /^#?([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;
  if (!hexRegex.test(parsedColor)) {
    console.warn(`Invalid HEX color provided to fieldsHighlightColor export param: ${fieldsHighlightColor}`);
    return null;
  }
  if (parsedColor.startsWith('#')) {
    parsedColor = parsedColor.slice(1);
  }
  return {
    name: 'w:rPr',
    elements: [
      {
        name: 'w:shd',
        attributes: {
          'w:fill': `#${parsedColor}`,
          'w:color': 'auto',
          'w:val': 'clear',
        },
      },
    ],
  };
}
function translateDocumentSection(params) {
  const { node } = params;
  const { attrs = {} } = node;
  const childContent = translateChildNodes({ ...params, nodes: node.content });
  const nodeElements = [
    {
      name: 'w:sdtContent',
      elements: childContent,
    },
  ];
  const exportedTag = JSON.stringify({
    type: 'documentSection',
    description: attrs.description,
  });
  const sdtPr = generateSdtPrTagForDocumentSection(attrs.id, attrs.title, exportedTag);
  const { isLocked } = attrs;
  if (isLocked) {
    sdtPr.elements.push({
      name: 'w:lock',
      attributes: {
        'w:val': 'sdtContentLocked',
      },
    });
  }
  nodeElements.unshift(sdtPr);
  const result = {
    name: 'w:sdt',
    elements: nodeElements,
  };
  return result;
}
const generateSdtPrTagForDocumentSection = (id, title, tag) => {
  return {
    name: 'w:sdtPr',
    elements: [
      {
        name: 'w:id',
        attributes: {
          'w:val': id,
        },
      },
      {
        name: 'w:alias',
        attributes: {
          'w:val': title,
        },
      },
      {
        name: 'w:tag',
        attributes: {
          'w:val': tag,
        },
      },
    ],
  };
};
function translateDocumentPartObj(params) {
  const { node } = params;
  const { attrs = {} } = node;
  const childContent = translateChildNodes({ ...params, nodes: node.content });
  const nodeElements = [
    {
      name: 'w:sdtPr',
      elements: [
        {
          name: 'w:id',
          attributes: {
            'w:val': attrs.id,
          },
        },
        {
          name: 'w:docPartObj',
          elements: [
            {
              name: 'w:docPartGallery',
              attributes: {
                'w:val': attrs.docPartGallery,
              },
            },
            ...(attrs.docPartUnique
              ? [
                  {
                    name: 'w:docPartUnique',
                  },
                ]
              : []),
          ],
        },
      ],
    },
    {
      name: 'w:sdtContent',
      elements: childContent,
    },
  ];
  const result = {
    name: 'w:sdt',
    elements: nodeElements,
  };
  return result;
}
function translateStructuredContent(params) {
  const { node, isFinalDoc } = params;
  const childContent = translateChildNodes({ ...params, node });
  const childElements = Array.isArray(childContent) ? childContent : [childContent];
  if (isFinalDoc) {
    if (node?.type === 'structuredContent') {
      return convertSdtContentToRuns(childElements);
    }
    if (node?.type === 'structuredContentBlock') {
      return childElements.length === 1 ? childElements[0] : childElements;
    }
  }
  const sdtContent = { name: 'w:sdtContent', elements: childElements };
  const sdtPr = generateSdtPrTagForStructuredContent({ node });
  const nodeElements = [sdtPr, sdtContent];
  const result = {
    name: 'w:sdt',
    elements: nodeElements,
  };
  return result;
}
function generateSdtPrTagForStructuredContent({ node }) {
  const { attrs = {} } = node;
  const id = {
    name: 'w:id',
    type: 'element',
    attributes: { 'w:val': attrs.id },
  };
  const alias = {
    name: 'w:alias',
    type: 'element',
    attributes: { 'w:val': attrs.alias },
  };
  const tag = {
    name: 'w:tag',
    type: 'element',
    attributes: { 'w:val': attrs.tag },
  };
  const resultElements = [];
  if (attrs.id) resultElements.push(id);
  if (attrs.alias) resultElements.push(alias);
  if (attrs.tag) resultElements.push(tag);
  if (attrs.sdtPr) {
    const elements = attrs.sdtPr.elements || [];
    const elementsToExclude = ['w:id', 'w:alias', 'w:tag'];
    const restElements = elements.filter((el) => !elementsToExclude.includes(el.name));
    const result2 = {
      name: 'w:sdtPr',
      type: 'element',
      elements: [...resultElements, ...restElements],
    };
    return result2;
  }
  const result = {
    name: 'w:sdtPr',
    type: 'element',
    elements: resultElements,
  };
  return result;
}
const XML_NODE_NAME$c = 'w:sdt';
const SD_NODE_NAME$9 = ['fieldAnnotation', 'structuredContent', 'structuredContentBlock', 'documentSection'];
const validXmlAttributes$7 = [];
function encode$i(params) {
  const nodes = params.nodes;
  const node = nodes[0];
  const { type: sdtType, handler: handler2 } = sdtNodeTypeStrategy(node);
  if (!handler2 || sdtType === 'unknown') {
    return void 0;
  }
  const result = handler2(params);
  return result;
}
function decode$k(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const types = {
    fieldAnnotation: () => translateFieldAnnotation(params),
    structuredContent: () => translateStructuredContent(params),
    structuredContentBlock: () => translateStructuredContent(params),
    documentSection: () => translateDocumentSection(params),
    documentPartObject: () => translateDocumentPartObj(params),
    // Handled in doc-part-obj translator
    default: () => null,
  };
  const decoder = types[node.type] ?? types.default;
  const result = decoder();
  return result;
}
const config$b = {
  xmlName: XML_NODE_NAME$c,
  sdNodeOrKeyName: SD_NODE_NAME$9,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$i,
  decode: decode$k,
  attributes: validXmlAttributes$7,
};
const translator$r = NodeTranslator.from(config$b);
function preProcessVerticalMergeCells(table, { editorSchema }) {
  if (!table || !Array.isArray(table.content)) {
    return table;
  }
  const rows = table.content;
  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    if (!row) continue;
    if (!Array.isArray(row.content)) {
      row.content = [];
    }
    for (let cellIndex = 0; cellIndex < row.content.length; cellIndex++) {
      const cell = row.content[cellIndex];
      if (!cell) continue;
      const attrs = cell.attrs || {};
      if (!attrs.rowspan || attrs.rowspan <= 1) continue;
      const maxRowspan = Math.min(attrs.rowspan, rows.length - rowIndex);
      for (let offset = 1; offset < maxRowspan; offset++) {
        const rowToChange = rows[rowIndex + offset];
        if (!rowToChange) continue;
        if (!Array.isArray(rowToChange.content)) {
          rowToChange.content = [];
        }
        const existingCell = rowToChange.content[cellIndex];
        if (existingCell?.attrs?.continueMerge) continue;
        const mergedCell = {
          type: cell.type,
          content: [editorSchema.nodes.paragraph.createAndFill().toJSON()],
          attrs: {
            ...cell.attrs,
            rowspan: null,
            continueMerge: true,
          },
        };
        rowToChange.content.splice(cellIndex, 0, mergedCell);
      }
    }
  }
  return table;
}
const translator$q = NodeTranslator.from({
  xmlName: 'w:bidiVisual',
  sdNodeOrKeyName: 'rightToLeft',
  encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.['w:val'] ?? '1'),
  decode: ({ node }) => (node.attrs.rightToLeft ? { attributes: {} } : void 0),
});
const translator$p = NodeTranslator.from(createSingleAttrPropertyHandler('w:tblCaption', 'caption'));
const translator$o = NodeTranslator.from(createSingleAttrPropertyHandler('w:tblDescription', 'description'));
const translator$n = NodeTranslator.from(createMeasurementPropertyHandler('w:tblInd', 'tableIndent'));
const translator$m = NodeTranslator.from(createSingleAttrPropertyHandler('w:tblLayout', 'tableLayout', 'w:type'));
const translator$l = NodeTranslator.from({
  xmlName: 'w:tblLook',
  sdNodeOrKeyName: 'tblLook',
  attributes: ['w:firstColumn', 'w:firstRow', 'w:lastColumn', 'w:lastRow', 'w:noHBand', 'w:noVBand']
    .map((attr) => createAttributeHandler(attr, null, parseBoolean, booleanToString))
    .concat([createAttributeHandler('w:val')]),
  encode: (params, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function ({ node }, context) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.tblLook || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  },
});
const translator$k = NodeTranslator.from(createSingleAttrPropertyHandler('w:tblOverlap', 'overlap'));
const translator$j = NodeTranslator.from(createSingleAttrPropertyHandler('w:tblStyle', 'tableStyleId'));
const translator$i = NodeTranslator.from(
  createSingleAttrPropertyHandler('w:tblStyleColBandSize', 'tableStyleColBandSize'),
);
const translator$h = NodeTranslator.from(
  createSingleAttrPropertyHandler('w:tblStyleRowBandSize', 'tableStyleRowBandSize'),
);
const translator$g = NodeTranslator.from(createMeasurementPropertyHandler('w:tblW', 'tableWidth'));
const translator$f = NodeTranslator.from({
  xmlName: 'w:tblpPr',
  sdNodeOrKeyName: 'floatingTableProperties',
  attributes: ['w:leftFromText', 'w:rightFromText', 'w:topFromText', 'w:bottomFromText', 'w:tblpX', 'w:tblpY']
    .map((attr) => createAttributeHandler(attr, null, parseInteger, integerToString))
    .concat(['w:horzAnchor', 'w:vertAnchor', 'w:tblpXSpec', 'w:tblpYSpec'].map((attr) => createAttributeHandler(attr))),
  encode: (params, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function ({ node }, context) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.floatingTableProperties || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  },
});
const propertyTranslators$2 = [
  translator$16,
  translator$14,
  translator$12,
  translator$11,
  translator$10,
  translator$_,
  translator$Y,
  translator$W,
];
const translator$e = NodeTranslator.from(
  createNestedPropertiesTranslator('w:tblBorders', 'borders', propertyTranslators$2),
);
const propertyTranslators$1 = [translator$15, translator$13, translator$$, translator$Z, translator$X, translator$V];
const translator$d = NodeTranslator.from(
  createNestedPropertiesTranslator('w:tblCellMar', 'cellMargins', propertyTranslators$1),
);
const propertyTranslators = [
  translator$q,
  translator$C,
  translator$1a,
  translator$p,
  translator$B,
  translator$o,
  translator$n,
  translator$m,
  translator$l,
  translator$k,
  translator$j,
  translator$i,
  translator$h,
  translator$g,
  translator$f,
  translator$e,
  translator$d,
];
const translator$c = NodeTranslator.from(
  createNestedPropertiesTranslator('w:tblPr', 'tableProperties', propertyTranslators),
);
const translator$b = NodeTranslator.from(
  createSingleAttrPropertyHandler('w:gridCol', 'col', 'w:w', parseInteger, integerToString),
);
const DEFAULT_COLUMN_WIDTH_PX = 100;
const normalizeTwipWidth = (value) => {
  if (value == null) return null;
  const numericValue = typeof value === 'string' ? parseInt(value, 10) : value;
  if (!Number.isFinite(numericValue) || Number.isNaN(numericValue) || numericValue <= 0) {
    return null;
  }
  return numericValue;
};
const getSchemaDefaultColumnWidthPx = (params) => {
  const defaultValue = params?.editor?.schema?.nodes?.tableCell?.spec?.attrs?.colwidth?.default;
  if (Array.isArray(defaultValue)) {
    const numericWidth = defaultValue.find((width) => typeof width === 'number' && Number.isFinite(width) && width > 0);
    if (numericWidth != null) return numericWidth;
  } else if (typeof defaultValue === 'number' && Number.isFinite(defaultValue) && defaultValue > 0) {
    return defaultValue;
  }
  return DEFAULT_COLUMN_WIDTH_PX;
};
const getTableWidthPx = (params) => {
  const explicitWidth = params?.node?.attrs?.tableWidth?.width;
  if (typeof explicitWidth === 'number' && explicitWidth > 0) return explicitWidth;
  const tableWidth = params?.node?.attrs?.tableProperties?.tableWidth;
  if (tableWidth?.value != null && typeof tableWidth.value === 'number' && tableWidth.value > 0) {
    const { value, type } = tableWidth;
    if (!type || type === 'auto' || type === 'dxa') {
      return twipsToPixels(value);
    }
  }
  return null;
};
const resolveFallbackColumnWidthTwips = (params, totalColumns, cellMinWidthTwips) => {
  const columnCount = Math.max(totalColumns, 1);
  const defaultColumnWidthPx = getSchemaDefaultColumnWidthPx(params);
  const tableWidthPx = getTableWidthPx(params);
  const safeDefaultPx =
    Number.isFinite(defaultColumnWidthPx) && defaultColumnWidthPx > 0 ? defaultColumnWidthPx : DEFAULT_COLUMN_WIDTH_PX;
  let fallbackWidthPx = safeDefaultPx;
  if (typeof tableWidthPx === 'number' && tableWidthPx > 0) {
    fallbackWidthPx = tableWidthPx / columnCount;
  }
  const fallbackWidthTwips = pixelsToTwips(fallbackWidthPx);
  if (!Number.isFinite(fallbackWidthTwips) || Number.isNaN(fallbackWidthTwips) || fallbackWidthTwips <= 0) {
    const safeDefault = Math.max(pixelsToTwips(safeDefaultPx), cellMinWidthTwips);
    return safeDefault;
  }
  return Math.max(fallbackWidthTwips, cellMinWidthTwips);
};
const XML_NODE_NAME$b = 'w:tblGrid';
const SD_ATTR_KEY$2 = 'grid';
const cellMinWidth = pixelsToTwips(10);
const encode$h = (params) => {
  const { nodes } = params;
  const node = nodes[0];
  const attributes = encodeProperties(node, { [translator$b.xmlName]: translator$b }, true);
  return {
    xmlName: XML_NODE_NAME$b,
    sdNodeOrKeyName: SD_ATTR_KEY$2,
    attributes,
  };
};
const decode$j = (params) => {
  const { grid: rawGrid } = params.node.attrs || {};
  const grid = Array.isArray(rawGrid) ? rawGrid : [];
  const { firstRow = {} } = params.extraParams || {};
  const cellNodes = firstRow.content?.filter((n) => n.type === 'tableCell') ?? [];
  const columnCountFromCells = cellNodes.reduce((count, cell) => {
    const spanCount = Math.max(1, cell?.attrs?.colspan ?? 1);
    return count + spanCount;
  }, 0);
  const totalColumns = Math.max(columnCountFromCells, grid.length);
  const fallbackColumnWidthTwips = resolveFallbackColumnWidthTwips(params, totalColumns, cellMinWidth);
  const elements = [];
  let columnIndex = 0;
  const pushColumn = (widthTwips, { enforceMinimum = false } = {}) => {
    let numericWidth = typeof widthTwips === 'string' ? parseInt(widthTwips, 10) : widthTwips;
    let shouldEnforceMinimum = enforceMinimum;
    if (numericWidth == null || Number.isNaN(numericWidth) || numericWidth <= 0) {
      numericWidth = fallbackColumnWidthTwips;
      shouldEnforceMinimum = true;
    }
    const roundedWidth = Math.round(numericWidth);
    const minimumWidth = shouldEnforceMinimum ? cellMinWidth : 1;
    const safeWidth = Math.max(roundedWidth, minimumWidth);
    const decoded = translator$b.decode({
      node: {
        type:
          /** @type {string} */
          translator$b.sdNodeOrKeyName,
        attrs: { col: safeWidth },
      },
    });
    if (decoded) elements.push(decoded);
  };
  cellNodes.forEach((cell) => {
    const { colspan = 1, colwidth } = cell?.attrs || {};
    const spanCount = Math.max(1, colspan);
    for (let span = 0; span < spanCount; span++) {
      const rawWidth = Array.isArray(colwidth) ? colwidth[span] : void 0;
      const cellWidthPixels = typeof rawWidth === 'number' && Number.isFinite(rawWidth) ? rawWidth : Number(rawWidth);
      const hasCellWidth = Number.isFinite(cellWidthPixels) && cellWidthPixels > 0;
      const colGridAttrs = grid?.[columnIndex] || {};
      const gridWidthTwips = normalizeTwipWidth(colGridAttrs.col);
      const gridWidthPixels = gridWidthTwips != null ? twipsToPixels(gridWidthTwips) : null;
      let cellWidthTwips;
      let enforceMinimum = false;
      if (hasCellWidth) {
        const tolerance = 0.5;
        if (
          gridWidthTwips != null &&
          gridWidthPixels != null &&
          Math.abs(gridWidthPixels - cellWidthPixels) <= tolerance
        ) {
          cellWidthTwips = gridWidthTwips;
        } else {
          cellWidthTwips = pixelsToTwips(cellWidthPixels);
        }
      } else if (gridWidthTwips != null) {
        cellWidthTwips = gridWidthTwips;
      } else {
        cellWidthTwips = fallbackColumnWidthTwips;
        enforceMinimum = true;
      }
      pushColumn(cellWidthTwips, { enforceMinimum });
      columnIndex++;
    }
  });
  while (columnIndex < grid.length) {
    const gridWidthTwips = normalizeTwipWidth(grid[columnIndex]?.col);
    pushColumn(gridWidthTwips);
    columnIndex++;
  }
  const newNode = {
    name: XML_NODE_NAME$b,
    attributes: {},
    elements,
  };
  return newNode;
};
const config$a = {
  xmlName: XML_NODE_NAME$b,
  sdNodeOrKeyName: SD_ATTR_KEY$2,
  encode: encode$h,
  decode: decode$j,
};
const translator$a = NodeTranslator.from(config$a);
const DEFAULT_PAGE_WIDTH_TWIPS = 12240;
const DEFAULT_PAGE_MARGIN_TWIPS = 1440;
const DEFAULT_CONTENT_WIDTH_TWIPS = DEFAULT_PAGE_WIDTH_TWIPS - 2 * DEFAULT_PAGE_MARGIN_TWIPS;
const MIN_COLUMN_WIDTH_TWIPS = pixelsToTwips(10);
const pctToPercent = (value) => {
  if (value == null) return null;
  return value / 50;
};
const resolveContentWidthTwips = () => DEFAULT_CONTENT_WIDTH_TWIPS;
const resolveMeasurementWidthPx = (measurement) => {
  if (!measurement || typeof measurement.value !== 'number' || measurement.value <= 0) return null;
  const { value, type } = measurement;
  if (!type || type === 'auto') return null;
  if (type === 'dxa') return twipsToPixels(value);
  if (type === 'pct') {
    const percent = pctToPercent(value);
    if (percent == null || percent <= 0) return null;
    const widthTwips = (resolveContentWidthTwips() * percent) / 100;
    return twipsToPixels(widthTwips);
  }
  return null;
};
const countColumnsInRow = (row) => {
  if (!row?.elements?.length) return 0;
  return row.elements.reduce((count, element) => {
    if (element.name !== 'w:tc') return count;
    const tcPr = element.elements?.find((el) => el.name === 'w:tcPr');
    const gridSpan = tcPr?.elements?.find((el) => el.name === 'w:gridSpan');
    const spanValue = parseInt(gridSpan?.attributes?.['w:val'] || '1', 10);
    return count + (Number.isFinite(spanValue) && spanValue > 0 ? spanValue : 1);
  }, 0);
};
const clampColumnWidthTwips = (value) => Math.max(Math.round(value), MIN_COLUMN_WIDTH_TWIPS);
const createFallbackGrid = (columnCount, columnWidthTwips) =>
  Array.from({ length: columnCount }, () => ({ col: clampColumnWidthTwips(columnWidthTwips) }));
const buildFallbackGridForTable = ({ params, rows, tableWidth, tableWidthMeasurement }) => {
  const firstRow = rows.find((row) => row.elements?.some((el) => el.name === 'w:tc'));
  const columnCount = countColumnsInRow(firstRow);
  if (!columnCount) return null;
  const schemaDefaultPx = getSchemaDefaultColumnWidthPx(
    /** @type {any} */
    params,
  );
  const minimumColumnWidthPx =
    Number.isFinite(schemaDefaultPx) && schemaDefaultPx > 0 ? schemaDefaultPx : DEFAULT_COLUMN_WIDTH_PX;
  let totalWidthPx;
  if (tableWidthMeasurement) {
    const resolved = resolveMeasurementWidthPx(tableWidthMeasurement);
    if (resolved != null) totalWidthPx = resolved;
  }
  if (totalWidthPx == null && tableWidth?.width && tableWidth.width > 0) {
    totalWidthPx = tableWidth.width;
  }
  if (totalWidthPx == null) {
    totalWidthPx = minimumColumnWidthPx * columnCount;
  }
  const rawColumnWidthPx = Math.max(totalWidthPx / columnCount, minimumColumnWidthPx);
  const columnWidthTwips = clampColumnWidthTwips(pixelsToTwips(rawColumnWidthPx));
  const fallbackColumnWidthPx = twipsToPixels(columnWidthTwips);
  return {
    grid: createFallbackGrid(columnCount, columnWidthTwips),
    columnWidths: Array(columnCount).fill(fallbackColumnWidthPx),
  };
};
const XML_NODE_NAME$a = 'w:tbl';
const SD_NODE_NAME$8 = 'table';
const encode$g = (params, encodedAttrs) => {
  const { nodes } = params;
  const node = nodes[0];
  const tblPr = node.elements.find((el) => el.name === 'w:tblPr');
  if (tblPr) {
    const encodedProperties = translator$c.encode({ ...params, nodes: [tblPr] });
    encodedAttrs['tableProperties'] = encodedProperties || {};
  }
  const tblGrid = node.elements.find((el) => el.name === 'w:tblGrid');
  if (tblGrid) {
    encodedAttrs['grid'] = translator$a.encode({ ...params, nodes: [tblGrid] }).attributes;
  }
  [
    'tableStyleId',
    'justification',
    'tableLayout',
    ['tableIndent', ({ value, type }) => ({ width: twipsToPixels(value), type })],
    ['tableCellSpacing', ({ value, type }) => ({ w: String(value), type })],
  ].forEach((prop) => {
    let key2;
    let transform;
    if (Array.isArray(prop)) {
      [key2, transform] = prop;
    } else {
      key2 = prop;
      transform = (v) => v;
    }
    if (encodedAttrs.tableProperties && encodedAttrs.tableProperties[key2]) {
      encodedAttrs[key2] = transform(encodedAttrs.tableProperties[key2]);
    }
  });
  if (encodedAttrs.tableCellSpacing) {
    encodedAttrs['borderCollapse'] = 'separate';
  }
  if (encodedAttrs.tableProperties?.tableWidth) {
    const tableWidthMeasurement = encodedAttrs.tableProperties.tableWidth;
    const widthPx = twipsToPixels(tableWidthMeasurement.value);
    if (widthPx != null) {
      encodedAttrs.tableWidth = {
        width: widthPx,
        type: tableWidthMeasurement.type,
      };
    } else if (tableWidthMeasurement.type === 'auto') {
      encodedAttrs.tableWidth = {
        width: 0,
        type: tableWidthMeasurement.type,
      };
    }
  }
  const { borders, rowBorders } = _processTableBorders(encodedAttrs.tableProperties?.borders || {});
  const referencedStyles = _getReferencedTableStyles(encodedAttrs.tableStyleId, params);
  if (referencedStyles?.cellMargins && !encodedAttrs.tableProperties?.cellMargins) {
    encodedAttrs.tableProperties = {
      ...(encodedAttrs.tableProperties || {}),
      cellMargins: referencedStyles.cellMargins,
    };
  }
  const rows = node.elements.filter((el) => el.name === 'w:tr');
  const borderData = Object.assign({}, referencedStyles?.borders || {}, borders || {});
  const borderRowData = Object.assign({}, referencedStyles?.rowBorders || {}, rowBorders || {});
  encodedAttrs['borders'] = borderData;
  let columnWidths = Array.isArray(encodedAttrs['grid'])
    ? encodedAttrs['grid'].map((item) => twipsToPixels(item.col))
    : [];
  if (!columnWidths.length) {
    const fallback = buildFallbackGridForTable({
      params,
      rows,
      tableWidth: encodedAttrs.tableWidth,
      tableWidthMeasurement: encodedAttrs.tableProperties?.tableWidth,
    });
    if (fallback) {
      encodedAttrs.grid = fallback.grid;
      columnWidths = fallback.columnWidths;
    }
  }
  const content = [];
  const totalColumns = columnWidths.length;
  const activeRowSpans = totalColumns > 0 ? new Array(totalColumns).fill(0) : [];
  rows.forEach((row, rowIndex) => {
    const result = translator$v.encode({
      ...params,
      nodes: [row],
      extraParams: {
        row,
        table: node,
        rowBorders: borderRowData,
        columnWidths,
        activeRowSpans: activeRowSpans.slice(),
        rowIndex,
        _referencedStyles: referencedStyles,
      },
    });
    if (result) {
      content.push(result);
      if (totalColumns > 0) {
        const activeRowSpansForCurrentRow = activeRowSpans.slice();
        for (let col = 0; col < totalColumns; col++) {
          if (activeRowSpans[col] > 0) {
            activeRowSpans[col] -= 1;
          }
        }
        let columnIndex = 0;
        const advanceColumnIndex = () => {
          while (columnIndex < totalColumns && activeRowSpansForCurrentRow[columnIndex] > 0) {
            columnIndex += 1;
          }
        };
        advanceColumnIndex();
        result.content?.forEach((cell) => {
          advanceColumnIndex();
          const colspan = Math.max(1, cell.attrs?.colspan || 1);
          const rowspan = Math.max(1, cell.attrs?.rowspan || 1);
          if (rowspan > 1) {
            for (let offset = 0; offset < colspan && columnIndex + offset < totalColumns; offset++) {
              const targetIndex = columnIndex + offset;
              const remainingRows = rowspan - 1;
              if (remainingRows > 0 && remainingRows > activeRowSpans[targetIndex]) {
                activeRowSpans[targetIndex] = remainingRows;
              }
            }
          }
          columnIndex += colspan;
          advanceColumnIndex();
        });
      }
    }
  });
  return {
    type: 'table',
    content,
    attrs: encodedAttrs,
  };
};
const decode$i = (params, decodedAttrs) => {
  params.node = preProcessVerticalMergeCells(params.node, params);
  const { node } = params;
  const elements = translateChildNodes(params);
  const firstRow = node.content?.find((n) => n.type === 'tableRow');
  const properties = node.attrs.grid;
  const element = translator$a.decode({
    ...params,
    node: { ...node, attrs: { ...node.attrs, grid: properties } },
    extraParams: {
      firstRow,
    },
  });
  if (element) elements.unshift(element);
  if (node.attrs?.tableProperties) {
    const properties2 = { ...node.attrs.tableProperties };
    const element2 = translator$c.decode({
      ...params,
      node: { ...node, attrs: { ...node.attrs, tableProperties: properties2 } },
    });
    if (element2) elements.unshift(element2);
  }
  return {
    name: 'w:tbl',
    attributes: decodedAttrs || {},
    elements,
  };
};
function _processTableBorders(rawBorders) {
  const borders = {};
  const rowBorders = {};
  Object.entries(rawBorders).forEach(([name, attributes]) => {
    const attrs = {};
    const color = attributes.color;
    const size = attributes.size;
    if (color && color !== 'auto') attrs['color'] = color.startsWith('#') ? color : `#${color}`;
    if (size && size !== 'auto') attrs['size'] = eighthPointsToPixels(size);
    const rowBorderNames = ['insideH', 'insideV'];
    if (rowBorderNames.includes(name)) rowBorders[name] = attrs;
    borders[name] = attrs;
  });
  return {
    borders,
    rowBorders,
  };
}
function _getReferencedTableStyles(tableStyleReference, params) {
  if (!tableStyleReference) return null;
  const stylesToReturn = {};
  const { docx } = params;
  const styles = docx['word/styles.xml'];
  const { elements } = styles.elements[0];
  const styleElements = elements.filter((el) => el.name === 'w:style');
  const styleTag = styleElements.find((el) => el.attributes['w:styleId'] === tableStyleReference);
  if (!styleTag) return null;
  stylesToReturn.name = styleTag.elements.find((el) => el.name === 'w:name');
  const basedOn = styleTag.elements.find((el) => el.name === 'w:basedOn');
  let baseTblPr;
  if (basedOn?.attributes) {
    const baseStyles = styleElements.find((el) => el.attributes['w:styleId'] === basedOn.attributes['w:val']);
    baseTblPr = baseStyles ? baseStyles.elements.find((el) => el.name === 'w:tblPr') : {};
  }
  const pPr = styleTag.elements.find((el) => el.name === 'w:pPr');
  if (pPr) {
    const justification = pPr.elements.find((el) => el.name === 'w:jc');
    if (justification?.attributes) stylesToReturn.justification = justification.attributes['w:val'];
  }
  const rPr = styleTag?.elements.find((el) => el.name === 'w:rPr');
  if (rPr) {
    const fonts = rPr.elements.find((el) => el.name === 'w:rFonts');
    if (fonts) {
      const { 'w:ascii': ascii, 'w:hAnsi': hAnsi, 'w:cs': cs } = fonts.attributes;
      stylesToReturn.fonts = { ascii, hAnsi, cs };
    }
    const fontSize = rPr.elements.find((el) => el.name === 'w:sz');
    if (fontSize?.attributes) stylesToReturn.fontSize = halfPointToPoints(fontSize.attributes['w:val']) + 'pt';
  }
  const tblPr = styleTag.elements.find((el) => el.name === 'w:tblPr');
  if (tblPr && tblPr.elements) {
    if (baseTblPr && baseTblPr.elements) {
      tblPr.elements.push(...baseTblPr.elements);
    }
    const tableProperties = translator$c.encode({ ...params, nodes: [tblPr] });
    if (tableProperties) {
      const { borders, rowBorders } = _processTableBorders(tableProperties.borders || {});
      if (borders) stylesToReturn.borders = borders;
      if (rowBorders) stylesToReturn.rowBorders = rowBorders;
      const cellMargins = {};
      Object.entries(tableProperties.cellMargins || {}).forEach(([key2, attrs]) => {
        if (attrs?.value != null) {
          cellMargins[key2] = {
            value: attrs.value,
            type: attrs.type || 'dxa',
          };
        }
      });
      if (Object.keys(cellMargins).length) stylesToReturn.cellMargins = cellMargins;
    }
  }
  return stylesToReturn;
}
const config$9 = {
  xmlName: XML_NODE_NAME$a,
  sdNodeOrKeyName: SD_NODE_NAME$8,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$g,
  decode: decode$i,
  attributes: [],
};
const translator$9 = NodeTranslator.from(config$9);
const encode$f = (attributes) => {
  return attributes['w:id'];
};
const decode$h = (attrs) => {
  return attrs.id;
};
const attrConfig$7 = Object.freeze({
  xmlName: 'w:id',
  sdName: 'id',
  encode: encode$f,
  decode: decode$h,
});
const encode$e = (attributes) => {
  return attributes['w:name'];
};
const decode$g = (attrs) => {
  return attrs.name;
};
const attrConfig$6 = Object.freeze({
  xmlName: 'w:name',
  sdName: 'name',
  encode: encode$e,
  decode: decode$g,
});
const encode$d = (attributes) => {
  return attributes['w:colFirst'];
};
const decode$f = (attrs) => {
  return attrs.colFirst;
};
const attrConfig$5 = Object.freeze({
  xmlName: 'w:colFirst',
  sdName: 'colFirst',
  encode: encode$d,
  decode: decode$f,
});
const encode$c = (attributes) => {
  return attributes['w:colLast'];
};
const decode$e = (attrs) => {
  return attrs.colLast;
};
const attrConfig$4 = Object.freeze({
  xmlName: 'w:colLast',
  sdName: 'colLast',
  encode: encode$c,
  decode: decode$e,
});
const encode$b = (attributes) => {
  return attributes['w:displacedByCustomXml'];
};
const decode$d = (attrs) => {
  return attrs.displacedByCustomXml;
};
const attrConfig$3 = Object.freeze({
  xmlName: 'w:displacedByCustomXml',
  sdName: 'displacedByCustomXml',
  encode: encode$b,
  decode: decode$d,
});
const validXmlAttributes$6 = [attrConfig$7, attrConfig$6, attrConfig$5, attrConfig$4, attrConfig$3];
const XML_NODE_NAME$9 = 'w:bookmarkStart';
const SD_NODE_NAME$7 = 'bookmarkStart';
const encode$a = (params, encodedAttrs = {}) => {
  return {
    type: 'bookmarkStart',
    attrs: encodedAttrs,
  };
};
const decode$c = (params, decodedAttrs = {}) => {
  const result = {
    name: 'w:bookmarkStart',
    elements: [],
  };
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    result.attributes = decodedAttrs;
  }
  return result;
};
const config$8 = {
  xmlName: XML_NODE_NAME$9,
  sdNodeOrKeyName: SD_NODE_NAME$7,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$a,
  decode: decode$c,
  attributes: validXmlAttributes$6,
};
const translator$8 = NodeTranslator.from(config$8);
const encode$9 = (attributes) => {
  return attributes['w:id'];
};
const decode$b = (attrs) => {
  return attrs.id;
};
const attrConfig$2 = Object.freeze({
  xmlName: 'w:id',
  sdName: 'id',
  encode: encode$9,
  decode: decode$b,
});
const encode$8 = (attributes) => {
  return attributes['w:displacedByCustomXml'];
};
const decode$a = (attrs) => {
  return attrs.displacedByCustomXml;
};
const attrConfig$1 = Object.freeze({
  xmlName: 'w:displacedByCustomXml',
  sdName: 'displacedByCustomXml',
  encode: encode$8,
  decode: decode$a,
});
const validXmlAttributes$5 = [attrConfig$2, attrConfig$1];
const XML_NODE_NAME$8 = 'w:bookmarkEnd';
const SD_NODE_NAME$6 = 'bookmarkEnd';
const encode$7 = (params, encodedAttrs = {}) => {
  return {
    type: 'bookmarkEnd',
    attrs: encodedAttrs,
  };
};
const decode$9 = (params, decodedAttrs = {}) => {
  const result = {
    name: 'w:bookmarkEnd',
    elements: [],
  };
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    result.attributes = decodedAttrs;
  }
  return result;
};
const config$7 = {
  xmlName: XML_NODE_NAME$8,
  sdNodeOrKeyName: SD_NODE_NAME$6,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$7,
  decode: decode$9,
  attributes: validXmlAttributes$5,
};
const translator$7 = NodeTranslator.from(config$7);
const decode$8 = (attrs) => attrs?.['w:id'];
const attrConfig = Object.freeze({
  xmlName: 'w:id',
  sdName: 'w:id',
  // We do not translate it from 'w:id' to 'id' when encoding, so the name is the same
  encode: () => {},
  decode: decode$8,
});
const XML_NODE_NAME$7 = 'w:commentRange';
const SD_NODE_NAME$5 = 'commentRange';
const decode$7 = (params) => {
  const { node, comments, commentsExportType, exportedCommentDefs } = params;
  if (!node) return;
  if (!comments) return;
  if (exportedCommentDefs?.length === 0) return;
  if (commentsExportType === 'clean') return;
  const commentNodeId = node.attrs['w:id'];
  const originalComment = comments.find((comment) => {
    return comment.commentId == commentNodeId;
  });
  if (!originalComment) return;
  const parentCommentId = originalComment.parentCommentId;
  const parentComment = comments.find(
    ({ commentId, importedId }) => commentId === parentCommentId || importedId === parentCommentId,
  );
  const isInternal = parentComment?.isInternal || originalComment.isInternal;
  if (commentsExportType === 'external' && isInternal) return;
  const isResolved = !!originalComment.resolvedTime;
  if (isResolved) return;
  if (node.type !== 'commentRangeStart' && node.type !== 'commentRangeEnd') {
    return;
  }
  const { type } = node;
  const commentIndex = comments.findIndex((comment) => comment.commentId === originalComment.commentId);
  let commentSchema = getCommentSchema(type, commentIndex);
  if (type === 'commentRangeEnd') {
    const commentReference = {
      name: 'w:r',
      elements: [{ name: 'w:commentReference', attributes: { 'w:id': String(commentIndex) } }],
    };
    commentSchema = [commentSchema, commentReference];
  }
  return commentSchema;
};
const getCommentSchema = (type, commentIndex) => {
  return {
    name: `w:${type}`,
    attributes: {
      'w:id': String(commentIndex),
    },
  };
};
const getConfig = (type) => ({
  xmlName: `${XML_NODE_NAME$7}${type}`,
  sdNodeOrKeyName: `${SD_NODE_NAME$5}${type}`,
  type: NodeTranslator.translatorTypes.NODE,
  encode: () => {},
  decode: decode$7,
  attributes: [attrConfig],
});
const commentRangeStartTranslator = NodeTranslator.from(getConfig('Start'));
const commentRangeEndTranslator = NodeTranslator.from(getConfig('End'));
const XML_NODE_NAME$6 = 'sd:pageReference';
const SD_NODE_NAME$4 = 'pageReference';
const encode$6 = (params) => {
  const { nodes = [], nodeListHandler } = params || {};
  const node = nodes[0];
  const processedText = nodeListHandler.handler({
    ...params,
    nodes: node.elements,
  });
  const processedNode = {
    type: 'pageReference',
    attrs: {
      instruction: node.attributes?.instruction || '',
      marksAsAttrs: node.marks || [],
    },
    content: processedText,
  };
  return processedNode;
};
const decode$6 = (params) => {
  const { node } = params;
  const outputMarks = processOutputMarks(node.attrs?.marksAsAttrs || []);
  const contentNodes = (node.content ?? []).flatMap((n) => exportSchemaToJson({ ...params, node: n }));
  const translated = [
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:fldChar',
          attributes: {
            'w:fldCharType': 'begin',
          },
        },
      ],
    },
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:instrText',
          attributes: { 'xml:space': 'preserve' },
          elements: [
            {
              type: 'text',
              text: `${node.attrs.instruction}`,
            },
          ],
        },
      ],
    },
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:fldChar',
          attributes: {
            'w:fldCharType': 'separate',
          },
        },
      ],
    },
    ...contentNodes,
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:fldChar',
          attributes: {
            'w:fldCharType': 'end',
          },
        },
      ],
    },
  ];
  return translated;
};
const config$6 = {
  xmlName: XML_NODE_NAME$6,
  sdNodeOrKeyName: SD_NODE_NAME$4,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$6,
  decode: decode$6,
};
const translator$6 = NodeTranslator.from(config$6);
const XML_NODE_NAME$5 = 'sd:tableOfContents';
const SD_NODE_NAME$3 = 'tableOfContents';
const encode$5 = (params) => {
  const { nodes = [], nodeListHandler } = params || {};
  const node = nodes[0];
  const processedContent = nodeListHandler.handler({
    ...params,
    nodes: node.elements || [],
  });
  const processedNode = {
    type: 'tableOfContents',
    attrs: {
      instruction: node.attributes?.instruction || '',
    },
    content: processedContent,
  };
  return processedNode;
};
const decode$5 = (params) => {
  const { node } = params;
  const contentNodes = node.content.map((n) => exportSchemaToJson({ ...params, node: n }));
  const tocBeginElements = [
    {
      name: 'w:r',
      elements: [{ name: 'w:fldChar', attributes: { 'w:fldCharType': 'begin' }, elements: [] }],
    },
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:instrText',
          attributes: { 'xml:space': 'preserve' },
          elements: [{ text: node.attrs?.instruction || '', type: 'text', name: '#text', elements: [] }],
        },
      ],
    },
    { name: 'w:r', elements: [{ name: 'w:fldChar', attributes: { 'w:fldCharType': 'separate' }, elements: [] }] },
  ];
  if (contentNodes.length > 0) {
    const firstParagraph = contentNodes[0];
    let insertIndex = 0;
    if (firstParagraph.elements) {
      const pPrIndex = firstParagraph.elements.findIndex((el) => el.name === 'w:pPr');
      insertIndex = pPrIndex >= 0 ? pPrIndex + 1 : 0;
    } else {
      firstParagraph.elements = [];
    }
    firstParagraph.elements.splice(insertIndex, 0, ...tocBeginElements);
  } else {
    contentNodes.push({
      name: 'w:p',
      elements: tocBeginElements,
    });
  }
  const tocEndElements = [
    { name: 'w:r', elements: [{ name: 'w:fldChar', attributes: { 'w:fldCharType': 'end' }, elements: [] }] },
  ];
  const lastParagraph = contentNodes[contentNodes.length - 1];
  if (lastParagraph.elements) {
    lastParagraph.elements.push(...tocEndElements);
  } else {
    lastParagraph.elements = [...tocEndElements];
  }
  return contentNodes;
};
const config$5 = {
  xmlName: XML_NODE_NAME$5,
  sdNodeOrKeyName: SD_NODE_NAME$3,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$5,
  decode: decode$5,
};
const translator$5 = NodeTranslator.from(config$5);
function parseInlineStyles(styleString) {
  if (!styleString) return {};
  return styleString
    .split(';')
    .filter((style) => !!style.trim())
    .reduce((acc, style) => {
      const [prop, value] = style.split(':').map((str) => str.trim());
      if (prop && value) acc[prop] = value;
      return acc;
    }, {});
}
function handleVRectImport({ pNode, pict }) {
  const rect = pict.elements?.find((el) => el.name === 'v:rect');
  const schemaAttrs = {};
  const rectAttrs = rect.attributes || {};
  schemaAttrs.attributes = rectAttrs;
  if (rectAttrs.style) {
    const parsedStyle = parseInlineStyles(rectAttrs.style);
    const rectStyle = buildVRectStyles(parsedStyle);
    if (rectStyle) {
      schemaAttrs.style = rectStyle;
    }
    const size = {};
    const isFullWidthHR = rectAttrs['o:hr'] === 't' || rectAttrs['o:hrstd'] === 't';
    if (parsedStyle.width !== void 0) {
      if (isFullWidthHR) {
        size.width = '100%';
      } else {
        const inlineWidth = parsePointsToPixels(parsedStyle.width);
        size.width = inlineWidth;
      }
    }
    if (parsedStyle.height !== void 0) {
      size.height = parsePointsToPixels(parsedStyle.height);
    }
    if (Object.keys(size).length > 0) {
      schemaAttrs.size = size;
    }
  }
  if (rectAttrs.fillcolor) {
    schemaAttrs.background = rectAttrs.fillcolor;
  }
  const vmlAttrs = {};
  if (rectAttrs['o:hralign']) vmlAttrs.hralign = rectAttrs['o:hralign'];
  if (rectAttrs['o:hrstd']) vmlAttrs.hrstd = rectAttrs['o:hrstd'];
  if (rectAttrs['o:hr']) vmlAttrs.hr = rectAttrs['o:hr'];
  if (rectAttrs.stroked) vmlAttrs.stroked = rectAttrs.stroked;
  if (Object.keys(vmlAttrs).length > 0) {
    schemaAttrs.vmlAttributes = vmlAttrs;
  }
  const isHorizontalRule = rectAttrs['o:hr'] === 't' || rectAttrs['o:hrstd'] === 't';
  if (isHorizontalRule) {
    schemaAttrs.horizontalRule = true;
  }
  const pPr = pNode.elements?.find((el) => el.name === 'w:pPr');
  const spacingElement = pPr?.elements?.find((el) => el.name === 'w:spacing');
  const spacingAttrs = spacingElement?.attributes || {};
  const inLineIndentTag = pPr?.elements?.find((el) => el.name === 'w:ind');
  const inLineIndent = inLineIndentTag?.attributes || {};
  const spacing = {};
  if (spacingAttrs['w:after']) spacing.lineSpaceAfter = twipsToPixels(spacingAttrs['w:after']);
  if (spacingAttrs['w:before']) spacing.lineSpaceBefore = twipsToPixels(spacingAttrs['w:before']);
  if (spacingAttrs['w:line']) spacing.line = twipsToLines(spacingAttrs['w:line']);
  if (spacingAttrs['w:lineRule']) spacing.lineRule = spacingAttrs['w:lineRule'];
  const indent = {
    left: 0,
    right: 0,
    firstLine: 0,
    hanging: 0,
  };
  const leftIndent = inLineIndent?.['w:left'];
  const rightIndent = inLineIndent?.['w:right'];
  if (leftIndent) {
    indent.left = twipsToPixels(leftIndent);
  }
  if (rightIndent) {
    indent.right = twipsToPixels(rightIndent);
  }
  return {
    type: 'paragraph',
    content: [
      {
        type: 'contentBlock',
        attrs: schemaAttrs,
      },
    ],
    attrs: {
      spacing: Object.keys(spacing).length > 0 ? spacing : void 0,
      rsidRDefault: pNode.attributes?.['w:rsidRDefault'],
      indent,
    },
  };
}
function parsePointsToPixels(value) {
  if (typeof value !== 'string') return value;
  if (value.endsWith('pt')) {
    const val = value.replace('pt', '');
    if (isNaN(Number(val))) {
      return 0;
    }
    const points = parseFloat(val);
    return Math.ceil(points * 1.33);
  }
  if (value.endsWith('px')) {
    const val = value.replace('px', '');
    if (isNaN(Number(val))) {
      return 0;
    }
    return parseInt(val);
  }
  const numValue = parseFloat(value);
  return isNaN(numValue) ? 0 : numValue;
}
function buildVRectStyles(styleObject) {
  let style = '';
  for (const [prop, value] of Object.entries(styleObject)) {
    style += `${prop}: ${value};`;
  }
  return style;
}
const defaultInitialXml = `<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex" xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex" xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex" xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex" xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex" xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex" xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink" xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:oel="http://schemas.microsoft.com/office/2019/extlst" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh wp14"><w:body></w:body></w:document>`;
const parseXmlToJson = (xml) => {
  return JSON.parse(xmljs.xml2json(xml, null, 2));
};
const getInitialJSON = (parsedDocx, fallbackXml = defaultInitialXml) => {
  return parsedDocx['word/document.xml'] || parseXmlToJson(fallbackXml);
};
const handleDrawingNode = (params) => {
  const { nodes } = params;
  const validNodes = ['w:drawing', 'w:p'];
  if (nodes.length === 0 || !validNodes.includes(nodes[0].name)) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = nodes[0];
  let node;
  if (mainNode.name === 'w:drawing') node = mainNode;
  else node = mainNode.elements.find((el) => el.name === 'w:drawing');
  if (!node) return { nodes: [], consumed: 0 };
  const schemaNode = translator$s.encode(params);
  const newNodes = schemaNode ? [schemaNode] : [];
  return { nodes: newNodes, consumed: 1 };
};
const drawingNodeHandlerEntity = {
  handlerName: 'drawingNodeHandler',
  handler: handleDrawingNode,
};
const createTrackStyleMark = (marks) => {
  const trackStyleMark = marks.find((mark) => mark.type === 'trackFormat');
  if (trackStyleMark) {
    return {
      type: 'element',
      name: 'w:rPrChange',
      attributes: {
        'w:id': trackStyleMark.attrs.id,
        'w:author': trackStyleMark.attrs.author,
        'w:authorEmail': trackStyleMark.attrs.authorEmail,
        'w:date': trackStyleMark.attrs.date,
      },
      elements: trackStyleMark.attrs.before.map((mark) => processOutputMarks([mark])).filter((r2) => r2 !== void 0),
    };
  }
  return void 0;
};
const XML_NODE_NAME$4 = 'w:del';
const SD_ATTR_KEY$1 = 'trackDelete';
const validXmlAttributes$4 = [
  createAttributeHandler('w:id', 'id'),
  createAttributeHandler('w:date', 'date'),
  createAttributeHandler('w:author', 'author'),
  createAttributeHandler('w:authorEmail', 'authorEmail'),
];
const encode$4 = (params, encodedAttrs = {}) => {
  const { nodeListHandler, extraParams = {} } = params;
  const { node } = extraParams;
  const subs = nodeListHandler.handler({
    ...params,
    insideTrackChange: true,
    nodes: node.elements,
    path: [...(params.path || []), node],
  });
  encodedAttrs.importedAuthor = `${encodedAttrs.author} (imported)`;
  subs.forEach((subElement) => {
    if (subElement.marks === void 0) subElement.marks = [];
    subElement.marks.push({ type: 'trackDelete', attrs: encodedAttrs });
  });
  return subs;
};
function decode$4(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const trackingMarks = ['trackInsert', 'trackFormat', 'trackDelete'];
  const marks = node.marks;
  const trackedMark = marks.find((m) => m.type === 'trackDelete');
  const trackStyleMark = createTrackStyleMark(marks);
  node.marks = marks.filter((m) => !trackingMarks.includes(m.type));
  if (trackStyleMark) {
    node.marks.push(trackStyleMark);
  }
  const translatedTextNode = exportSchemaToJson({ ...params, node });
  const textNode = translatedTextNode.elements.find((n) => n.name === 'w:t');
  textNode.name = 'w:delText';
  return {
    name: 'w:del',
    attributes: {
      'w:id': trackedMark.attrs.id,
      'w:author': trackedMark.attrs.author,
      'w:authorEmail': trackedMark.attrs.authorEmail,
      'w:date': trackedMark.attrs.date,
    },
    elements: [translatedTextNode],
  };
}
const config$4 = {
  xmlName: XML_NODE_NAME$4,
  sdNodeOrKeyName: SD_ATTR_KEY$1,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$4,
  decode: decode$4,
  attributes: validXmlAttributes$4,
};
const translator$4 = NodeTranslator.from(config$4);
const XML_NODE_NAME$3 = 'w:ins';
const SD_ATTR_KEY = 'trackInsert';
const validXmlAttributes$3 = [
  createAttributeHandler('w:id', 'id'),
  createAttributeHandler('w:date', 'date'),
  createAttributeHandler('w:author', 'author'),
  createAttributeHandler('w:authorEmail', 'authorEmail'),
];
const encode$3 = (params, encodedAttrs = {}) => {
  const { nodeListHandler, extraParams = {} } = params;
  const { node } = extraParams;
  const subs = nodeListHandler.handler({
    ...params,
    insideTrackChange: true,
    nodes: node.elements,
    path: [...(params.path || []), node],
  });
  encodedAttrs.importedAuthor = `${encodedAttrs.author} (imported)`;
  subs.forEach((subElement) => {
    if (subElement.marks === void 0) subElement.marks = [];
    subElement.marks.push({ type: 'trackInsert', attrs: encodedAttrs });
  });
  return subs;
};
function decode$3(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const trackingMarks = ['trackInsert', 'trackFormat', 'trackDelete'];
  const marks = node.marks;
  const trackedMark = marks.find((m) => m.type === 'trackInsert');
  const trackStyleMark = createTrackStyleMark(marks);
  node.marks = marks.filter((m) => !trackingMarks.includes(m.type));
  if (trackStyleMark) {
    node.marks.push(trackStyleMark);
  }
  const translatedTextNode = exportSchemaToJson({ ...params, node });
  return {
    name: 'w:ins',
    attributes: {
      'w:id': trackedMark.attrs.id,
      'w:author': trackedMark.attrs.author,
      'w:authorEmail': trackedMark.attrs.authorEmail,
      'w:date': trackedMark.attrs.date,
    },
    elements: [translatedTextNode],
  };
}
const config$3 = {
  xmlName: XML_NODE_NAME$3,
  sdNodeOrKeyName: SD_ATTR_KEY,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$3,
  decode: decode$3,
  attributes: validXmlAttributes$3,
};
const translator$3 = NodeTranslator.from(config$3);
const isTrackChangeElement = (node) => node?.name === 'w:del' || node?.name === 'w:ins';
const unwrapTrackChangeNode = (node) => {
  if (!node) {
    return null;
  }
  if (isTrackChangeElement(node)) {
    return node;
  }
  if (node.name === 'w:sdt') {
    const content = node.elements?.find((element) => element.name === 'w:sdtContent');
    if (!content?.elements?.length) {
      return null;
    }
    for (const child of content.elements) {
      const trackChange = unwrapTrackChangeNode(child);
      if (trackChange) {
        return trackChange;
      }
    }
  }
  return null;
};
const handleTrackChangeNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = unwrapTrackChangeNode(nodes[0]);
  if (!mainNode) {
    return { nodes: [], consumed: 0 };
  }
  let result;
  const translatorParams = {
    ...params,
    nodes: [mainNode],
  };
  switch (mainNode.name) {
    case 'w:del':
      result = translator$4.encode({
        extraParams: {
          node: mainNode,
        },
        ...translatorParams,
      });
      break;
    case 'w:ins':
      result = translator$3.encode({
        extraParams: {
          node: mainNode,
        },
        ...translatorParams,
      });
      break;
  }
  return { nodes: result, consumed: 1 };
};
const trackChangeNodeHandlerEntity = {
  handlerName: 'trackChangeNodeHandler',
  handler: handleTrackChangeNode,
};
const hyperlinkNodeHandlerEntity = generateV2HandlerEntity('hyperlinkNodeHandler', translator$1d);
const runNodeHandlerEntity = generateV2HandlerEntity('runNodeHandler', translator$1c);
const XML_NODE_NAME$2 = 'w:t';
const SD_NODE_NAME$2 = 'text';
const validXmlAttributes$2 = [createAttributeHandler('xml:space', 'xmlSpace')];
const encode$2 = (params, encodedAttrs = {}) => {
  const { node } = params.extraParams;
  const { elements, type, attributes } = node;
  let text;
  if (!elements) {
    return null;
  }
  if (elements.length === 1) {
    text = elements[0].text;
    const xmlSpace = encodedAttrs.xmlSpace ?? elements[0]?.attributes?.['xml:space'];
    if (xmlSpace !== 'preserve' && typeof text === 'string') {
      text = text.replace(/^\s+/, '').replace(/\s+$/, '');
    }
    text = text.replace(/\[\[sdspace\]\]/g, '');
  } else if (!elements.length && encodedAttrs.xmlSpace === 'preserve') {
    text = ' ';
  } else return null;
  return {
    type: 'text',
    text,
    attrs: { type, attributes: attributes || {} },
    marks: [],
  };
};
const decode$2 = (params) => {
  const { node, extraParams } = params;
  if (!node || !node.type) {
    return null;
  }
  const trackedMarks = ['trackDelete', 'trackInsert'];
  const trackedMark = node.marks?.find((m) => trackedMarks.includes(m.type));
  if (trackedMark) {
    switch (trackedMark.type) {
      case 'trackDelete':
        return translator$4.decode(params);
      case 'trackInsert':
        return translator$3.decode(params);
    }
  }
  const isLinkNode = node.marks?.some((m) => m.type === 'link');
  if (isLinkNode && !extraParams?.linkProcessed) {
    return translator$1d.decode(params);
  }
  const { text, marks = [] } = node;
  return getTextNodeForExport(text, marks, params);
};
const config$2 = {
  xmlName: XML_NODE_NAME$2,
  sdNodeOrKeyName: SD_NODE_NAME$2,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$2,
  decode: decode$2,
  attributes: validXmlAttributes$2,
};
const translator$2 = NodeTranslator.from(config$2);
const handleTextNode = (params) => {
  const { nodes, insideTrackChange } = params;
  if (nodes.length === 0 || !(nodes[0].name === 'w:t' || (insideTrackChange && nodes[0].name === 'w:delText'))) {
    return { nodes: [], consumed: 0 };
  }
  const node = nodes[0];
  const resultNode = translator$2.encode({
    ...params,
    extraParams: {
      ...(params.extraParams || {}),
      node,
    },
  });
  if (!resultNode) return { nodes: [], consumed: 0 };
  return {
    nodes: [resultNode],
    consumed: 1,
  };
};
const textNodeHandlerEntity = {
  handlerName: 'textNodeHandler',
  handler: handleTextNode,
};
const handleParagraphNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:p') {
    return { nodes: [], consumed: 0 };
  }
  const schemaNode = translator$1p.encode(params);
  const newNodes = schemaNode ? [schemaNode] : [];
  return { nodes: newNodes, consumed: 1 };
};
const paragraphNodeHandlerEntity = {
  handlerName: 'paragraphNodeHandler',
  handler: handleParagraphNode,
};
const handleSdtNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:sdt') {
    return { nodes: [], consumed: 0 };
  }
  const result = translator$r.encode(params);
  if (!result) {
    return { nodes: [], consumed: 0 };
  }
  const resultNodes = Array.isArray(result) ? result : [result];
  return {
    nodes: resultNodes,
    consumed: 1,
  };
};
const sdtNodeHandlerEntity = {
  handlerName: 'sdtNodeHandler',
  handler: handleSdtNode,
};
function parseProperties(node) {
  const marks = [];
  const unknownMarks = [];
  const { attributes = {}, elements = [] } = node;
  const { nodes, paragraphProperties = {}, runProperties = {} } = splitElementsAndProperties(elements);
  const hasRun = elements.find((element) => element.name === 'w:r');
  if (hasRun) paragraphProperties.elements = paragraphProperties?.elements?.filter((el) => el.name !== 'w:rPr');
  if (runProperties && runProperties?.elements?.length) {
    marks.push(...parseMarks(runProperties, unknownMarks));
  }
  if (paragraphProperties && paragraphProperties.elements?.length) {
    const disallowedParagraphProperties = ['w:u'];
    const filteredParagraphProperties = {
      ...paragraphProperties,
      elements: paragraphProperties.elements?.filter((el) => !disallowedParagraphProperties.includes(el.name)),
    };
    marks.push(...parseMarks(filteredParagraphProperties, unknownMarks));
  }
  marks.push(...handleStyleChangeMarks(runProperties, marks));
  if (paragraphProperties && paragraphProperties.elements?.length) {
    attributes['paragraphProperties'] = paragraphProperties;
  }
  if (marks && node.name === 'w:p') {
    marks.forEach((mark) => {
      const attrValue = Object.keys(mark.attrs ?? {})[0];
      if (attrValue) {
        const value = mark.attrs[attrValue];
        attributes[attrValue] = value;
      }
    });
  }
  return { elements: nodes, attributes, marks, unknownMarks };
}
function splitElementsAndProperties(elements) {
  const pPr = elements.find((el) => el.name === 'w:pPr');
  const rPr = elements.find((el) => el.name === 'w:rPr');
  const sectPr = elements.find((el) => el.name === 'w:sectPr');
  const els = elements.filter((el) => el.name !== 'w:pPr' && el.name !== 'w:rPr' && el.name !== 'w:sectPr');
  return {
    nodes: els,
    paragraphProperties: pPr,
    runProperties: rPr,
    sectionProperties: sectPr,
  };
}
function getElementName(element) {
  return SuperConverter.allowedElements[element.name || element.type];
}
const isPropertiesElement = (element) => {
  return !!SuperConverter.propertyTypes[element.name || element.type];
};
const handleStandardNode = (params) => {
  const { nodes, docx, nodeListHandler } = params;
  if (!nodes || nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const node = nodes[0];
  const { name } = node;
  const { attributes, elements, marks = [] } = parseProperties(node);
  if (name === 'w:sdt') {
    return { nodes: [], consumed: 0 };
  }
  if (isPropertiesElement(node)) {
    return {
      nodes: [
        {
          type: getElementName(node),
          attrs: { ...attributes },
          marks: [],
        },
      ],
      consumed: 0,
    };
  }
  if (!getElementName(node)) {
    return {
      nodes: [
        {
          type: name,
          content: elements,
          attrs: { ...attributes },
          marks,
        },
      ],
      consumed: 0,
      unhandled: true,
    };
  }
  const content = [];
  const parentStyleId = getParentStyleId(node);
  if (elements && elements.length) {
    const updatedElements = elements.map((el) => {
      if (!el.marks) el.marks = [];
      el.marks.push(...marks);
      return el;
    });
    const childParams = {
      ...params,
      nodes: updatedElements,
      parentStyleId,
      path: [...(params.path || []), node],
    };
    const childContent = nodeListHandler.handler(childParams);
    content.push(...childContent);
  }
  const resultNode = {
    type: getElementName(node),
    content,
    attrs: { ...attributes },
    marks: [],
  };
  return { nodes: [resultNode], consumed: 1 };
};
const getParentStyleId = (node) => {
  const pPr = node.elements?.find((el) => el.name === 'w:pPr');
  const styleTag = pPr?.elements?.find((el) => el.name === 'w:pStyle');
  return styleTag ? styleTag.attributes['w:val'] : null;
};
const standardNodeHandlerEntity = {
  handlerName: 'standardNodeHandler',
  handler: handleStandardNode,
};
const handler = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:br') {
    return { nodes: [], consumed: 0 };
  }
  const result = translator$1s.encode(params);
  if (!result) return { nodes: [], consumed: 0 };
  return {
    nodes: [result],
    consumed: 1,
  };
};
const lineBreakNodeHandlerEntity = {
  handlerName: 'lineBreakNodeHandler',
  handler,
};
const handleBookmarkNode = (params) => {
  const { nodes, nodeListHandler, editor } = params;
  if (nodes.length === 0 || nodes[0].name !== 'w:bookmarkStart') {
    return { nodes: [], consumed: 0 };
  }
  const node = nodes[0];
  const handleStandardNode2 = nodeListHandler.handlerEntities.find(
    (e) => e.handlerName === 'standardNodeHandler',
  )?.handler;
  if (!handleStandardNode2) {
    console.error('Standard node handler not found');
    return { nodes: [], consumed: 0 };
  }
  const customMarks = editor?.extensionService?.extensions?.filter((e) => e.isExternal === true) || [];
  const bookmarkName = node.attributes['w:name']?.split(';')[0];
  const customMark = customMarks.find((mark) => mark.name === bookmarkName);
  if (customMark) {
    const bookmarkEndIndex = nodes.findIndex(
      (n) => n.name === 'w:bookmarkEnd' && n.attributes['w:id'] === node.attributes['w:id'],
    );
    const textNodes = nodes.slice(1, bookmarkEndIndex);
    const nodeListHandler2 = params.nodeListHandler;
    const attrs = {};
    node.attributes['w:name'].split(';').forEach((name) => {
      const [key2, value] = name.split('=');
      if (key2 && value) {
        attrs[key2] = value;
      }
    });
    const translatedText = nodeListHandler2.handler({
      ...params,
      nodes: textNodes,
      path: [...(params.path || []), node],
    });
    translatedText.forEach((n) => {
      n.marks.push({
        type: customMark.name,
        attrs,
      });
    });
    return {
      nodes: translatedText,
      consumed: translatedText.length + 2,
    };
  }
  const updatedParams = { ...params, nodes: [node] };
  const result = handleStandardNode2(updatedParams);
  if (result.nodes.length === 1) {
    result.nodes[0].attrs.name = node.attributes['w:name'];
    result.nodes[0].attrs.id = node.attributes['w:id'];
  }
  return result;
};
const handleBookmarkStartNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== 'w:bookmarkStart') {
    return { nodes: [], consumed: 0 };
  }
  if (isCustomMarkBookmark(nodes[0], params.editor)) {
    return handleBookmarkNode(params);
  }
  const node = translator$8.encode(params);
  if (!node) return { nodes: [], consumed: 0 };
  return { nodes: [node], consumed: 1 };
};
const isCustomMarkBookmark = (bookmarkStartNode, editor) => {
  if (!bookmarkStartNode?.attributes || !editor?.extensionService?.extensions) {
    return false;
  }
  const rawBookmarkName = bookmarkStartNode.attributes['w:name'];
  if (!rawBookmarkName || typeof rawBookmarkName !== 'string') {
    return false;
  }
  const [bookmarkName, ...bookmarkPayloadParts] = rawBookmarkName.split(';');
  if (!bookmarkName) {
    return false;
  }
  const customMarks = editor.extensionService.extensions.filter((extension) => extension.isExternal === true);
  const matchesCustomMarkName = customMarks.some((mark) => mark.name === bookmarkName);
  if (!matchesCustomMarkName) {
    return false;
  }
  return bookmarkPayloadParts.some((part) => part && part.includes('='));
};
const bookmarkStartNodeHandlerEntity = {
  handlerName: 'w:bookmarkStartTranslator',
  handler: handleBookmarkStartNode,
};
const handleBookmarkEndNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== 'w:bookmarkEnd') {
    return { nodes: [], consumed: 0 };
  }
  const node = translator$7.encode(params);
  if (!node) return { nodes: [], consumed: 0 };
  return { nodes: [node], consumed: 1 };
};
const bookmarkEndNodeHandlerEntity = {
  handlerName: 'w:bookmarkEndTranslator',
  handler: handleBookmarkEndNode,
};
const SUPPORTED_ALTERNATE_CONTENT_REQUIRES = /* @__PURE__ */ new Set([
  'wps',
  'wpg',
  'wp14',
  'w14',
  'w15',
  'w16',
  'w16cex',
  'w16cid',
  'w16du',
  'w16sdtdh',
  'w16sdtfl',
  'w16se',
]);
const XML_NODE_NAME$1 = 'mc:AlternateContent';
const SD_NODE_NAME$1 = [];
const validXmlAttributes$1 = [];
function encode$1(params) {
  const { nodeListHandler } = params;
  const { node } = params.extraParams;
  if (!node || !node.type) {
    return null;
  }
  const { branch, elements } = selectAlternateContentElements(node);
  if (!elements) {
    return null;
  }
  return nodeListHandler.handler({
    ...params,
    nodes: elements,
    path: buildPath(params.path, node, branch),
  });
}
function decode$1(params) {
  const { node } = params;
  const { drawingContent } = node.attrs;
  const drawing = {
    name: 'w:drawing',
    elements: [...(drawingContent ? [...(drawingContent.elements || [])] : [])],
  };
  const choice = {
    name: 'mc:Choice',
    attributes: { Requires: 'wps' },
    elements: [drawing],
  };
  return {
    name: 'mc:AlternateContent',
    elements: [choice],
  };
}
const config$1 = {
  xmlName: XML_NODE_NAME$1,
  sdNodeOrKeyName: SD_NODE_NAME$1,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$1,
  decode: decode$1,
  attributes: validXmlAttributes$1,
};
function selectAlternateContentElements(node) {
  if (!node?.elements?.length) {
    return { branch: null, elements: null };
  }
  const choices = node.elements.filter((el) => el?.name === 'mc:Choice');
  const fallback = node.elements.find((el) => el?.name === 'mc:Fallback');
  const supportedChoice = choices.find((choice) => {
    const requiresAttr = choice?.attributes?.Requires || choice?.attributes?.requires;
    if (!requiresAttr) return false;
    return requiresAttr
      .split(/\s+/)
      .filter(Boolean)
      .some((namespace) => SUPPORTED_ALTERNATE_CONTENT_REQUIRES.has(namespace));
  });
  const branch = supportedChoice || fallback || choices[0] || null;
  const selectedElements = branch?.elements;
  if (!selectedElements) {
    return { branch, elements: null };
  }
  return {
    branch,
    elements: carbonCopy(selectedElements),
  };
}
const translator$1 = NodeTranslator.from(config$1);
function buildPath(existingPath = [], node, branch) {
  const path = [...existingPath];
  if (node) path.push(node);
  if (branch) path.push(branch);
  return path;
}
const ALTERNATE_CONTENT_NODE = 'mc:AlternateContent';
const skipHandlerResponse = { nodes: [], consumed: 0 };
const isAlternateContentNode = (node) => node?.name === ALTERNATE_CONTENT_NODE;
const resolveAlternateContentElements = (alternateContent) => {
  const { elements } = selectAlternateContentElements(alternateContent);
  if (!elements) return null;
  return elements;
};
const buildNodeWithoutAlternateContent = (node) => {
  const { elements } = node || {};
  if (!elements?.length) return null;
  let replaced = false;
  const updatedElements = [];
  elements.forEach((element) => {
    if (isAlternateContentNode(element)) {
      const resolved = resolveAlternateContentElements(element);
      if (resolved) {
        updatedElements.push(...resolved);
        replaced = true;
        return;
      }
      updatedElements.push(carbonCopy(element));
      return;
    }
    updatedElements.push(carbonCopy(element));
  });
  if (!replaced) return null;
  const clone = carbonCopy(node);
  clone.elements = updatedElements;
  return clone;
};
const handleAlternateChoice = (params) => {
  const { nodes, nodeListHandler } = params;
  if (!nodes?.length) {
    return skipHandlerResponse;
  }
  const [currentNode] = nodes;
  if (isAlternateContentNode(currentNode)) {
    const nodeForTranslator = currentNode?.type
      ? currentNode
      : {
          ...currentNode,
          type: 'element',
        };
    const translated = translator$1.encode({
      ...params,
      nodes: [nodeForTranslator],
      extraParams: { ...(params.extraParams || {}), node: nodeForTranslator },
    });
    if (!translated) {
      return skipHandlerResponse;
    }
    const nodesArray = Array.isArray(translated) ? translated : [translated];
    return { nodes: nodesArray, consumed: 1 };
  }
  const sanitizedNode = buildNodeWithoutAlternateContent(currentNode);
  if (!sanitizedNode) {
    return skipHandlerResponse;
  }
  const result = nodeListHandler.handler({
    ...params,
    nodes: [sanitizedNode],
    path: [...(params.path || []), sanitizedNode],
  });
  return { nodes: result, consumed: 1 };
};
const alternateChoiceHandler = {
  handlerName: 'alternateChoiceHandler',
  handler: handleAlternateChoice,
};
const handleAutoPageNumber = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'sd:autoPageNumber') {
    return { nodes: [], consumed: 0 };
  }
  const rPr = nodes[0].elements?.find((el) => el.name === 'w:rPr');
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: 'page-number',
    attrs: {
      marksAsAttrs: marks,
    },
  };
  return { nodes: [processedNode], consumed: 1 };
};
const autoPageHandlerEntity = {
  handlerName: 'autoPageNumberHandler',
  handler: handleAutoPageNumber,
};
const handleAutoTotalPageNumber = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== 'sd:totalPageNumber') {
    return { nodes: [], consumed: 0 };
  }
  const rPr = nodes[0].elements?.find((el) => el.name === 'w:rPr');
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: 'total-page-number',
    attrs: {
      marksAsAttrs: marks,
    },
  };
  return { nodes: [processedNode], consumed: 1 };
};
const autoTotalPageCountEntity = {
  handlerName: 'autoTotalPageCountEntity',
  handler: handleAutoTotalPageNumber,
};
const pageReferenceEntity = generateV2HandlerEntity('pageReferenceNodeHandler', translator$6);
const handlePictNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== 'w:p') {
    return { nodes: [], consumed: 0 };
  }
  const pNode = nodes[0];
  const runs = pNode.elements?.filter((el) => el.name === 'w:r') || [];
  let pict = null;
  for (const run2 of runs) {
    const foundPict = run2.elements?.find((el) => el.name === 'w:pict');
    if (foundPict) {
      pict = foundPict;
      break;
    }
  }
  if (!pict) {
    return { nodes: [], consumed: 0 };
  }
  const node = pict;
  const result = translator.encode({ ...params, extraParams: { node, pNode } });
  if (!result) {
    return { nodes: [], consumed: 0 };
  }
  return {
    nodes: [result],
    consumed: 1,
  };
};
const pictNodeHandlerEntity = {
  handlerName: 'handlePictNode',
  handler: handlePictNode,
};
function importCommentData({ docx, editor, converter }) {
  const nodeListHandler = defaultNodeListHandler();
  const comments = docx['word/comments.xml'];
  if (!comments) return;
  const { elements } = comments;
  if (!elements || !elements.length) return;
  const { elements: allComments = [] } = elements[0];
  const extractedComments = allComments.map((el) => {
    const { attributes } = el;
    const importedId = attributes['w:id'];
    const authorName = attributes['w:author'];
    const authorEmail = attributes['w:email'];
    const initials = attributes['w:initials'];
    const createdDate = attributes['w:date'];
    const internalId = attributes['custom:internalId'];
    const trackedChange = attributes['custom:trackedChange'] === 'true';
    const trackedChangeType = attributes['custom:trackedChangeType'];
    const trackedChangeText =
      attributes['custom:trackedChangeText'] !== 'null' ? attributes['custom:trackedChangeText'] : null;
    const trackedDeletedText =
      attributes['custom:trackedDeletedText'] !== 'null' ? attributes['custom:trackedDeletedText'] : null;
    const date = new Date(createdDate);
    const unixTimestampMs = date.getTime();
    const parsedComment = nodeListHandler.handler({
      nodes: el.elements,
      nodeListHandler,
      docx,
      editor,
      converter,
      path: [el],
    });
    const { attrs } = parsedComment[0];
    const paraId = attrs['w14:paraId'];
    return {
      commentId: internalId || v4(),
      importedId,
      creatorName: authorName,
      creatorEmail: authorEmail,
      createdTime: unixTimestampMs,
      textJson: parsedComment[0],
      initials,
      paraId,
      trackedChange,
      trackedChangeText,
      trackedChangeType,
      trackedDeletedText,
      isDone: false,
    };
  });
  const extendedComments = generateCommentsWithExtendedData({ docx, comments: extractedComments });
  return extendedComments;
}
const generateCommentsWithExtendedData = ({ docx, comments }) => {
  if (!comments?.length) return [];
  const commentsExtended = docx['word/commentsExtended.xml'];
  if (!commentsExtended) return comments.map((comment) => ({ ...comment, isDone: comment.isDone ?? false }));
  const { elements: initialElements = [] } = commentsExtended;
  if (!initialElements?.length) return comments.map((comment) => ({ ...comment, isDone: comment.isDone ?? false }));
  const { elements = [] } = initialElements[0] ?? {};
  const commentEx = elements.filter((el) => el.name === 'w15:commentEx');
  return comments.map((comment) => {
    const extendedDef = commentEx.find((ce) => ce.attributes['w15:paraId'] === comment.paraId);
    if (!extendedDef) return { ...comment, isDone: comment.isDone ?? false };
    const { isDone, paraIdParent } = getExtendedDetails(extendedDef);
    let parentComment;
    if (paraIdParent) parentComment = comments.find((c) => c.paraId === paraIdParent);
    const newComment = {
      ...comment,
      isDone: isDone ?? false,
      parentCommentId: parentComment?.commentId,
    };
    return newComment;
  });
};
const getExtendedDetails = (commentEx) => {
  const { attributes } = commentEx;
  const paraId = attributes['w15:paraId'];
  const isDone = attributes['w15:done'] === '1' ? true : false;
  const paraIdParent = attributes['w15:paraIdParent'];
  return { paraId, isDone, paraIdParent };
};
const RELATIONSHIP_TYPES =
  /** @type {const} */
  {
    image: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
    hyperlink: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
  };
const getDocumentRelationshipElements = (editor) => {
  const docx = editor.converter?.convertedXml;
  if (!docx) return [];
  const documentRels = docx['word/_rels/document.xml.rels'];
  const elements = documentRels?.elements;
  if (!Array.isArray(elements)) return [];
  const relationshipTag = elements.find((el) => el.name === 'Relationships');
  return relationshipTag?.elements || [];
};
const getMaxRelationshipIdInt = (relationships) => {
  const ids = [];
  relationships.forEach((rel) => {
    const splitId = rel.attributes.Id.split('rId');
    const parsedInt = parseInt(splitId[1], 10);
    if (Number.isInteger(parsedInt)) {
      ids.push(parsedInt);
    }
  });
  if (ids.length === 0) return 0;
  return Math.max(...ids);
};
const findRelationshipIdFromTarget = (target, editor) => {
  if (!target) return null;
  if (target.startsWith('word/')) target = target.replace('word/', '');
  const relationships = getDocumentRelationshipElements(editor);
  const existingLinkRel = relationships?.find((rel) => rel.attributes.Target === target);
  if (existingLinkRel) {
    return existingLinkRel.attributes.Id;
  }
};
const insertNewRelationship = (target, type, editor) => {
  if (!target || typeof target !== 'string') {
    throw new Error('Target must be a non-empty string');
  }
  if (!type || typeof type !== 'string') {
    throw new Error('Type must be a non-empty string');
  }
  if (!editor) {
    throw new Error('Editor instance is required');
  }
  const mappedType = RELATIONSHIP_TYPES[type];
  if (!mappedType) {
    console.warn(
      `Unsupported relationship type: ${type}. Available types: ${Object.keys(RELATIONSHIP_TYPES).join(', ')}`,
    );
    return null;
  }
  const existingRelId = findRelationshipIdFromTarget(target, editor);
  if (existingRelId) {
    console.info(`Reusing existing relationship for target: ${target} (ID: ${existingRelId})`);
    return existingRelId;
  }
  const docx = editor.converter?.convertedXml;
  if (!docx) {
    console.error('No converted XML found in editor');
    return null;
  }
  const documentRels = docx['word/_rels/document.xml.rels'];
  if (!documentRels) {
    console.error('No document relationships found in the docx');
    return null;
  }
  const relationshipsTag = documentRels.elements?.find((el) => el.name === 'Relationships');
  if (!relationshipsTag) {
    console.error('No Relationships tag found in document relationships');
    return null;
  }
  if (!relationshipsTag.elements) {
    relationshipsTag.elements = [];
  }
  const newId = getNewRelationshipId(editor);
  if (!newId) {
    console.error('Failed to generate new relationship ID');
    return null;
  }
  const newRel = {
    type: 'element',
    name: 'Relationship',
    attributes: {
      Id: newId,
      Type: mappedType,
      Target: target,
    },
  };
  if (type === 'hyperlink') {
    newRel.attributes.TargetMode = 'External';
  }
  relationshipsTag.elements.push(newRel);
  return newId;
};
const getNewRelationshipId = (editor) => {
  const relationships = getDocumentRelationshipElements(editor);
  const maxIdInt = getMaxRelationshipIdInt(relationships);
  return `rId${maxIdInt + 1}`;
};
const DocxHelpers = {
  findRelationshipIdFromTarget,
  insertNewRelationship,
  getNewRelationshipId,
};
const kebabCase = (str) => str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
const comments_module_events = {
  ADD: 'add',
  UPDATE: 'update',
  SELECTED: 'selected',
};
const getDefaultStyleDefinition = (defaultStyleId, docx) => {
  const result = { lineSpaceBefore: null, lineSpaceAfter: null };
  if (!defaultStyleId) return result;
  const styles = docx['word/styles.xml'];
  if (!styles) return result;
  const { elements } = styles.elements[0];
  const elementsWithId = elements.filter((el) => {
    const { attributes } = el;
    return attributes && attributes['w:styleId'] === defaultStyleId;
  });
  const firstMatch = elementsWithId[0];
  if (!firstMatch) return result;
  const qFormat = elementsWithId.find((el) => {
    const qFormat2 = el.elements.find((innerEl) => innerEl.name === 'w:qFormat');
    return qFormat2;
  });
  const name = elementsWithId
    .find((el) => el.elements.some((inner) => inner.name === 'w:name'))
    ?.elements.find((inner) => inner.name === 'w:name')?.attributes['w:val'];
  const pPr = firstMatch.elements.find((el) => el.name === 'w:pPr');
  const spacing = pPr?.elements?.find((el) => el.name === 'w:spacing');
  const justify = pPr?.elements?.find((el) => el.name === 'w:jc');
  const indent = pPr?.elements?.find((el) => el.name === 'w:ind');
  const tabs = pPr?.elements?.find((el) => el.name === 'w:tabs');
  let lineSpaceBefore, lineSpaceAfter, line;
  if (spacing) {
    lineSpaceBefore = twipsToPixels(spacing?.attributes['w:before']);
    lineSpaceAfter = twipsToPixels(spacing?.attributes['w:after']);
    line = twipsToLines(spacing?.attributes['w:line']);
  }
  let textAlign, leftIndent, rightIndent, firstLine;
  if (indent) {
    textAlign = justify?.attributes['w:val'];
    leftIndent = twipsToPixels(indent?.attributes['w:left']);
    rightIndent = twipsToPixels(indent?.attributes['w:right']);
    firstLine = twipsToPixels(indent?.attributes['w:firstLine']);
  }
  let tabStops = [];
  if (tabs) {
    tabStops = (tabs.elements || [])
      .filter((el) => el.name === 'w:tab')
      .map((tab) => {
        let val = tab.attributes['w:val'];
        if (val == 'left') {
          val = 'start';
        } else if (val == 'right') {
          val = 'end';
        }
        return {
          val,
          pos: twipsToPixels(tab.attributes['w:pos']),
          leader: tab.attributes['w:leader'],
        };
      });
  }
  const keepNext = pPr?.elements?.find((el) => el.name === 'w:keepNext');
  const keepLines = pPr?.elements?.find((el) => el.name === 'w:keepLines');
  const outlineLevel = pPr?.elements?.find((el) => el.name === 'w:outlineLvl');
  const outlineLvlValue = outlineLevel?.attributes['w:val'];
  const pageBreakBefore = pPr?.elements?.find((el) => el.name === 'w:pageBreakBefore');
  let pageBreakBeforeVal = 0;
  if (pageBreakBefore) {
    if (!pageBreakBefore.attributes?.['w:val']) pageBreakBeforeVal = 1;
    else pageBreakBeforeVal = Number(pageBreakBefore?.attributes?.['w:val']);
  }
  const pageBreakAfter = pPr?.elements?.find((el) => el.name === 'w:pageBreakAfter');
  let pageBreakAfterVal;
  if (pageBreakAfter) {
    if (!pageBreakAfter.attributes?.['w:val']) pageBreakAfterVal = 1;
    else pageBreakAfterVal = Number(pageBreakAfter?.attributes?.['w:val']);
  }
  const basedOn = elementsWithId
    .find((el) => el.elements.some((inner) => inner.name === 'w:basedOn'))
    ?.elements.find((inner) => inner.name === 'w:basedOn')?.attributes['w:val'];
  const parsedAttrs = {
    name,
    qFormat: qFormat ? true : false,
    keepNext: keepNext ? true : false,
    keepLines: keepLines ? true : false,
    outlineLevel: outlineLevel ? parseInt(outlineLvlValue) : null,
    pageBreakBefore: pageBreakBeforeVal ? true : false,
    pageBreakAfter: pageBreakAfterVal ? true : false,
    basedOn: basedOn ?? null,
  };
  const rPr = firstMatch.elements.find((el) => el.name === 'w:rPr');
  const parsedMarks = parseMarks(rPr, [], docx) || [];
  const parsedStyles = {
    spacing: { lineSpaceAfter, lineSpaceBefore, line },
    textAlign,
    indent: { leftIndent, rightIndent, firstLine },
    tabStops: tabStops.length > 0 ? tabStops : null,
  };
  parsedMarks.forEach((mark) => {
    const { type, attrs } = mark;
    if (type === 'textStyle') {
      Object.entries(attrs).forEach(([key2, value]) => {
        parsedStyles[kebabCase(key2)] = value;
      });
      return;
    }
    parsedStyles[type] = attrs;
  });
  return {
    attrs: parsedAttrs,
    styles: parsedStyles,
  };
};
const IGNORED_NODE_NAMES = ['w:proofErr', 'w:lastRenderedPageBreak'];
const pruneIgnoredNodes = (nodes = []) =>
  nodes
    .filter((node) => !IGNORED_NODE_NAMES.includes(node.name))
    .map((node) => (node.elements ? { ...node, elements: pruneIgnoredNodes(node.elements) } : node));
const handleTabNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== 'w:tab') {
    return { nodes: [], consumed: 0 };
  }
  const node = translator$1q.encode(params);
  return { nodes: [node], consumed: 1 };
};
const tabNodeEntityHandler = {
  handlerName: 'w:tabTranslator',
  handler: handleTabNode,
};
const tableNodeHandlerEntity = generateV2HandlerEntity('tableNodeHandler', translator$9);
const tableOfContentsHandlerEntity = generateV2HandlerEntity('tableOfContentsHandler', translator$5);
function preProcessPageInstruction(nodesToCombine) {
  const pageNumNode = {
    name: 'sd:autoPageNumber',
    type: 'element',
  };
  nodesToCombine.forEach((n) => {
    const rPrNode = n.elements.find((el) => el.name === 'w:rPr');
    if (rPrNode) pageNumNode.elements = [rPrNode];
  });
  return [pageNumNode];
}
function preProcessNumPagesInstruction(nodesToCombine) {
  const totalPageNumNode = {
    name: 'sd:totalPageNumber',
    type: 'element',
  };
  nodesToCombine.forEach((n) => {
    const rPrNode = n.elements?.find((el) => el.name === 'w:rPr');
    if (rPrNode) totalPageNumNode.elements = [rPrNode];
  });
  return [totalPageNumNode];
}
function preProcessPageRefInstruction(nodesToCombine, instrText) {
  const pageRefNode = {
    name: 'sd:pageReference',
    type: 'element',
    attributes: {
      instruction: instrText,
    },
    elements: nodesToCombine,
  };
  return [pageRefNode];
}
function preProcessHyperlinkInstruction(nodesToCombine, instruction, docx) {
  const urlMatch = instruction.match(/HYPERLINK\s+"([^"]+)"/);
  let linkAttributes;
  if (urlMatch && urlMatch.length >= 2) {
    const url = urlMatch[1];
    const rels = docx['word/_rels/document.xml.rels'];
    const relationships = rels?.elements.find((el) => el.name === 'Relationships');
    if (relationships) {
      const rId = generateDocxRandomId();
      relationships.elements.push({
        type: 'element',
        name: 'Relationship',
        attributes: {
          Id: rId,
          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
          Target: url,
          TargetMode: 'External',
        },
      });
      linkAttributes = { 'r:id': rId };
    } else {
      linkAttributes = { 'w:anchor': url };
    }
  } else {
    const availableSwitches = {
      'w:anchor': /(?:\\)?l "(?<value>[^"]+)"/,
      new_window: /(?:\\n|\n)/,
      'w:tgtFrame': /(?:\\t|\t) "(?<value>[^"]+)"/,
      'w:tooltip': /(?:\\)?o "(?<value>[^"]+)"/,
    };
    const parsedSwitches = {};
    for (const [key2, pattern] of Object.entries(availableSwitches)) {
      const match = instruction.match(pattern);
      if (match) {
        parsedSwitches[key2] = match.groups?.value || true;
      }
    }
    if (parsedSwitches.new_window) {
      parsedSwitches['w:tgtFrame'] = '_blank';
      delete parsedSwitches.new_window;
    }
    linkAttributes = { ...parsedSwitches };
  }
  return [
    {
      name: 'w:hyperlink',
      type: 'element',
      attributes: linkAttributes,
      elements: nodesToCombine,
    },
  ];
}
function preProcessTocInstruction(nodesToCombine, instrText) {
  return [
    {
      name: 'sd:tableOfContents',
      type: 'element',
      attributes: {
        instruction: instrText,
      },
      elements: nodesToCombine,
    },
  ];
}
const getInstructionPreProcessor = (instruction) => {
  const instructionType = instruction.split(' ')[0];
  switch (instructionType) {
    case 'PAGE':
      return preProcessPageInstruction;
    case 'NUMPAGES':
      return preProcessNumPagesInstruction;
    case 'PAGEREF':
      return preProcessPageRefInstruction;
    case 'HYPERLINK':
      return preProcessHyperlinkInstruction;
    case 'TOC':
      return preProcessTocInstruction;
    default:
      return null;
  }
};
const preProcessNodesForFldChar = (nodes = [], docx) => {
  const processedNodes = [];
  let collectedNodesStack = [];
  let currentFieldStack = [];
  let unpairedEnd = null;
  let collecting = false;
  const finalizeField = () => {
    if (collecting) {
      const collectedNodes = collectedNodesStack.pop().filter((n) => n !== null);
      const currentField = currentFieldStack.pop();
      const combined = _processCombinedNodesForFldChar(collectedNodes, currentField.instrText.trim(), docx);
      if (collectedNodesStack.length === 0) {
        processedNodes.push(...combined);
      } else {
        collectedNodesStack[collectedNodesStack.length - 1].push(...combined);
      }
    } else {
      unpairedEnd = true;
    }
  };
  for (const node of nodes) {
    const fldCharEl = node.elements?.find((el) => el.name === 'w:fldChar');
    const fldType = fldCharEl?.attributes?.['w:fldCharType'];
    const instrTextEl = node.elements?.find((el) => el.name === 'w:instrText');
    collecting = collectedNodesStack.length > 0;
    if (fldType === 'begin') {
      collectedNodesStack.push([null]);
      currentFieldStack.push({ instrText: '' });
      continue;
    }
    if (instrTextEl && collecting && currentFieldStack.length > 0) {
      currentFieldStack[currentFieldStack.length - 1].instrText += (instrTextEl.elements?.[0]?.text || '') + ' ';
      continue;
    }
    if (fldType === 'end') {
      finalizeField();
      continue;
    } else if (fldType === 'separate') {
      continue;
    }
    if (Array.isArray(node.elements)) {
      const childResult = preProcessNodesForFldChar(node.elements, docx);
      node.elements = childResult.processedNodes;
      if (childResult.unpairedBegin) {
        childResult.unpairedBegin.forEach((pendingField) => {
          currentFieldStack.push(pendingField.fieldInfo);
          collectedNodesStack.push([node]);
        });
      } else if (childResult.unpairedEnd) {
        collectedNodesStack[collectedNodesStack.length - 1].push(node);
        finalizeField();
      } else if (collecting) {
        collectedNodesStack[collectedNodesStack.length - 1].push(node);
      } else {
        processedNodes.push(node);
      }
    } else if (collecting) {
      collectedNodesStack[collectedNodesStack.length - 1].push(node);
    } else {
      processedNodes.push(node);
    }
  }
  let unpairedBegin = null;
  if (collectedNodesStack.length > 0) {
    unpairedBegin = [];
    for (let i = 0; i < collectedNodesStack.length; i++) {
      processedNodes.push(...collectedNodesStack[i].filter((n) => n !== null));
      unpairedBegin.push({
        nodes: collectedNodesStack[i],
        fieldInfo: currentFieldStack[i],
      });
    }
  }
  return { processedNodes, unpairedBegin, unpairedEnd };
};
const _processCombinedNodesForFldChar = (nodesToCombine = [], instrText, docx) => {
  const instructionType = instrText.trim().split(' ')[0];
  const instructionPreProcessor = getInstructionPreProcessor(instructionType);
  if (instructionPreProcessor) {
    return instructionPreProcessor(nodesToCombine, instrText, docx);
  } else {
    return nodesToCombine;
  }
};
const createDocumentJson = (docx, converter, editor) => {
  const json = carbonCopy(getInitialJSON(docx));
  if (!json) return null;
  if (converter?.telemetry) {
    const files = Object.keys(docx).map((filePath) => {
      const parts = filePath.split('/');
      return {
        filePath,
        fileDepth: parts.length,
        fileType: filePath.split('.').pop(),
      };
    });
    const trackStructure = (documentIdentifier = null) =>
      converter.telemetry.trackFileStructure(
        {
          totalFiles: files.length,
          maxDepth: Math.max(...files.map((f2) => f2.fileDepth)),
          totalNodes: 0,
          files,
        },
        converter.fileSource,
        converter.documentGuid ?? converter.documentId ?? null,
        documentIdentifier ?? converter.documentId ?? null,
        converter.documentInternalId,
      );
    try {
      const identifierResult = converter.getDocumentIdentifier?.();
      if (identifierResult && typeof identifierResult.then === 'function') {
        identifierResult.then(trackStructure).catch(() => trackStructure());
      } else {
        trackStructure(identifierResult);
      }
    } catch {
      trackStructure();
    }
  }
  const nodeListHandler = defaultNodeListHandler();
  const bodyNode = json.elements[0].elements.find((el) => el.name === 'w:body');
  if (bodyNode) {
    ensureSectionProperties(bodyNode);
    const node = bodyNode;
    const { processedNodes } = preProcessNodesForFldChar(node.elements ?? [], docx);
    node.elements = processedNodes;
    const contentElements = node.elements?.filter((n) => n.name !== 'w:sectPr') ?? [];
    const content = pruneIgnoredNodes(contentElements);
    const comments = importCommentData({ docx, converter, editor });
    const lists = {};
    const inlineDocumentFonts = [];
    let parsedContent = nodeListHandler.handler({
      nodes: content,
      nodeListHandler,
      docx,
      converter,
      editor,
      inlineDocumentFonts,
      lists,
      path: [],
    });
    parsedContent = filterOutRootInlineNodes(parsedContent);
    const result = {
      type: 'doc',
      content: parsedContent,
      attrs: {
        attributes: json.elements[0].attributes,
      },
    };
    if (result.content.length > 1) {
      converter?.telemetry?.trackUsage('document_import', {
        documentType: 'docx',
        timestamp: /* @__PURE__ */ new Date().toISOString(),
      });
    }
    return {
      pmDoc: result,
      savedTagsToRestore: node,
      pageStyles: getDocumentStyles(node, docx, converter, editor),
      comments,
      inlineDocumentFonts,
      linkedStyles: getStyleDefinitions(docx),
      numbering: getNumberingDefinitions(docx, converter),
    };
  }
  return null;
};
const defaultNodeListHandler = () => {
  const entities = [
    alternateChoiceHandler,
    runNodeHandlerEntity,
    pictNodeHandlerEntity,
    listHandlerEntity,
    paragraphNodeHandlerEntity,
    textNodeHandlerEntity,
    lineBreakNodeHandlerEntity,
    sdtNodeHandlerEntity,
    bookmarkStartNodeHandlerEntity,
    bookmarkEndNodeHandlerEntity,
    hyperlinkNodeHandlerEntity,
    drawingNodeHandlerEntity,
    trackChangeNodeHandlerEntity,
    tableNodeHandlerEntity,
    tabNodeEntityHandler,
    tableOfContentsHandlerEntity,
    autoPageHandlerEntity,
    autoTotalPageCountEntity,
    pageReferenceEntity,
    standardNodeHandlerEntity,
  ];
  const handler2 = createNodeListHandler(entities);
  return {
    handler: handler2,
    handlerEntities: entities,
  };
};
const createNodeListHandler = (nodeHandlers) => {
  const getSafeElementContext = (elements, index, processedNode, path) => {
    if (!elements || index < 0 || index >= elements.length) {
      return {
        elementIndex: index,
        error: 'index_out_of_bounds',
        arrayLength: elements?.length,
      };
    }
    const element = elements[index];
    return {
      elementName: element?.name,
      attributes: processedNode?.attrs,
      marks: processedNode?.marks,
      elementPath: path,
      type: processedNode?.type,
      content: processedNode?.content,
    };
  };
  const nodeListHandlerFn = ({
    nodes: elements,
    docx,
    insideTrackChange,
    converter,
    editor,
    filename,
    parentStyleId,
    lists,
    inlineDocumentFonts,
    path = [],
  }) => {
    if (!elements || !elements.length) return [];
    const filteredElements = pruneIgnoredNodes(elements);
    if (!filteredElements.length) return [];
    const processedElements = [];
    try {
      for (let index = 0; index < filteredElements.length; index++) {
        try {
          const nodesToHandle = filteredElements.slice(index);
          if (!nodesToHandle || nodesToHandle.length === 0) {
            continue;
          }
          const { nodes, consumed, unhandled } = nodeHandlers.reduce(
            (res, handler2) => {
              if (res.consumed > 0) return res;
              return handler2.handler({
                nodes: nodesToHandle,
                docx,
                nodeListHandler: { handler: nodeListHandlerFn, handlerEntities: nodeHandlers },
                insideTrackChange,
                converter,
                editor,
                filename,
                parentStyleId,
                lists,
                inlineDocumentFonts,
                path,
              });
            },
            { nodes: [], consumed: 0 },
          );
          const context = getSafeElementContext(
            filteredElements,
            index,
            nodes[0],
            `/word/${filename || 'document.xml'}`,
          );
          if (unhandled) {
            if (!context.elementName) continue;
            converter?.telemetry?.trackStatistic('unknown', context);
            continue;
          } else {
            converter?.telemetry?.trackStatistic('node', context);
            if (context.type === 'orderedList' || context.type === 'bulletList') {
              context.content.forEach((item) => {
                const innerItemContext = getSafeElementContext([item], 0, item, `/word/${filename || 'document.xml'}`);
                converter?.telemetry?.trackStatistic('attributes', innerItemContext);
              });
            }
            const hasHighlightMark = nodes[0]?.marks?.find((mark) => mark.type === 'highlight');
            if (hasHighlightMark) {
              converter?.docHiglightColors.add(hasHighlightMark.attrs.color.toUpperCase());
            }
          }
          if (consumed > 0) {
            index += consumed - 1;
          }
          if (nodes) {
            nodes.forEach((node) => {
              if (node?.type && !['runProperties'].includes(node.type)) {
                if (node.type === 'text' && Array.isArray(node.content) && !node.content.length) {
                  return;
                }
                processedElements.push(node);
              }
            });
          }
        } catch (error) {
          console.debug('Import error', error);
          editor?.emit('exception', { error, editor });
          converter?.telemetry?.trackStatistic('error', {
            type: 'processing_error',
            message: error.message,
            name: error.name,
            stack: error.stack,
            fileName: `/word/${filename || 'document.xml'}`,
          });
        }
      }
      return processedElements;
    } catch (error) {
      console.debug('Error during import', error);
      editor?.emit('exception', { error, editor });
      converter?.telemetry?.trackStatistic('error', {
        type: 'fatal_error',
        message: error.message,
        name: error.name,
        stack: error.stack,
        fileName: `/word/${filename || 'document.xml'}`,
      });
      throw error;
    }
  };
  return nodeListHandlerFn;
};
function getDocumentStyles(node, docx, converter, editor) {
  const sectPr = node.elements?.find((n) => n.name === 'w:sectPr');
  const styles = {};
  sectPr?.elements?.forEach((el) => {
    const { name, attributes } = el;
    switch (name) {
      case 'w:pgSz':
        styles['pageSize'] = {
          width: twipsToInches(attributes['w:w']),
          height: twipsToInches(attributes['w:h']),
        };
        break;
      case 'w:pgMar':
        styles['pageMargins'] = {
          top: twipsToInches(attributes['w:top']),
          right: twipsToInches(attributes['w:right']),
          bottom: twipsToInches(attributes['w:bottom']),
          left: twipsToInches(attributes['w:left']),
          header: twipsToInches(attributes['w:header']),
          footer: twipsToInches(attributes['w:footer']),
          gutter: twipsToInches(attributes['w:gutter']),
        };
        break;
      case 'w:cols':
        styles['columns'] = {
          space: twipsToInches(attributes['w:space']),
          num: attributes['w:num'],
          equalWidth: attributes['w:equalWidth'],
        };
        break;
      case 'w:docGrid':
        styles['docGrid'] = {
          linePitch: twipsToInches(attributes['w:linePitch']),
          type: attributes['w:type'],
        };
        break;
      case 'w:titlePg':
        converter.headerIds.titlePg = true;
    }
  });
  importHeadersFooters(docx, converter, editor);
  styles.alternateHeaders = isAlternatingHeadersOddEven(docx);
  return styles;
}
const DEFAULT_SECTION_PROPS = Object.freeze({
  pageSize: Object.freeze({ width: '12240', height: '15840' }),
  pageMargins: Object.freeze({
    top: '1440',
    right: '1440',
    bottom: '1440',
    left: '1440',
    header: '720',
    footer: '720',
    gutter: '0',
  }),
});
function ensureSectionProperties(bodyNode) {
  if (!bodyNode.elements) bodyNode.elements = [];
  let sectPr = bodyNode.elements.find((el) => el.name === 'w:sectPr');
  if (!sectPr) {
    sectPr = {
      type: 'element',
      name: 'w:sectPr',
      elements: [],
    };
    bodyNode.elements.push(sectPr);
  } else if (!sectPr.elements) {
    sectPr.elements = [];
  }
  const ensureChild = (name, factory) => {
    let child = sectPr.elements.find((el) => el.name === name);
    if (!child) {
      child = factory();
      sectPr.elements.push(child);
    } else if (!child.attributes) {
      child.attributes = {};
    }
    return child;
  };
  const pgSz = ensureChild('w:pgSz', () => ({
    type: 'element',
    name: 'w:pgSz',
    attributes: {},
  }));
  pgSz.attributes['w:w'] = pgSz.attributes['w:w'] ?? DEFAULT_SECTION_PROPS.pageSize.width;
  pgSz.attributes['w:h'] = pgSz.attributes['w:h'] ?? DEFAULT_SECTION_PROPS.pageSize.height;
  const pgMar = ensureChild('w:pgMar', () => ({
    type: 'element',
    name: 'w:pgMar',
    attributes: {},
  }));
  Object.entries(DEFAULT_SECTION_PROPS.pageMargins).forEach(([key2, value]) => {
    const attrKey = `w:${key2}`;
    if (pgMar.attributes[attrKey] == null) pgMar.attributes[attrKey] = value;
  });
  return sectPr;
}
function getStyleDefinitions(docx) {
  const styles = docx['word/styles.xml'];
  if (!styles) return [];
  const { elements } = styles.elements[0];
  const styleDefinitions = elements.filter((el) => el.name === 'w:style');
  const latentStyles = elements.find((el) => el.name === 'w:latentStyles');
  latentStyles?.elements.forEach((el) => {
    const { attributes } = el;
    styleDefinitions.find((style) => style.attributes['w:styleId'] === attributes['w:name']);
  });
  const allParsedStyles = [];
  styleDefinitions.forEach((style) => {
    const id = style.attributes['w:styleId'];
    const parsedStyle = getDefaultStyleDefinition(id, docx);
    const importedStyle = {
      id: style.attributes['w:styleId'],
      type: style.attributes['w:type'],
      definition: parsedStyle,
      attributes: {},
    };
    allParsedStyles.push(importedStyle);
  });
  return allParsedStyles;
}
function addDefaultStylesIfMissing(styles) {
  if (!styles) return null;
  const updatedStyles = carbonCopy(styles);
  const { elements } = updatedStyles.elements[0];
  Object.keys(DEFAULT_LINKED_STYLES).forEach((styleId) => {
    const existsOnDoc = elements.some((el) => el.attributes?.['w:styleId'] === styleId);
    if (!existsOnDoc) {
      const missingStyle = DEFAULT_LINKED_STYLES[styleId];
      updatedStyles.elements[0].elements.push(missingStyle);
    }
  });
  return updatedStyles;
}
const importHeadersFooters = (docx, converter, mainEditor) => {
  const rels = docx['word/_rels/document.xml.rels'];
  const relationships = rels?.elements.find((el) => el.name === 'Relationships');
  const { elements } = relationships || { elements: [] };
  const headerType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header';
  const footerType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer';
  const headers = elements.filter((el) => el.attributes['Type'] === headerType);
  const footers = elements.filter((el) => el.attributes['Type'] === footerType);
  const sectPr = findSectPr(docx['word/document.xml']) || [];
  const allSectPrElements = sectPr.flatMap((el) => el.elements);
  if (!mainEditor) return;
  const editor = { ...mainEditor };
  editor.options.annotations = true;
  headers.forEach((header) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(header, docx);
    const sectPrHeader = allSectPrElements.find(
      (el) => el.name === 'w:headerReference' && el.attributes['r:id'] === rId,
    );
    let sectionType = sectPrHeader?.attributes['w:type'];
    if (converter.headerIds[sectionType]) sectionType = null;
    const nodeListHandler = defaultNodeListHandler();
    let schema = nodeListHandler.handler({
      nodes: referenceFile.elements[0].elements,
      nodeListHandler,
      docx,
      converter,
      editor,
      filename: currentFileName,
      path: [],
    });
    schema = filterOutRootInlineNodes(schema);
    if (!converter.headerIds.ids) converter.headerIds.ids = [];
    converter.headerIds.ids.push(rId);
    converter.headers[rId] = { type: 'doc', content: [...schema] };
    sectionType && (converter.headerIds[sectionType] = rId);
  });
  const titlePg = allSectPrElements?.find((el) => el.name === 'w:titlePg');
  if (titlePg) converter.headerIds.titlePg = true;
  footers.forEach((footer) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(footer, docx);
    const sectPrFooter = allSectPrElements.find(
      (el) => el.name === 'w:footerReference' && el.attributes['r:id'] === rId,
    );
    const sectionType = sectPrFooter?.attributes['w:type'];
    const nodeListHandler = defaultNodeListHandler();
    let schema = nodeListHandler.handler({
      nodes: referenceFile.elements[0].elements,
      nodeListHandler,
      docx,
      converter,
      editor,
      filename: currentFileName,
      path: [],
    });
    schema = filterOutRootInlineNodes(schema);
    if (!converter.footerIds.ids) converter.footerIds.ids = [];
    converter.footerIds.ids.push(rId);
    converter.footers[rId] = { type: 'doc', content: [...schema] };
    converter.footerIds[sectionType] = rId;
  });
};
const findSectPr = (obj, result = []) => {
  for (const key2 in obj) {
    if (obj[key2] === 'w:sectPr') {
      result.push(obj);
    } else if (typeof obj[key2] === 'object') {
      findSectPr(obj[key2], result);
    }
  }
  return result;
};
const getHeaderFooterSectionData = (sectionData, docx) => {
  const rId = sectionData.attributes.Id;
  const target = sectionData.attributes.Target;
  const referenceFile = docx[`word/${target}`];
  const currentFileName = target;
  return {
    rId,
    referenceFile,
    currentFileName,
  };
};
function filterOutRootInlineNodes(content = []) {
  if (!Array.isArray(content) || content.length === 0) return content;
  const INLINE_TYPES = /* @__PURE__ */ new Set([
    'text',
    'bookmarkStart',
    'bookmarkEnd',
    'lineBreak',
    'hardBreak',
    'pageNumber',
    'totalPageCount',
    'runItem',
    'image',
    'tab',
    'fieldAnnotation',
    'mention',
    'contentBlock',
    'aiLoaderNode',
    'commentRangeStart',
    'commentRangeEnd',
    'commentReference',
    'structuredContent',
  ]);
  return content.filter((node) => node && typeof node.type === 'string' && !INLINE_TYPES.has(node.type));
}
function getNumberingDefinitions(docx, converter) {
  const cache = ensureNumberingCache(docx, converter);
  const abstractDefinitions = {};
  cache.abstractById.forEach((value, key2) => {
    const numericKey = Number(key2);
    if (!Number.isNaN(numericKey)) {
      abstractDefinitions[numericKey] = value;
    }
  });
  let importListDefs = {};
  cache.numNodesById.forEach((value, key2) => {
    const numericKey = Number(key2);
    if (Number.isInteger(numericKey)) {
      importListDefs[numericKey] = value;
    }
  });
  const listDefsEntries = Object.entries(importListDefs);
  const foundByDurableId = listDefsEntries.filter(([, def]) => def.attributes?.['w16cid:durableId'] === '485517411');
  if (foundByDurableId.length > 1) {
    importListDefs = Object.fromEntries(
      listDefsEntries.filter(([, def]) => def.attributes?.['w16cid:durableId'] !== '485517411'),
    );
  }
  return {
    abstracts: abstractDefinitions,
    definitions: importListDefs,
  };
}
const isAlternatingHeadersOddEven = (docx) => {
  const settings = docx['word/settings.xml'];
  if (!settings || !settings.elements?.length) return false;
  const { elements = [] } = settings.elements[0];
  const evenOdd = elements.find((el) => el.name === 'w:evenAndOddHeaders');
  return !!evenOdd;
};
function handleShapeTextboxImport({ params, pict }) {
  const shape = pict.elements?.find((el) => el.name === 'v:shape');
  const schemaAttrs = {};
  const schemaTextboxAttrs = {};
  const shapeAttrs = shape.attributes || {};
  schemaAttrs.attributes = shapeAttrs;
  if (shapeAttrs.fillcolor) {
    schemaAttrs.fillcolor = shapeAttrs.fillcolor;
  }
  const parsedStyle = parseInlineStyles(shapeAttrs.style);
  const shapeStyle = buildStyles(parsedStyle);
  if (shapeStyle) {
    schemaAttrs.style = shapeStyle;
  }
  const textbox = shape.elements?.find((el) => el.name === 'v:textbox');
  const wrap = shape.elements?.find((el) => el.name === 'w10:wrap');
  if (wrap?.attributes) {
    schemaAttrs.wrapAttributes = wrap.attributes;
  }
  if (textbox?.attributes) {
    schemaTextboxAttrs.attributes = textbox.attributes;
  }
  const textboxContent = textbox?.elements?.find((el) => el.name === 'w:txbxContent');
  const textboxContentElems = textboxContent?.elements || [];
  const content = textboxContentElems.map((elem) =>
    handleParagraphNode({
      nodes: [elem],
      docx: params.docx,
      nodeListHandler: defaultNodeListHandler(),
    }),
  );
  const contentNodes = content.reduce((acc, current) => [...acc, ...current.nodes], []);
  const shapeTextbox = {
    type: 'shapeTextbox',
    attrs: schemaTextboxAttrs,
    content: contentNodes,
  };
  const shapeContainer = {
    type: 'shapeContainer',
    attrs: schemaAttrs,
    content: [shapeTextbox],
  };
  return shapeContainer;
}
function buildStyles(styleObject) {
  const allowed = [
    'width',
    'height',
    // these styles should probably work relative to the page,
    // since in the doc it is positioned absolutely.
    // 'margin-left',
    // 'margin-right',
    // causes pagination issues.
    // 'margin-top',
    // 'margin-bottom',
    // styleObject - also contains other word styles (mso-).
  ];
  let style = '';
  for (const [prop, value] of Object.entries(styleObject)) {
    if (allowed.includes(prop)) {
      style += `${prop}: ${value};`;
    }
  }
  return style;
}
function pictNodeTypeStrategy(node) {
  const shape = node.elements?.find((el) => el.name === 'v:shape');
  const group = node.elements?.find((el) => el.name === 'v:group');
  const rect = node.elements?.find((el) => el.name === 'v:rect');
  if (rect) {
    return { type: 'contentBlock', handler: handleVRectImport };
  }
  if (!shape && !group) {
    return { type: 'unknown', handler: null };
  }
  const isGroup = group && !shape;
  if (isGroup) {
    return { type: 'unknown', handler: null };
  } else {
    const textbox = shape.elements?.find((el) => el.name === 'v:textbox');
    if (textbox) {
      return { type: 'shapeContainer', handler: handleShapeTextboxImport };
    }
  }
  return { type: 'unknown', handler: null };
}
function translateShapeContainer(params) {
  const { node } = params;
  const elements = translateChildNodes(params);
  const shape = {
    name: 'v:shape',
    attributes: {
      ...node.attrs.attributes,
      fillcolor: node.attrs.fillcolor,
    },
    elements: [
      ...elements,
      ...(node.attrs.wrapAttributes
        ? [
            {
              name: 'w10:wrap',
              attributes: { ...node.attrs.wrapAttributes },
            },
          ]
        : []),
    ],
  };
  const pict = {
    name: 'w:pict',
    attributes: {
      'w14:anchorId': generateRandomSigned32BitIntStrId(),
    },
    elements: [shape],
  };
  const par = {
    name: 'w:p',
    elements: [wrapTextInRun(pict)],
  };
  return par;
}
function translateShapeTextbox(params) {
  const { node } = params;
  const elements = translateChildNodes(params);
  const textboxContent = {
    name: 'w:txbxContent',
    elements,
  };
  const textbox = {
    name: 'v:textbox',
    attributes: {
      ...node.attrs.attributes,
    },
    elements: [textboxContent],
  };
  return textbox;
}
function translateContentBlock(params) {
  const { node } = params;
  const { vmlAttributes, horizontalRule } = node.attrs;
  if (vmlAttributes || horizontalRule) {
    return translateVRectContentBlock(params);
  }
  const alternateContent = translator$1.decode(params);
  return wrapTextInRun(alternateContent);
}
function translateVRectContentBlock(params) {
  const { node } = params;
  const { vmlAttributes, background, attributes, style } = node.attrs;
  const rectAttrs = {
    id: attributes?.id || `_x0000_i${Math.floor(Math.random() * 1e4)}`,
  };
  if (style) {
    rectAttrs.style = style;
  }
  if (background) {
    rectAttrs.fillcolor = background;
  }
  if (vmlAttributes) {
    if (vmlAttributes.hralign) rectAttrs['o:hralign'] = vmlAttributes.hralign;
    if (vmlAttributes.hrstd) rectAttrs['o:hrstd'] = vmlAttributes.hrstd;
    if (vmlAttributes.hr) rectAttrs['o:hr'] = vmlAttributes.hr;
    if (vmlAttributes.stroked) rectAttrs.stroked = vmlAttributes.stroked;
  }
  if (attributes) {
    Object.entries(attributes).forEach(([key2, value]) => {
      if (!rectAttrs[key2] && value !== void 0) {
        rectAttrs[key2] = value;
      }
    });
  }
  const rect = {
    name: 'v:rect',
    attributes: rectAttrs,
  };
  const pict = {
    name: 'w:pict',
    attributes: {
      'w14:anchorId': generateRandomSigned32BitIntStrId(),
    },
    elements: [rect],
  };
  return wrapTextInRun(pict);
}
const XML_NODE_NAME = 'w:pict';
const SD_NODE_NAME = ['shapeContainer', 'contentBlock'];
const validXmlAttributes = [];
function encode(params) {
  const { node, pNode } = params.extraParams;
  const { type: pictType, handler: handler2 } = pictNodeTypeStrategy(node);
  if (!handler2 || pictType === 'unknown') {
    return void 0;
  }
  const result = handler2({
    params,
    pNode,
    pict: node,
  });
  return result;
}
function decode(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const types = {
    shapeContainer: () => translateShapeContainer(params),
    shapeTextbox: () => translateShapeTextbox(params),
    contentBlock: () => translateContentBlock(params),
    default: () => null,
  };
  const decoder = types[node.type] ?? types.default;
  const result = decoder();
  return result;
}
const config = {
  xmlName: XML_NODE_NAME,
  sdNodeOrKeyName: SD_NODE_NAME,
  type: NodeTranslator.translatorTypes.NODE,
  encode,
  decode,
  attributes: validXmlAttributes,
};
const translator = NodeTranslator.from(config);
const RUN_LEVEL_WRAPPERS = /* @__PURE__ */ new Set(['w:hyperlink', 'w:ins', 'w:del']);
const DEFAULT_SECTION_PROPS_TWIPS = Object.freeze({
  pageSize: Object.freeze({ width: '12240', height: '15840' }),
  pageMargins: Object.freeze({
    top: '1440',
    right: '1440',
    bottom: '1440',
    left: '1440',
    header: '720',
    footer: '720',
    gutter: '0',
  }),
});
const ensureSectionLayoutDefaults = (sectPr, converter) => {
  if (!sectPr) {
    return {
      type: 'element',
      name: 'w:sectPr',
      elements: [],
    };
  }
  if (!sectPr.elements) sectPr.elements = [];
  const ensureChild = (name) => {
    let child = sectPr.elements.find((n) => n.name === name);
    if (!child) {
      child = {
        type: 'element',
        name,
        elements: [],
        attributes: {},
      };
      sectPr.elements.push(child);
    } else {
      if (!child.elements) child.elements = [];
      if (!child.attributes) child.attributes = {};
    }
    return child;
  };
  const pageSize = converter?.pageStyles?.pageSize;
  const pgSz = ensureChild('w:pgSz');
  if (pageSize?.width != null) pgSz.attributes['w:w'] = String(inchesToTwips(pageSize.width));
  if (pageSize?.height != null) pgSz.attributes['w:h'] = String(inchesToTwips(pageSize.height));
  if (pgSz.attributes['w:w'] == null) pgSz.attributes['w:w'] = DEFAULT_SECTION_PROPS_TWIPS.pageSize.width;
  if (pgSz.attributes['w:h'] == null) pgSz.attributes['w:h'] = DEFAULT_SECTION_PROPS_TWIPS.pageSize.height;
  const pageMargins = converter?.pageStyles?.pageMargins;
  const pgMar = ensureChild('w:pgMar');
  if (pageMargins) {
    Object.entries(pageMargins).forEach(([key2, value]) => {
      const converted = inchesToTwips(value);
      if (converted != null) pgMar.attributes[`w:${key2}`] = String(converted);
    });
  }
  Object.entries(DEFAULT_SECTION_PROPS_TWIPS.pageMargins).forEach(([key2, value]) => {
    const attrKey = `w:${key2}`;
    if (pgMar.attributes[attrKey] == null) pgMar.attributes[attrKey] = value;
  });
  return sectPr;
};
const isLineBreakOnlyRun = (node) => {
  if (!node) return false;
  if (node.type === 'lineBreak' || node.type === 'hardBreak') return true;
  if (node.type !== 'run') return false;
  const runContent = Array.isArray(node.content) ? node.content : [];
  if (!runContent.length) return false;
  return runContent.every((child) => child?.type === 'lineBreak' || child?.type === 'hardBreak');
};
function convertSdtContentToRuns(elements) {
  const normalized = Array.isArray(elements) ? elements : [elements];
  const runs = [];
  normalized.forEach((element) => {
    if (!element) return;
    if (element.name === 'w:sdtPr') {
      return;
    }
    if (element.name === 'w:r') {
      runs.push(element);
      return;
    }
    if (element.name === 'w:sdt') {
      const sdtContent = (element.elements || []).find((child) => child?.name === 'w:sdtContent');
      if (sdtContent?.elements) {
        runs.push(...convertSdtContentToRuns(sdtContent.elements));
      }
      return;
    }
    if (RUN_LEVEL_WRAPPERS.has(element.name)) {
      const wrapperElements = convertSdtContentToRuns(element.elements || []);
      if (wrapperElements.length) {
        runs.push({
          ...element,
          elements: wrapperElements,
        });
      }
      return;
    }
    if (element.name) {
      runs.push({
        name: 'w:r',
        type: 'element',
        elements: element.elements || [element],
      });
    }
  });
  return runs.filter((run2) => Array.isArray(run2.elements) && run2.elements.length > 0);
}
function exportSchemaToJson(params) {
  const { type } = params.node || {};
  const router = {
    doc: translateDocumentNode,
    body: translateBodyNode,
    heading: translateHeadingNode,
    paragraph: translator$1p,
    run: translator$1c,
    text: translator$2,
    bulletList: translateList,
    orderedList: translateList,
    lineBreak: translator$1s,
    table: translator$9,
    tableRow: translator$v,
    tableCell: translator$I,
    bookmarkStart: translator$8,
    bookmarkEnd: translator$7,
    fieldAnnotation: translator$r,
    tab: translator$1q,
    image: translator$s,
    hardBreak: translator$1s,
    commentRangeStart: commentRangeStartTranslator,
    commentRangeEnd: commentRangeEndTranslator,
    commentReference: () => null,
    shapeContainer: translator,
    shapeTextbox: translator,
    contentBlock: translator,
    vectorShape: translateVectorShape,
    shapeGroup: translateShapeGroup,
    structuredContent: translator$r,
    structuredContentBlock: translator$r,
    documentPartObject: translator$r,
    documentSection: translator$r,
    'page-number': translatePageNumberNode,
    'total-page-number': translateTotalPageNumberNode,
    pageReference: translator$6,
    tableOfContents: translator$5,
  };
  let handler2 = router[type];
  if (handler2 && 'decode' in handler2 && typeof handler2.decode === 'function') {
    return handler2.decode(params);
  }
  if (!handler2) {
    console.error('No translation function found for node type:', type);
    return null;
  }
  return handler2(params);
}
function translateBodyNode(params) {
  let sectPr = params.bodyNode?.elements?.find((n) => n.name === 'w:sectPr');
  if (!sectPr) {
    sectPr = {
      type: 'element',
      name: 'w:sectPr',
      elements: [],
    };
  } else if (!sectPr.elements) {
    sectPr = { ...sectPr, elements: [] };
  }
  sectPr = ensureSectionLayoutDefaults(sectPr, params.converter);
  if (params.converter) {
    const hasHeader = sectPr.elements?.some((n) => n.name === 'w:headerReference');
    const hasDefaultHeader = params.converter.headerIds?.default;
    if (!hasHeader && hasDefaultHeader && !params.editor.options.isHeaderOrFooter) {
      const defaultHeader = generateDefaultHeaderFooter('header', params.converter.headerIds?.default);
      sectPr.elements.push(defaultHeader);
    }
    const hasFooter = sectPr.elements?.some((n) => n.name === 'w:footerReference');
    const hasDefaultFooter = params.converter.footerIds?.default;
    if (!hasFooter && hasDefaultFooter && !params.editor.options.isHeaderOrFooter) {
      const defaultFooter = generateDefaultHeaderFooter('footer', params.converter.footerIds?.default);
      sectPr.elements.push(defaultFooter);
    }
  }
  const elements = translateChildNodes(params);
  if (params.isHeaderFooter) {
    return {
      name: 'w:body',
      elements: [...elements],
    };
  }
  return {
    name: 'w:body',
    elements: [...elements, sectPr],
  };
}
const generateDefaultHeaderFooter = (type, id) => {
  return {
    type: 'element',
    name: `w:${type}Reference`,
    attributes: {
      'w:type': 'default',
      'r:id': id,
    },
  };
};
function translateHeadingNode(params) {
  const { node } = params;
  const { level = 1, ...otherAttrs } = node.attrs;
  const paragraphNode = {
    type: 'paragraph',
    content: node.content,
    attrs: {
      ...otherAttrs,
      styleId: `Heading${level}`,
      // Maps to Heading1, Heading2, etc. in Word
    },
  };
  return translateParagraphNode({ ...params, node: paragraphNode });
}
function translateParagraphNode(params) {
  const elements = translateChildNodes(params);
  const htmlAnnotationChild = elements.find((element) => element.name === 'htmlAnnotation');
  if (htmlAnnotationChild) {
    return htmlAnnotationChild.elements;
  }
  const pPr = generateParagraphProperties(params.node);
  if (pPr) elements.unshift(pPr);
  let attributes = {};
  if (params.node.attrs?.rsidRDefault) {
    attributes['w:rsidRDefault'] = params.node.attrs.rsidRDefault;
  }
  const result = {
    name: 'w:p',
    elements,
    attributes,
  };
  return result;
}
function normalizeLineHeight(value) {
  if (typeof value === 'string' && value.trim().endsWith('%')) {
    const parsed2 = parseFloat(value);
    return Number.isFinite(parsed2) ? parsed2 / 100 : null;
  }
  const parsed = parseFloat(value);
  return Number.isFinite(parsed) ? parsed : null;
}
function generateParagraphProperties(node) {
  const { attrs = {} } = node;
  const pPrElements = [];
  const { styleId } = attrs;
  if (styleId) pPrElements.push({ name: 'w:pStyle', attributes: { 'w:val': styleId } });
  const { spacing, indent, textAlign, textIndent, lineHeight, marksAttrs, keepLines, keepNext, dropcap, borders } =
    attrs;
  if (spacing) {
    const { lineSpaceBefore, lineSpaceAfter, lineRule } = spacing;
    const attributes = {};
    if (lineSpaceBefore >= 0) attributes['w:before'] = pixelsToTwips(lineSpaceBefore);
    if (lineSpaceAfter >= 0) attributes['w:after'] = pixelsToTwips(lineSpaceAfter);
    attributes['w:lineRule'] = lineRule || 'auto';
    const normalized = normalizeLineHeight(lineHeight);
    if (normalized !== null) {
      if (lineRule === 'exact') {
        attributes['w:line'] = ptToTwips(normalized);
      } else if (lineHeight.endsWith('px')) {
        attributes['w:line'] = pixelsToTwips(normalized);
        attributes['w:lineRule'] = 'exact';
      } else {
        attributes['w:line'] = linesToTwips(normalized);
      }
    }
    const spacingElement = {
      name: 'w:spacing',
      attributes,
    };
    pPrElements.push(spacingElement);
  }
  if (lineHeight && !spacing) {
    const spacingElement = {
      name: 'w:spacing',
      attributes: {
        'w:line': linesToTwips(lineHeight),
      },
    };
    pPrElements.push(spacingElement);
  }
  const hasIndent = !!indent;
  if (hasIndent) {
    const { left, right, firstLine, hanging, explicitLeft, explicitRight, explicitFirstLine, explicitHanging } = indent;
    const attributes = {};
    if (left !== void 0 && (left !== 0 || explicitLeft || textIndent)) {
      attributes['w:left'] = pixelsToTwips(left);
    }
    if (right !== void 0 && (right !== 0 || explicitRight)) {
      attributes['w:right'] = pixelsToTwips(right);
    }
    if (firstLine !== void 0 && (firstLine !== 0 || explicitFirstLine)) {
      attributes['w:firstLine'] = pixelsToTwips(firstLine);
    }
    if (hanging !== void 0 && (hanging !== 0 || explicitHanging)) {
      attributes['w:hanging'] = pixelsToTwips(hanging);
    }
    if (textIndent && attributes['w:left'] === void 0) {
      attributes['w:left'] = getTextIndentExportValue(textIndent);
    }
    if (Object.keys(attributes).length) {
      const indentElement = {
        name: 'w:ind',
        attributes,
      };
      pPrElements.push(indentElement);
    }
  } else if (textIndent && textIndent !== '0in') {
    const indentElement = {
      name: 'w:ind',
      attributes: {
        'w:left': getTextIndentExportValue(textIndent),
      },
    };
    pPrElements.push(indentElement);
  }
  if (textAlign) {
    const textAlignElement = {
      name: 'w:jc',
      attributes: { 'w:val': textAlign === 'justify' ? 'both' : textAlign },
    };
    pPrElements.push(textAlignElement);
  }
  if (marksAttrs) {
    const outputMarks = processOutputMarks(marksAttrs);
    const rPrElement = generateRunProps(outputMarks);
    pPrElements.push(rPrElement);
  }
  if (keepLines) {
    pPrElements.push({
      name: 'w:keepLines',
      attributes: { 'w:val': keepLines },
    });
  }
  if (keepNext) {
    pPrElements.push({
      name: 'w:keepNext',
      attributes: { 'w:val': keepNext },
    });
  }
  if (dropcap) {
    pPrElements.push({
      name: 'w:framePr',
      attributes: {
        'w:dropCap': dropcap.type,
        'w:lines': dropcap.lines,
        'w:wrap': dropcap.wrap,
        'w:vAnchor': dropcap.vAnchor,
        'w:hAnchor': dropcap.hAnchor,
      },
    });
  }
  const sectPr = node.attrs?.paragraphProperties?.sectPr;
  if (sectPr) {
    pPrElements.push(sectPr);
  }
  const mapTabVal = (value) => {
    if (!value || value === 'start') return 'left';
    if (value === 'end') return 'right';
    return value;
  };
  const { tabStops } = attrs;
  if (tabStops && tabStops.length > 0) {
    const tabElements = tabStops.map((tab) => {
      const posValue = tab.originalPos !== void 0 ? tab.originalPos : pixelsToTwips(tab.pos).toString();
      const tabAttributes = {
        'w:val': mapTabVal(tab.val),
        'w:pos': posValue,
      };
      if (tab.leader) {
        tabAttributes['w:leader'] = tab.leader;
      }
      return {
        name: 'w:tab',
        attributes: tabAttributes,
      };
    });
    pPrElements.push({
      name: 'w:tabs',
      elements: tabElements,
    });
  }
  const numPr = node.attrs?.paragraphProperties?.elements?.find((n) => n.name === 'w:numPr');
  const hasNumPr = pPrElements.some((n) => n.name === 'w:numPr');
  if (numPr && !hasNumPr) pPrElements.push(numPr);
  if (!pPrElements.length) return null;
  if (borders && Object.keys(borders).length) {
    pPrElements.push(generateParagraphBorders(borders));
  }
  return {
    name: 'w:pPr',
    elements: pPrElements,
  };
}
function generateParagraphBorders(borders) {
  const elements = [];
  const sides = ['top', 'bottom', 'left', 'right'];
  sides.forEach((side) => {
    const b = borders[side];
    if (!b) return;
    let attributes;
    if (!b.size) {
      attributes = { 'w:val': 'nil' };
    } else {
      attributes = {
        'w:val': b.val || 'single',
        'w:sz': pixelsToEightPoints(b.size),
        'w:space': b.space ? pixelsToEightPoints(b.space) : 0,
        'w:color': (b.color || '#000000').replace('#', ''),
      };
    }
    elements.push({ name: `w:${side}`, attributes });
  });
  return { name: 'w:pBdr', elements };
}
function translateDocumentNode(params) {
  const bodyNode = {
    type: 'body',
    content: params.node.content,
  };
  const translatedBodyNode = exportSchemaToJson({ ...params, node: bodyNode });
  const node = {
    name: 'w:document',
    elements: [translatedBodyNode],
    attributes: DEFAULT_DOCX_DEFS,
  };
  return [node, params];
}
function getTextNodeForExport(text, marks, params) {
  const hasLeadingOrTrailingSpace = /^\s|\s$/.test(text);
  const space = hasLeadingOrTrailingSpace ? 'preserve' : null;
  const nodeAttrs = space ? { 'xml:space': space } : null;
  const textNodes = [];
  const outputMarks = processOutputMarks(marks);
  textNodes.push({
    name: 'w:t',
    elements: [{ text, type: 'text' }],
    attributes: nodeAttrs,
  });
  if (params) {
    const { editor } = params;
    const customMarks = editor.extensionService.extensions.filter((e) => e.isExternal === true);
    marks.forEach((mark) => {
      const isCustomMark = customMarks.some((customMark) => {
        const customMarkName = customMark.name;
        return mark.type === customMarkName;
      });
      if (!isCustomMark) return;
      let attrsString = '';
      Object.entries(mark.attrs).forEach(([key2, value]) => {
        if (value) {
          attrsString += `${key2}=${value};`;
        }
      });
      if (isCustomMark) {
        textNodes.unshift({
          type: 'element',
          name: 'w:bookmarkStart',
          attributes: {
            'w:id': '5000',
            'w:name': mark.type + ';' + attrsString,
          },
        });
        textNodes.push({
          type: 'element',
          name: 'w:bookmarkEnd',
          attributes: {
            'w:id': '5000',
          },
        });
      }
    });
  }
  return wrapTextInRun(textNodes, outputMarks);
}
function wrapTextInRun(nodeOrNodes, marks) {
  let elements = [];
  if (Array.isArray(nodeOrNodes)) elements = nodeOrNodes;
  else elements = [nodeOrNodes];
  if (marks && marks.length) elements.unshift(generateRunProps(marks));
  return {
    name: 'w:r',
    elements,
  };
}
function generateRunProps(marks = []) {
  return {
    name: 'w:rPr',
    elements: marks.filter((mark) => !!Object.keys(mark).length),
  };
}
function processOutputMarks(marks = []) {
  return marks.flatMap((mark) => {
    if (mark.type === 'textStyle') {
      return Object.entries(mark.attrs)
        .filter(([, value]) => value)
        .map(([key2]) => {
          const unwrappedMark = { type: key2, attrs: mark.attrs };
          return translateMark(unwrappedMark);
        });
    } else {
      return translateMark(mark);
    }
  });
}
function processLinkContentNode(node) {
  if (!node) return node;
  const contentNode = carbonCopy(node);
  if (!contentNode) return contentNode;
  const hyperlinkStyle = {
    name: 'w:rStyle',
    attributes: { 'w:val': 'Hyperlink' },
  };
  const color = {
    name: 'w:color',
    attributes: { 'w:val': '467886' },
  };
  const underline = {
    name: 'w:u',
    attributes: {
      'w:val': 'none',
    },
  };
  if (contentNode.name === 'w:r') {
    const runProps = contentNode.elements.find((el) => el.name === 'w:rPr');
    if (runProps) {
      const foundColor = runProps.elements.find((el) => el.name === 'w:color');
      const foundHyperlinkStyle = runProps.elements.find((el) => el.name === 'w:rStyle');
      const underlineMark = runProps.elements.find((el) => el.name === 'w:u');
      if (!foundColor) runProps.elements.unshift(color);
      if (!foundHyperlinkStyle) runProps.elements.unshift(hyperlinkStyle);
      if (!underlineMark) runProps.elements.unshift(underline);
    } else {
      const runProps2 = {
        name: 'w:rPr',
        elements: [hyperlinkStyle, color],
      };
      contentNode.elements.unshift(runProps2);
    }
  }
  return contentNode;
}
function addNewLinkRelationship(params, link) {
  const newId = 'rId' + generateDocxRandomId();
  if (!params.relationships || !Array.isArray(params.relationships)) {
    params.relationships = [];
  }
  params.relationships.push({
    type: 'element',
    name: 'Relationship',
    attributes: {
      Id: newId,
      Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
      Target: link,
      TargetMode: 'External',
    },
  });
  return newId;
}
function translateList(params) {
  const { node, editor } = params;
  const listItem = node.content[0];
  const { numId, level } = listItem.attrs;
  const listType = node.type.name;
  const listDef = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  if (!listDef) {
    ListHelpers.generateNewListDefinition({
      numId,
      listType,
      editor,
    });
  }
  let numPrTag;
  if (numId !== void 0 && numId !== null) {
    numPrTag = generateNumPrTag(numId, level);
  }
  const collapsedParagraphNode = convertMultipleListItemsIntoSingleNode(listItem);
  let outputNode = exportSchemaToJson({ ...params, node: collapsedParagraphNode });
  if (Array.isArray(outputNode) && params.isFinalDoc) {
    const parsedElements = [];
    outputNode?.forEach((node2, index) => {
      if (node2?.elements) {
        const runs = node2.elements?.filter((n) => n.name === 'w:r');
        parsedElements.push(...runs);
        if (node2.name === 'w:p' && index < outputNode.length - 1) {
          parsedElements.push({
            name: 'w:br',
          });
        }
      }
    });
    outputNode = {
      name: 'w:p',
      elements: [{ name: 'w:pPr', elements: [] }, ...parsedElements],
    };
  }
  let nodesToFlatten = [];
  const sdtNodes = outputNode.elements?.filter((n) => n.name === 'w:sdt');
  if (sdtNodes && sdtNodes.length > 0) {
    nodesToFlatten = sdtNodes;
    nodesToFlatten?.forEach((sdtNode) => {
      const sdtContent = sdtNode.elements.find((n) => n.name === 'w:sdtContent');
      const foundRun = sdtContent.elements?.find((el) => el.name === 'w:r');
      if (sdtContent && sdtContent.elements && !foundRun) {
        const parsedElements = [];
        sdtContent.elements.forEach((element, index) => {
          if (element.name === 'w:rPr' && element.elements?.length) {
            parsedElements.push(element);
          }
          const runs = element.elements?.filter((n) => n.name === 'w:r');
          if (runs && runs.length) {
            parsedElements.push(...runs);
          }
          if (element.name === 'w:p' && index < sdtContent.elements.length - 1) {
            parsedElements.push({
              name: 'w:br',
            });
          }
        });
        sdtContent.elements = parsedElements;
      }
    });
  }
  const pPr = outputNode.elements?.find((n) => n.name === 'w:pPr');
  if (pPr && pPr.elements && numPrTag) {
    pPr.elements.unshift(numPrTag);
  }
  const indentTag = restoreIndent(listItem.attrs.indent);
  indentTag && pPr?.elements?.push(indentTag);
  const runNode = outputNode.elements?.find((n) => n.name === 'w:r');
  const rPr = runNode?.elements?.find((n) => n.name === 'w:rPr');
  if (rPr) pPr.elements.push(rPr);
  if (listItem.attrs.numPrType !== 'inline') {
    const numPrIndex = pPr?.elements?.findIndex((e) => e?.name === 'w:numPr');
    if (numPrIndex !== -1) {
      pPr?.elements?.splice(numPrIndex, 1);
    }
  }
  return [outputNode];
}
const convertMultipleListItemsIntoSingleNode = (listItem) => {
  const { content } = listItem;
  if (!content || content.length === 0) {
    return null;
  }
  const firstParagraph = content[0];
  const collapsedParagraph = {
    ...firstParagraph,
    content: [],
  };
  content.forEach((item, index) => {
    if (item.type === 'paragraph') {
      if (index > 0) {
        collapsedParagraph.content.push({
          type: 'lineBreak',
          attrs: {},
          content: [],
        });
      }
      if (item.content && item.content.length > 0) {
        collapsedParagraph.content.push(...item.content);
      }
    } else {
      collapsedParagraph.content.push(item);
    }
  });
  collapsedParagraph.content = collapsedParagraph.content.filter((node, index, nodes) => {
    if (!isLineBreakOnlyRun(node)) return true;
    const prevNode = nodes[index - 1];
    return !(prevNode && isLineBreakOnlyRun(prevNode));
  });
  return collapsedParagraph;
};
const restoreIndent = (indent) => {
  const attributes = {};
  if (!indent) indent = {};
  if (indent.left || indent.left === 0) attributes['w:left'] = pixelsToTwips(indent.left);
  if (indent.right || indent.right === 0) attributes['w:right'] = pixelsToTwips(indent.right);
  if (indent.firstLine || indent.firstLine === 0) attributes['w:firstLine'] = pixelsToTwips(indent.firstLine);
  if (indent.hanging || indent.hanging === 0) attributes['w:hanging'] = pixelsToTwips(indent.hanging);
  if (indent.leftChars || indent.leftChars === 0) attributes['w:leftChars'] = pixelsToTwips(indent.leftChars);
  if (!Object.keys(attributes).length) return;
  return {
    name: 'w:ind',
    type: 'element',
    attributes,
  };
};
const generateNumPrTag = (numId, level) => {
  return {
    name: 'w:numPr',
    type: 'element',
    elements: [
      {
        name: 'w:numId',
        type: 'element',
        attributes: { 'w:val': numId },
      },
      {
        name: 'w:ilvl',
        type: 'element',
        attributes: { 'w:val': level },
      },
    ],
  };
};
function translateMark(mark) {
  const xmlMark = SuperConverter.markTypes.find((m) => m.type === mark.type);
  if (!xmlMark) {
    return {};
  }
  const markElement = { name: xmlMark.name, attributes: {} };
  const { attrs } = mark;
  let value;
  switch (mark.type) {
    case 'bold':
      if (attrs?.value) {
        markElement.attributes['w:val'] = attrs.value;
      } else {
        delete markElement.attributes;
      }
      markElement.type = 'element';
      break;
    case 'italic':
      if (attrs?.value && attrs.value !== '1' && attrs.value !== true) {
        markElement.attributes['w:val'] = attrs.value;
      } else {
        delete markElement.attributes;
      }
      markElement.type = 'element';
      break;
    case 'underline': {
      const translated = translator$1m.decode({
        node: {
          attrs: {
            underlineType: attrs.underlineType ?? attrs.underline ?? null,
            underlineColor: attrs.underlineColor ?? attrs.color ?? null,
            underlineThemeColor: attrs.underlineThemeColor ?? attrs.themeColor ?? null,
            underlineThemeTint: attrs.underlineThemeTint ?? attrs.themeTint ?? null,
            underlineThemeShade: attrs.underlineThemeShade ?? attrs.themeShade ?? null,
          },
        },
      });
      return translated || {};
    }
    // Text style cases
    case 'fontSize':
      value = attrs.fontSize;
      markElement.attributes['w:val'] = value.slice(0, -2) * 2;
      break;
    case 'fontFamily':
      value = attrs.fontFamily;
      ['w:ascii', 'w:eastAsia', 'w:hAnsi', 'w:cs'].forEach((attr) => {
        const parsedValue = value.split(', ');
        markElement.attributes[attr] = parsedValue[0] ? parsedValue[0] : value;
      });
      break;
    // Add ability to get run styleIds from textStyle marks and inject to run properties in word
    case 'styleId':
      markElement.name = 'w:rStyle';
      markElement.attributes['w:val'] = attrs.styleId;
      break;
    case 'color': {
      const rawColor = attrs.color;
      if (!rawColor) break;
      const normalized = String(rawColor).trim().toLowerCase();
      if (normalized === 'inherit') {
        markElement.attributes['w:val'] = 'auto';
        break;
      }
      let processedColor = String(rawColor).replace(/^#/, '').replace(/;$/, '');
      if (processedColor.startsWith('rgb')) {
        processedColor = rgbToHex(processedColor);
      }
      markElement.attributes['w:val'] = processedColor;
      break;
    }
    case 'textAlign':
      markElement.attributes['w:val'] = attrs.textAlign;
      break;
    case 'textIndent':
      markElement.attributes['w:firstline'] = inchesToTwips(attrs.textIndent);
      break;
    case 'textTransform':
      if (attrs?.textTransform === 'none') {
        markElement.attributes['w:val'] = '0';
      } else {
        delete markElement.attributes;
      }
      markElement.type = 'element';
      break;
    case 'lineHeight':
      markElement.attributes['w:line'] = linesToTwips(attrs.lineHeight);
      break;
    case 'highlight': {
      const highlightValue = attrs.color ?? attrs.highlight ?? null;
      const translated = translator$1r.decode({ node: { attrs: { highlight: highlightValue } } });
      return translated || {};
    }
    case 'strike':
      if (attrs?.value === '0') markElement.attributes['w:val'] = attrs.value;
      break;
    case 'link':
      return {};
  }
  return markElement;
}
class DocxExporter {
  constructor(converter) {
    __privateAdd(this, _DocxExporter_instances);
    this.converter = converter;
  }
  schemaToXml(data, debug = false) {
    const result = __privateMethod(this, _DocxExporter_instances, generate_xml_as_list_fn).call(this, data, debug);
    return result.join('');
  }
}
_DocxExporter_instances = new WeakSet();
generate_xml_as_list_fn = function (data, debug = false) {
  const json = JSON.parse(JSON.stringify(data));
  const declaration = this.converter.declaration.attributes;
  const xmlTag = `<?xml${Object.entries(declaration)
    .map(([key2, value]) => ` ${key2}="${value}"`)
    .join('')}?>`;
  const result = __privateMethod(this, _DocxExporter_instances, generateXml_fn).call(this, json, debug);
  const final = [xmlTag, ...result];
  return final;
};
replaceSpecialCharacters_fn = function (text) {
  if (text === void 0 || text === null) return text;
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
};
generateXml_fn = function (node) {
  if (!node) return null;
  let { name } = node;
  const { elements, attributes } = node;
  let tag = `<${name}`;
  for (let attr in attributes) {
    const parsedAttrName =
      typeof attributes[attr] === 'string'
        ? __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, attributes[attr])
        : attributes[attr];
    tag += ` ${attr}="${parsedAttrName}"`;
  }
  const selfClosing = name && (!elements || !elements.length);
  if (selfClosing) tag += ' />';
  else tag += '>';
  let tags = [tag];
  if (!name && node.type === 'text') {
    return __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, node.text ?? '');
  }
  if (elements) {
    if (name === 'w:instrText') {
      const textContent2 = (elements || [])
        .map((child) => (typeof child?.text === 'string' ? child.text : ''))
        .join('');
      tags.push(__privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, textContent2));
    } else if (name === 'w:t' || name === 'w:delText' || name === 'wp:posOffset') {
      try {
        let text = String(elements[0].text);
        text = __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, text);
        tags.push(text);
      } catch (error) {
        console.error('Text element does not contain valid string:', error);
      }
    } else {
      if (elements) {
        for (let child of elements) {
          const newElements = __privateMethod(this, _DocxExporter_instances, generateXml_fn).call(this, child);
          if (!newElements) continue;
          if (typeof newElements === 'string') {
            tags.push(newElements);
            continue;
          }
          const removeUndefined = newElements.filter((el) => {
            return el !== '<undefined>' && el !== '</undefined>';
          });
          tags.push(...removeUndefined);
        }
      }
    }
  }
  if (!selfClosing) tags.push(`</${name}>`);
  return tags;
};
const translatePageNumberNode = (params) => {
  const outputMarks = processOutputMarks(params.node.attrs?.marksAsAttrs || []);
  return getAutoPageJson('PAGE', outputMarks);
};
const translateTotalPageNumberNode = (params) => {
  const outputMarks = processOutputMarks(params.node.attrs?.marksAsAttrs || []);
  return getAutoPageJson('NUMPAGES', outputMarks);
};
const getAutoPageJson = (type, outputMarks = []) => {
  return [
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:fldChar',
          attributes: {
            'w:fldCharType': 'begin',
          },
        },
      ],
    },
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:instrText',
          attributes: { 'xml:space': 'preserve' },
          elements: [
            {
              type: 'text',
              text: ` ${type}`,
            },
          ],
        },
      ],
    },
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:fldChar',
          attributes: {
            'w:fldCharType': 'separate',
          },
        },
      ],
    },
    {
      name: 'w:r',
      elements: [
        {
          name: 'w:rPr',
          elements: outputMarks,
        },
        {
          name: 'w:fldChar',
          attributes: {
            'w:fldCharType': 'end',
          },
        },
      ],
    },
  ];
};
const prepareCommentParaIds = (comment) => {
  const newComment = {
    ...comment,
    commentParaId: generateRandom32BitHex(),
  };
  return newComment;
};
const getCommentDefinition = (comment, commentId, allComments, editor) => {
  const translatedText = translateParagraphNode({ editor, node: comment.commentJSON });
  const attributes = {
    'w:id': String(commentId),
    'w:author': comment.creatorName || comment.importedAuthor?.name,
    'w:email': comment.creatorEmail || comment.importedAuthor?.email,
    'w:date': toIsoNoFractional(comment.createdTime),
    'w:initials': getInitials(comment.creatorName),
    'w:done': comment.resolvedTime ? '1' : '0',
    'w15:paraId': comment.commentParaId,
    'custom:internalId': comment.commentId || comment.internalId,
    'custom:trackedChange': comment.trackedChange,
    'custom:trackedChangeText': comment.trackedChangeText || null,
    'custom:trackedChangeType': comment.trackedChangeType,
    'custom:trackedDeletedText': comment.deletedText || null,
  };
  if (comment?.parentCommentId) {
    const parentComment = allComments.find((c) => c.commentId === comment.parentCommentId);
    attributes['w15:paraIdParent'] = parentComment.commentParaId;
  }
  return {
    type: 'element',
    name: 'w:comment',
    attributes,
    elements: [translatedText],
  };
};
const getInitials = (name) => {
  if (!name) return null;
  const preparedText = name.replace('(imported)', '').trim();
  const initials = preparedText
    .split(' ')
    .map((word) => word[0])
    .join('');
  return initials;
};
const toIsoNoFractional = (unixMillis) => {
  const date = new Date(unixMillis || Date.now());
  return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
};
const updateCommentsXml = (commentDefs = [], commentsXml) => {
  const newCommentsXml = carbonCopy(commentsXml);
  commentDefs.forEach((commentDef) => {
    const elements = commentDef.elements[0].elements;
    elements.unshift(COMMENT_REF);
    const paraId = commentDef.attributes['w15:paraId'];
    commentDef.elements[0].attributes['w14:paraId'] = paraId;
    commentDef.attributes = {
      'w:id': commentDef.attributes['w:id'],
      'w:author': commentDef.attributes['w:author'],
      'w:email': commentDef.attributes['w:email'],
      'w:date': commentDef.attributes['w:date'],
      'w:initials': commentDef.attributes['w:initials'],
      'custom:internalId': commentDef.attributes['custom:internalId'],
      'custom:trackedChange': commentDef.attributes['custom:trackedChange'],
      'custom:trackedChangeText': commentDef.attributes['custom:trackedChangeText'],
      'custom:trackedChangeType': commentDef.attributes['custom:trackedChangeType'],
      'custom:trackedDeletedText': commentDef.attributes['custom:trackedDeletedText'],
      'xmlns:custom': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
    };
  });
  newCommentsXml.elements[0].elements = commentDefs;
  return newCommentsXml;
};
const updateCommentsExtendedXml = (comments = [], commentsExtendedXml) => {
  const xmlCopy = carbonCopy(commentsExtendedXml);
  const commentsEx = comments.map((comment) => {
    const attributes = {
      'w15:paraId': comment.commentParaId,
      'w15:done': comment.resolvedTime ? '1' : '0',
    };
    const parentId = comment.parentCommentId;
    if (parentId) {
      const parentComment = comments.find((c) => c.commentId === parentId);
      attributes['w15:paraIdParent'] = parentComment.commentParaId;
    }
    return {
      type: 'element',
      name: 'w15:commentEx',
      attributes,
    };
  });
  xmlCopy.elements[0].elements = commentsEx;
  return xmlCopy;
};
const updateCommentsIdsAndExtensible = (comments = [], commentsIds, extensible) => {
  const documentIdsUpdated = carbonCopy(commentsIds);
  const extensibleUpdated = carbonCopy(extensible);
  documentIdsUpdated.elements[0].elements = [];
  extensibleUpdated.elements[0].elements = [];
  comments.forEach((comment) => {
    const newDurableId = generateRandom32BitHex();
    const newCommentIdDef = {
      type: 'element',
      name: 'w16cid:commentId',
      attributes: {
        'w16cid:paraId': comment.commentParaId,
        'w16cid:durableId': newDurableId,
      },
    };
    documentIdsUpdated.elements[0].elements.push(newCommentIdDef);
    const newExtensible = {
      type: 'element',
      name: 'w16cex:commentExtensible',
      attributes: {
        'w16cex:durableId': newDurableId,
        'w16cex:dateUtc': toIsoNoFractional(),
      },
    };
    extensibleUpdated.elements[0].elements.push(newExtensible);
  });
  return {
    documentIdsUpdated,
    extensibleUpdated,
  };
};
const generateConvertedXmlWithCommentFiles = (convertedXml) => {
  const newXml = carbonCopy(convertedXml);
  newXml['word/comments.xml'] = COMMENTS_XML_DEFINITIONS.COMMENTS_XML_DEF;
  newXml['word/commentsExtended.xml'] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENDED_XML_DEF;
  newXml['word/commentsExtensible.xml'] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENSIBLE_XML_DEF;
  newXml['word/commentsIds.xml'] = COMMENTS_XML_DEFINITIONS.COMMENTS_IDS_XML_DEF;
  newXml['[Content_Types].xml'] = COMMENTS_XML_DEFINITIONS.CONTENT_TYPES;
  return newXml;
};
const removeCommentsFilesFromConvertedXml = (convertedXml) => {
  const updatedXml = carbonCopy(convertedXml);
  delete updatedXml['word/comments.xml'];
  delete updatedXml['word/commentsExtended.xml'];
  delete updatedXml['word/commentsExtensible.xml'];
  delete updatedXml['word/commentsIds.xml'];
  return updatedXml;
};
const generateRelationship = (target) => {
  const relsDefault = COMMENTS_XML_DEFINITIONS.DOCUMENT_RELS_XML_DEF.elements[0].elements;
  const rel = relsDefault.find((rel2) => rel2.attributes.Target === target);
  return { ...rel };
};
const prepareCommentsXmlFilesForExport = ({ convertedXml, defs, commentsWithParaIds, exportType }) => {
  const relationships = [];
  if (exportType === 'clean') {
    const documentXml = removeCommentsFilesFromConvertedXml(convertedXml);
    return { documentXml, relationships };
  }
  const updatedXml = generateConvertedXmlWithCommentFiles(convertedXml);
  updatedXml['word/comments.xml'] = updateCommentsXml(defs, updatedXml['word/comments.xml']);
  relationships.push(generateRelationship('comments.xml'));
  updatedXml['word/commentsExtended.xml'] = updateCommentsExtendedXml(
    commentsWithParaIds,
    updatedXml['word/commentsExtended.xml'],
  );
  relationships.push(generateRelationship('commentsExtended.xml'));
  const { documentIdsUpdated, extensibleUpdated } = updateCommentsIdsAndExtensible(
    commentsWithParaIds,
    updatedXml['word/commentsIds.xml'],
    updatedXml['word/commentsExtensible.xml'],
  );
  updatedXml['word/commentsIds.xml'] = documentIdsUpdated;
  updatedXml['word/commentsExtensible.xml'] = extensibleUpdated;
  relationships.push(generateRelationship('commentsIds.xml'));
  relationships.push(generateRelationship('commentsExtensible.xml'));
  return {
    relationships,
    documentXml: updatedXml,
  };
};
const HYPERLINK_RELATIONSHIP_TYPE = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
const HEADER_RELATIONSHIP_TYPE = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header';
const FOOTER_RELATIONSHIP_TYPE = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer';
const REL_ID_NUMERIC_PATTERN = /rId|mi/g;
const getLargestRelationshipId = (relationships = []) => {
  const numericIds = relationships
    .map((rel) => Number(String(rel?.attributes?.Id ?? '').replace(REL_ID_NUMERIC_PATTERN, '')))
    .filter((value) => Number.isFinite(value));
  return numericIds.length ? Math.max(...numericIds) : 0;
};
const mergeRelationshipElements = (existingRelationships = [], newRelationships = []) => {
  if (!newRelationships?.length) return existingRelationships;
  let largestId = getLargestRelationshipId(existingRelationships);
  const seenIds = new Set(existingRelationships.map((rel) => rel?.attributes?.Id).filter(Boolean));
  for (const rel of newRelationships) {
    const id = rel?.attributes?.Id;
    if (!id || seenIds.has(id)) continue;
    const numeric = Number(String(id).replace(REL_ID_NUMERIC_PATTERN, ''));
    if (Number.isFinite(numeric) && numeric > largestId) largestId = numeric;
  }
  const additions = [];
  newRelationships.forEach((rel) => {
    if (!rel?.attributes) return;
    const attributes = rel.attributes;
    const currentId = attributes.Id || '';
    attributes.Target = attributes?.Target?.replace(/&/g, '&amp;');
    const existingTarget = existingRelationships.find((el) => el.attributes.Target === attributes.Target);
    const isNewHyperlink = attributes.Type === HYPERLINK_RELATIONSHIP_TYPE && currentId.length > 6;
    const isNewHeadFoot =
      (attributes.Type === HEADER_RELATIONSHIP_TYPE || attributes.Type === FOOTER_RELATIONSHIP_TYPE) &&
      currentId.length > 6;
    const hasSeenId = currentId && seenIds.has(currentId);
    if (!isNewHyperlink && !isNewHeadFoot && existingTarget) return;
    if (!currentId || hasSeenId) {
      let candidate = Math.max(largestId, 1);
      while (seenIds.has(`rId${candidate}`)) {
        candidate += 1;
      }
      attributes.Id = `rId${candidate}`;
      largestId = candidate;
    } else {
      const numeric = Number(String(currentId).replace(REL_ID_NUMERIC_PATTERN, ''));
      if (Number.isFinite(numeric) && numeric > largestId) largestId = numeric;
    }
    seenIds.add(attributes.Id);
    additions.push(rel);
  });
  return additions.length ? [...existingRelationships, ...additions] : existingRelationships;
};
const FONT_FAMILY_FALLBACKS = Object.freeze({
  swiss: 'Arial, sans-serif',
  roman: 'Times New Roman, serif',
  modern: 'Courier New, monospace',
  script: 'cursive',
  decorative: 'fantasy',
  system: 'system-ui',
  auto: 'sans-serif',
});
const DEFAULT_GENERIC_FALLBACK = 'sans-serif';
const DEFAULT_FONT_SIZE_PT = 10;
const collectRunDefaultProperties = (
  runProps,
  { allowOverrideTypeface = true, allowOverrideSize = true, themeResolver, state },
) => {
  if (!runProps?.elements?.length || !state) return;
  const fontsNode = runProps.elements.find((el) => el.name === 'w:rFonts');
  if (fontsNode?.attributes) {
    const themeName = fontsNode.attributes['w:asciiTheme'];
    if (themeName) {
      const themeInfo = themeResolver?.(themeName) || {};
      if ((allowOverrideTypeface || !state.typeface) && themeInfo.typeface) state.typeface = themeInfo.typeface;
      if ((allowOverrideTypeface || !state.panose) && themeInfo.panose) state.panose = themeInfo.panose;
    }
    const ascii = fontsNode.attributes['w:ascii'];
    if ((allowOverrideTypeface || !state.typeface) && ascii) {
      state.typeface = ascii;
    }
  }
  const sizeNode = runProps.elements.find((el) => el.name === 'w:sz');
  if (sizeNode?.attributes?.['w:val']) {
    const sizeTwips = Number(sizeNode.attributes['w:val']);
    if (Number.isFinite(sizeTwips)) {
      if (state.fallbackSzTwips === void 0) state.fallbackSzTwips = sizeTwips;
      const sizePt = sizeTwips / 2;
      if (allowOverrideSize || state.fontSizePt === void 0) state.fontSizePt = sizePt;
    }
  }
  const kernNode = runProps.elements.find((el) => el.name === 'w:kern');
  if (kernNode?.attributes?.['w:val']) {
    if (allowOverrideSize || state.kern === void 0) state.kern = kernNode.attributes['w:val'];
  }
};
const _SuperConverter = class _SuperConverter {
  constructor(params = null) {
    __privateAdd(this, _SuperConverter_instances);
    this.debug = params?.debug || false;
    this.declaration = null;
    this.documentAttributes = null;
    this.convertedXml = {};
    this.docx = params?.docx || [];
    this.media = params?.media || {};
    this.fonts = params?.fonts || {};
    this.addedMedia = {};
    this.comments = [];
    this.inlineDocumentFonts = [];
    this.docHiglightColors = /* @__PURE__ */ new Set([]);
    this.xml = params?.xml;
    this.declaration = null;
    this.numbering = {};
    this.numbering = null;
    this.pageStyles = null;
    this.initialJSON = null;
    this.headers = {};
    this.headerIds = { default: null, even: null, odd: null, first: null };
    this.headerEditors = [];
    this.footers = {};
    this.footerIds = { default: null, even: null, odd: null, first: null };
    this.footerEditors = [];
    this.linkedStyles = [];
    this.json = params?.json;
    this.tagsNotInSchema = ['w:body'];
    this.savedTagsToRestore = [];
    this.telemetry = params?.telemetry || null;
    this.documentInternalId = null;
    this.fileSource = params?.fileSource || null;
    this.documentId = params?.documentId || null;
    this.documentGuid = null;
    this.documentHash = null;
    this.documentModified = false;
    if (this.docx.length || this.xml) this.parseFromXml();
  }
  static getFontTableEntry(docx, fontName) {
    if (!docx || !fontName) return null;
    const fontTable = docx['word/fontTable.xml'];
    if (!fontTable?.elements?.length) return null;
    const fontsNode = fontTable.elements.find((el) => el.name === 'w:fonts');
    if (!fontsNode?.elements?.length) return null;
    return fontsNode.elements.find((el) => el?.attributes?.['w:name'] === fontName) || null;
  }
  static getFallbackFromFontTable(docx, fontName) {
    const fontEntry = _SuperConverter.getFontTableEntry(docx, fontName);
    const family = fontEntry?.elements?.find((child) => child.name === 'w:family')?.attributes?.['w:val'];
    if (!family) return null;
    const mapped = FONT_FAMILY_FALLBACKS[family.toLowerCase()];
    return mapped || DEFAULT_GENERIC_FALLBACK;
  }
  static toCssFontFamily(fontName, docx) {
    if (!fontName) return fontName;
    if (fontName.includes(',')) return fontName;
    const fallback = _SuperConverter.getFallbackFromFontTable(docx, fontName) || DEFAULT_GENERIC_FALLBACK;
    const normalizedFallbackParts = fallback
      .split(',')
      .map((part) => part.trim().toLowerCase())
      .filter(Boolean);
    if (normalizedFallbackParts.includes(fontName.trim().toLowerCase())) {
      return fallback;
    }
    return `${fontName}, ${fallback}`;
  }
  /**
   * Get the DocxHelpers object that contains utility functions for working with docx files.
   * @returns {import('./docx-helpers/docx-helpers.js').DocxHelpers} The DocxHelpers object.
   */
  get docxHelpers() {
    return DocxHelpers;
  }
  parseFromXml() {
    this.docx?.forEach((file) => {
      this.convertedXml[file.name] = this.parseXmlToJson(file.content);
      if (file.name === 'word/document.xml') {
        this.documentAttributes = this.convertedXml[file.name].elements[0]?.attributes;
      }
      if (file.name === 'word/styles.xml') {
        this.convertedXml[file.name] = addDefaultStylesIfMissing(this.convertedXml[file.name]);
      }
    });
    this.initialJSON = this.convertedXml['word/document.xml'];
    if (!this.initialJSON) this.initialJSON = this.parseXmlToJson(this.xml);
    this.declaration = this.initialJSON?.declaration;
    this.resolveDocumentGuid();
  }
  parseXmlToJson(xml) {
    const newXml = xml.replace(/(<w:t xml:space="preserve">)(\s+)(<\/w:t>)/g, '$1[[sdspace]]$2[[sdspace]]$3');
    return JSON.parse(xmljs.xml2json(newXml, null, 2));
  }
  /**
   * Generic method to get a stored custom property from docx
   * @static
   * @param {Array} docx - Array of docx file objects
   * @param {string} propertyName - Name of the property to retrieve
   * @returns {string|null} The property value or null if not found
   */
  static getStoredCustomProperty(docx, propertyName) {
    try {
      const customXml = docx.find((doc) => doc.name === 'docProps/custom.xml');
      if (!customXml) return null;
      const converter = new _SuperConverter();
      const content = customXml.content;
      const contentJson = converter.parseXmlToJson(content);
      const properties = contentJson.elements.find((el) => el.name === 'Properties');
      if (!properties.elements) return null;
      const property = properties.elements.find((el) => el.name === 'property' && el.attributes.name === propertyName);
      if (!property) return null;
      return property.elements[0].elements[0].text;
    } catch (e) {
      console.warn(`Error getting custom property ${propertyName}:`, e);
      return null;
    }
  }
  /**
   * Generic method to set a stored custom property in docx
   * @static
   * @param {Object} docx - The docx object to store the property in
   * @param {string} propertyName - Name of the property
   * @param {string|Function} value - Value or function that returns the value
   * @param {boolean} preserveExisting - If true, won't overwrite existing values
   * @returns {string} The stored value
   */
  static setStoredCustomProperty(docx, propertyName, value, preserveExisting = false) {
    const customLocation = 'docProps/custom.xml';
    if (!docx[customLocation]) docx[customLocation] = generateCustomXml();
    const customXml = docx[customLocation];
    const properties = customXml.elements?.find((el) => el.name === 'Properties');
    if (!properties) return null;
    if (!properties.elements) properties.elements = [];
    let property = properties.elements.find((el) => el.name === 'property' && el.attributes.name === propertyName);
    if (property && preserveExisting) {
      return property.elements[0].elements[0].text;
    }
    const finalValue = typeof value === 'function' ? value() : value;
    if (!property) {
      const existingPids = properties.elements
        .filter((el) => el.attributes?.pid)
        .map((el) => parseInt(el.attributes.pid, 10))
        .filter(Number.isInteger);
      const pid = existingPids.length > 0 ? Math.max(...existingPids) + 1 : 2;
      property = {
        type: 'element',
        name: 'property',
        attributes: {
          name: propertyName,
          fmtid: '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}',
          pid,
        },
        elements: [
          {
            type: 'element',
            name: 'vt:lpwstr',
            elements: [
              {
                type: 'text',
                text: finalValue,
              },
            ],
          },
        ],
      };
      properties.elements.push(property);
    } else {
      property.elements[0].elements[0].text = finalValue;
    }
    return finalValue;
  }
  static getStoredSuperdocVersion(docx) {
    return _SuperConverter.getStoredCustomProperty(docx, 'SuperdocVersion');
  }
  static setStoredSuperdocVersion(docx = this.convertedXml, version2 = '0.31.0') {
    return _SuperConverter.setStoredCustomProperty(docx, 'SuperdocVersion', version2, false);
  }
  /**
   * Get document GUID from docx files (static method)
   * @static
   * @param {Array} docx - Array of docx file objects
   * @returns {string|null} The document GUID
   */
  static extractDocumentGuid(docx) {
    try {
      const settingsXml = docx.find((doc) => doc.name === 'word/settings.xml');
      if (!settingsXml) return null;
      const converter = new _SuperConverter();
      const settingsJson = converter.parseXmlToJson(settingsXml.content);
      const settings = settingsJson.elements?.[0];
      if (!settings) return null;
      const docIdElement = settings.elements?.find((el) => el.name === 'w15:docId');
      if (docIdElement?.attributes?.['w15:val']) {
        return docIdElement.attributes['w15:val'].replace(/[{}]/g, '');
      }
    } catch {}
    return _SuperConverter.getStoredCustomProperty(docx, 'DocumentGuid');
  }
  /**
   * Get the permanent document GUID
   * @returns {string|null} The document GUID (only for modified documents)
   */
  getDocumentGuid() {
    return this.documentGuid;
  }
  /**
   * Get the SuperDoc version for this converter instance
   * @returns {string|null} The SuperDoc version or null if not available
   */
  getSuperdocVersion() {
    if (this.docx) {
      return _SuperConverter.getStoredSuperdocVersion(this.docx);
    }
    return null;
  }
  /**
   * Resolve existing document GUID (synchronous)
   */
  resolveDocumentGuid() {
    const microsoftGuid = this.getMicrosoftDocId();
    if (microsoftGuid) {
      this.documentGuid = microsoftGuid;
      return;
    }
    const customGuid = _SuperConverter.getStoredCustomProperty(this.docx, 'DocumentGuid');
    if (customGuid) {
      this.documentGuid = customGuid;
    }
  }
  /**
   * Get Microsoft's docId from settings.xml (READ ONLY)
   */
  getMicrosoftDocId() {
    this.getDocumentInternalId();
    if (this.documentInternalId) {
      return this.documentInternalId.replace(/[{}]/g, '');
    }
    return null;
  }
  /**
   * Get document identifier (GUID or hash) - async for lazy hash generation
   */
  async getDocumentIdentifier() {
    if (this.documentGuid) {
      return this.documentGuid;
    }
    if (!this.documentHash && this.fileSource) {
      this.documentHash = await __privateMethod(this, _SuperConverter_instances, generateDocumentHash_fn).call(this);
    }
    return this.documentHash;
  }
  /**
   * Promote from hash to GUID on first edit
   */
  promoteToGuid() {
    if (this.documentGuid) return this.documentGuid;
    this.documentGuid = this.getMicrosoftDocId() || v4();
    this.documentModified = true;
    this.documentHash = null;
    return this.documentGuid;
  }
  getDocumentDefaultStyles() {
    const styles = this.convertedXml['word/styles.xml'];
    const styleRoot = styles?.elements?.[0];
    const styleElements = styleRoot?.elements || [];
    if (!styleElements.length) return {};
    const defaults = styleElements.find((el) => el.name === 'w:docDefaults');
    const normalStyle = styleElements.find((el) => el.name === 'w:style' && el.attributes?.['w:styleId'] === 'Normal');
    const defaultsState = {
      typeface: void 0,
      panose: void 0,
      fontSizePt: void 0,
      kern: void 0,
      fallbackSzTwips: void 0,
    };
    const docDefaultRun = defaults?.elements?.find((el) => el.name === 'w:rPrDefault');
    const docDefaultProps = docDefaultRun?.elements?.find((el) => el.name === 'w:rPr') ?? docDefaultRun;
    collectRunDefaultProperties(docDefaultProps, {
      allowOverrideTypeface: true,
      allowOverrideSize: true,
      themeResolver: (theme) => this.getThemeInfo(theme),
      state: defaultsState,
    });
    const normalRunProps = normalStyle?.elements?.find((el) => el.name === 'w:rPr') ?? null;
    collectRunDefaultProperties(normalRunProps, {
      allowOverrideTypeface: true,
      allowOverrideSize: true,
      themeResolver: (theme) => this.getThemeInfo(theme),
      state: defaultsState,
    });
    if (defaultsState.fontSizePt === void 0) {
      if (Number.isFinite(defaultsState.fallbackSzTwips)) defaultsState.fontSizePt = defaultsState.fallbackSzTwips / 2;
      else defaultsState.fontSizePt = DEFAULT_FONT_SIZE_PT;
    }
    const fontFamilyCss = defaultsState.typeface
      ? _SuperConverter.toCssFontFamily(defaultsState.typeface, this.convertedXml)
      : void 0;
    const result = {};
    if (defaultsState.fontSizePt !== void 0) result.fontSizePt = defaultsState.fontSizePt;
    if (defaultsState.kern !== void 0) result.kern = defaultsState.kern;
    if (defaultsState.typeface) result.typeface = defaultsState.typeface;
    if (defaultsState.panose) result.panose = defaultsState.panose;
    if (fontFamilyCss) result.fontFamilyCss = fontFamilyCss;
    return result;
  }
  getDocumentFonts() {
    const inlineDocumentFonts = [...new Set(this.inlineDocumentFonts || [])];
    const fontTable = this.convertedXml['word/fontTable.xml'];
    if (!fontTable) {
      return inlineDocumentFonts;
    }
    const wFonts = fontTable.elements?.find((element) => element.name === 'w:fonts');
    if (!wFonts) {
      return inlineDocumentFonts;
    }
    if (!wFonts.elements) {
      return inlineDocumentFonts;
    }
    const fontsInFontTable = wFonts.elements
      .filter((element) => element.name === 'w:font')
      .map((element) => element.attributes['w:name']);
    const allFonts = [...inlineDocumentFonts, ...fontsInFontTable];
    return [...new Set(allFonts)];
  }
  getFontFaceImportString() {
    const fontTable = this.convertedXml['word/fontTable.xml'];
    if (!fontTable || !Object.keys(this.fonts).length) return;
    const fonts = fontTable.elements.find((el) => el.name === 'w:fonts');
    const embededFonts = fonts?.elements.filter((el) =>
      el.elements?.some((nested) => nested?.attributes && nested.attributes['r:id'] && nested.attributes['w:fontKey']),
    );
    const fontsToInclude = embededFonts?.reduce((acc, cur) => {
      const embedElements = cur.elements
        .filter((el) => el.name.startsWith('w:embed'))
        ?.map((el) => ({ ...el, fontFamily: cur.attributes['w:name'] }));
      return [...acc, ...embedElements];
    }, []);
    const rels = this.convertedXml['word/_rels/fontTable.xml.rels'];
    const relationships = rels?.elements.find((el) => el.name === 'Relationships') || {};
    const { elements } = relationships;
    const fontsImported = [];
    let styleString = '';
    for (const font of fontsToInclude) {
      const filePath = elements.find((el) => el.attributes.Id === font.attributes['r:id'])?.attributes?.Target;
      if (!filePath) return;
      const fontUint8Array = this.fonts[`word/${filePath}`];
      const fontBuffer = fontUint8Array?.buffer;
      if (!fontBuffer) return;
      const ttfBuffer = deobfuscateFont(fontBuffer, font.attributes['w:fontKey']);
      if (!ttfBuffer) return;
      const blob = new Blob([ttfBuffer], { type: 'font/ttf' });
      const fontUrl = URL.createObjectURL(blob);
      const isNormal = font.name.includes('Regular');
      const isBold = font.name.includes('Bold');
      const isItalic = font.name.includes('Italic');
      const isLight = font.name.includes('Light');
      const fontWeight = isNormal ? 'normal' : isBold ? 'bold' : isLight ? '200' : 'normal';
      if (!fontsImported.includes(font.fontFamily)) {
        fontsImported.push(font.fontFamily);
      }
      styleString += `
        @font-face {
          font-style: ${isItalic ? 'italic' : 'normal'};
          font-weight: ${fontWeight};
          font-display: swap;
          font-family: ${font.fontFamily};
          src: url(${fontUrl}) format('truetype');
        }
      `;
    }
    return {
      styleString,
      fontsImported,
    };
  }
  getDocumentInternalId() {
    const settingsLocation = 'word/settings.xml';
    if (!this.convertedXml[settingsLocation]) {
      return;
    }
    const settings = this.convertedXml[settingsLocation];
    if (!settings.elements?.[0]?.elements?.length) {
      return;
    }
    const w15DocId = settings.elements[0].elements.find((el) => el.name === 'w15:docId');
    this.documentInternalId = w15DocId?.attributes?.['w15:val'];
  }
  createDocumentIdElement() {
    const docId = v4().toUpperCase();
    this.documentInternalId = docId;
    return {
      type: 'element',
      name: 'w15:docId',
      attributes: {
        'w15:val': `{${docId}}`,
      },
    };
  }
  getThemeInfo(themeName) {
    themeName = themeName.toLowerCase();
    const theme1 = this.convertedXml['word/theme/theme1.xml'];
    if (!theme1) return {};
    const themeData = theme1.elements.find((el) => el.name === 'a:theme');
    const themeElements = themeData.elements.find((el) => el.name === 'a:themeElements');
    const fontScheme = themeElements.elements.find((el) => el.name === 'a:fontScheme');
    let fonts;
    if (themeName.startsWith('major')) {
      fonts = fontScheme.elements.find((el) => el.name === 'a:majorFont').elements[0];
    } else if (themeName.startsWith('minor')) {
      fonts = fontScheme.elements.find((el) => el.name === 'a:minorFont').elements[0];
    }
    const { typeface, panose } = fonts.attributes;
    return { typeface, panose };
  }
  getSchema(editor) {
    let result;
    try {
      this.getDocumentInternalId();
      result = createDocumentJson({ ...this.convertedXml, media: this.media }, this, editor);
    } catch (error) {
      editor?.emit('exception', { error, editor });
    }
    if (result) {
      this.savedTagsToRestore.push({ ...result.savedTagsToRestore });
      this.pageStyles = result.pageStyles;
      this.numbering = result.numbering;
      this.comments = result.comments;
      this.linkedStyles = result.linkedStyles;
      this.inlineDocumentFonts = result.inlineDocumentFonts;
      return result.pmDoc;
    } else {
      return null;
    }
  }
  schemaToXml(data, debug = false) {
    const exporter = new DocxExporter(this);
    return exporter.schemaToXml(data, debug);
  }
  async exportToDocx(
    jsonData,
    editorSchema,
    documentMedia,
    isFinalDoc = false,
    commentsExportType,
    comments = [],
    editor,
    exportJsonOnly = false,
    fieldsHighlightColor,
  ) {
    const commentsWithParaIds = comments.map((c) => prepareCommentParaIds(c));
    const commentDefinitions = commentsWithParaIds.map((c, index) =>
      getCommentDefinition(c, index, commentsWithParaIds, editor),
    );
    const { result, params } = this.exportToXmlJson({
      data: jsonData,
      editorSchema,
      comments,
      commentDefinitions,
      commentsExportType,
      isFinalDoc,
      editor,
      fieldsHighlightColor,
    });
    if (exportJsonOnly) return result;
    const exporter = new DocxExporter(this);
    const xml = exporter.schemaToXml(result);
    await __privateMethod(this, _SuperConverter_instances, exportProcessMediaFiles_fn).call(
      this,
      {
        ...documentMedia,
        ...params.media,
        ...this.media,
      },
      editor,
    );
    let updatedXml = { ...this.convertedXml };
    let commentsRels = [];
    if (comments.length) {
      const { documentXml, relationships } = __privateMethod(
        this,
        _SuperConverter_instances,
        prepareCommentsXmlFilesForExport_fn,
      ).call(this, {
        defs: params.exportedCommentDefs,
        exportType: commentsExportType,
        commentsWithParaIds,
      });
      updatedXml = { ...documentXml };
      commentsRels = relationships;
    }
    this.convertedXml = { ...this.convertedXml, ...updatedXml };
    const headFootRels = __privateMethod(this, _SuperConverter_instances, exportProcessHeadersFooters_fn).call(this, {
      isFinalDoc,
    });
    __privateMethod(this, _SuperConverter_instances, exportProcessNewRelationships_fn).call(this, [
      ...params.relationships,
      ...commentsRels,
      ...headFootRels,
    ]);
    _SuperConverter.setStoredSuperdocVersion(this.convertedXml);
    if (this.documentModified || this.documentGuid) {
      if (!this.documentGuid) {
        this.documentGuid = this.getMicrosoftDocId() || v4();
      }
      _SuperConverter.setStoredCustomProperty(this.convertedXml, 'DocumentGuid', this.documentGuid, true);
    }
    __privateMethod(this, _SuperConverter_instances, exportNumberingFile_fn).call(this, params);
    return xml;
  }
  exportToXmlJson({
    data,
    editorSchema,
    comments,
    commentDefinitions,
    commentsExportType = 'clean',
    isFinalDoc = false,
    editor,
    isHeaderFooter = false,
    fieldsHighlightColor = null,
  }) {
    const bodyNode = this.savedTagsToRestore.find((el) => el.name === 'w:body');
    const [result, params] = exportSchemaToJson({
      node: data,
      bodyNode,
      relationships: [],
      documentMedia: {},
      media: {},
      isFinalDoc,
      editorSchema,
      converter: this,
      pageStyles: this.pageStyles,
      comments,
      commentsExportType,
      exportedCommentDefs: commentDefinitions,
      editor,
      isHeaderFooter,
      fieldsHighlightColor,
    });
    return { result, params };
  }
  // Deprecated methods for backward compatibility
  static getStoredSuperdocId(docx) {
    console.warn('getStoredSuperdocId is deprecated, use getDocumentGuid instead');
    return _SuperConverter.extractDocumentGuid(docx);
  }
  static updateDocumentVersion(docx, version2) {
    console.warn('updateDocumentVersion is deprecated, use setStoredSuperdocVersion instead');
    return _SuperConverter.setStoredSuperdocVersion(docx, version2);
  }
};
_SuperConverter_instances = new WeakSet();
generateDocumentHash_fn = async function () {
  if (!this.fileSource) return `HASH-${Date.now()}`;
  try {
    let buffer;
    if (Buffer.isBuffer(this.fileSource)) {
      buffer = this.fileSource;
    } else if (this.fileSource instanceof ArrayBuffer) {
      buffer = Buffer.from(this.fileSource);
    } else if (this.fileSource instanceof Blob || this.fileSource instanceof File) {
      const arrayBuffer = await this.fileSource.arrayBuffer();
      buffer = Buffer.from(arrayBuffer);
    } else {
      return `HASH-${Date.now()}`;
    }
    const hash = crc32(buffer);
    return `HASH-${hash.toString('hex').toUpperCase()}`;
  } catch (e) {
    console.warn('Could not generate document hash:', e);
    return `HASH-${Date.now()}`;
  }
};
exportNumberingFile_fn = function () {
  const numberingPath = 'word/numbering.xml';
  let numberingXml = this.convertedXml[numberingPath];
  const newNumbering = this.numbering;
  if (!numberingXml) numberingXml = baseNumbering;
  const currentNumberingXml = numberingXml.elements[0];
  const newAbstracts = Object.values(newNumbering.abstracts).map((entry) => entry);
  const newNumDefs = Object.values(newNumbering.definitions).map((entry) => entry);
  currentNumberingXml.elements = [...newAbstracts, ...newNumDefs];
  this.convertedXml[numberingPath] = numberingXml;
};
/**
 * Update comments files and relationships depending on export type
 */
prepareCommentsXmlFilesForExport_fn = function ({ defs, exportType, commentsWithParaIds }) {
  const { documentXml, relationships } = prepareCommentsXmlFilesForExport({
    exportType,
    convertedXml: this.convertedXml,
    defs,
    commentsWithParaIds,
  });
  return { documentXml, relationships };
};
exportProcessHeadersFooters_fn = function ({ isFinalDoc = false }) {
  const relsData = this.convertedXml['word/_rels/document.xml.rels'];
  const relationships = relsData.elements.find((x) => x.name === 'Relationships');
  const newDocRels = [];
  Object.entries(this.headers).forEach(([id, header], index) => {
    const fileName =
      relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `header${index + 1}.xml`;
    const headerEditor = this.headerEditors.find((item) => item.id === id);
    if (!headerEditor) return;
    const { result, params } = this.exportToXmlJson({
      data: header,
      editor: headerEditor.editor,
      editorSchema: headerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc,
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: 'w:hdr',
            type: 'element',
            elements: [],
          },
        ],
      };
      newDocRels.push({
        type: 'element',
        name: 'Relationship',
        attributes: {
          Id: id,
          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header',
          Target: fileName,
        },
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params.relationships.length) {
      const relationships2 =
        this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x) => x.name === 'Relationships')?.elements ||
        [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: 'Relationships',
            attributes: {
              xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',
            },
            elements: [...relationships2, ...params.relationships],
          },
        ],
      };
    }
  });
  Object.entries(this.footers).forEach(([id, footer], index) => {
    const fileName =
      relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `footer${index + 1}.xml`;
    const footerEditor = this.footerEditors.find((item) => item.id === id);
    if (!footerEditor) return;
    const { result, params } = this.exportToXmlJson({
      data: footer,
      editor: footerEditor.editor,
      editorSchema: footerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc,
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: 'w:ftr',
            type: 'element',
            elements: [],
          },
        ],
      };
      newDocRels.push({
        type: 'element',
        name: 'Relationship',
        attributes: {
          Id: id,
          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer',
          Target: fileName,
        },
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params.relationships.length) {
      const relationships2 =
        this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x) => x.name === 'Relationships')?.elements ||
        [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: 'Relationships',
            attributes: {
              xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',
            },
            elements: [...relationships2, ...params.relationships],
          },
        ],
      };
    }
  });
  return newDocRels;
};
exportProcessNewRelationships_fn = function (rels = []) {
  const relsData = this.convertedXml['word/_rels/document.xml.rels'];
  const relationships = relsData.elements.find((x) => x.name === 'Relationships');
  relationships.elements = mergeRelationshipElements(relationships.elements, rels);
};
exportProcessMediaFiles_fn = async function (media = {}) {
  const processedData = {
    ...(this.convertedXml.media || {}),
  };
  for (const [filePath, value] of Object.entries(media)) {
    if (value == null) continue;
    processedData[filePath] = await getArrayBufferFromUrl(value);
  }
  this.convertedXml.media = processedData;
  this.media = this.convertedXml.media;
  this.addedMedia = {
    ...processedData,
  };
};
__publicField(
  _SuperConverter,
  'allowedElements',
  Object.freeze({
    'w:document': 'doc',
    'w:body': 'body',
    'w:p': 'paragraph',
    'w:r': 'run',
    'w:t': 'text',
    'w:delText': 'text',
    'w:br': 'lineBreak',
    'w:tbl': 'table',
    'w:tr': 'tableRow',
    'w:tc': 'tableCell',
    'w:drawing': 'drawing',
    'w:bookmarkStart': 'bookmarkStart',
    // 'w:tab': 'tab',
    // Formatting only
    'w:sectPr': 'sectionProperties',
    'w:rPr': 'runProperties',
    // Comments
    'w:commentRangeStart': 'commentRangeStart',
    'w:commentRangeEnd': 'commentRangeEnd',
    'w:commentReference': 'commentReference',
  }),
);
__publicField(_SuperConverter, 'markTypes', [
  { name: 'w:b', type: 'bold', property: 'value' },
  // { name: 'w:bCs', type: 'bold' },
  { name: 'w:i', type: 'italic' },
  // { name: 'w:iCs', type: 'italic' },
  { name: 'w:u', type: 'underline', mark: 'underline', property: 'underlineType' },
  { name: 'w:strike', type: 'strike', mark: 'strike', property: 'value' },
  { name: 'w:color', type: 'color', mark: 'textStyle', property: 'color' },
  { name: 'w:sz', type: 'fontSize', mark: 'textStyle', property: 'fontSize' },
  // { name: 'w:szCs', type: 'fontSize', mark: 'textStyle', property: 'fontSize' },
  { name: 'w:rFonts', type: 'fontFamily', mark: 'textStyle', property: 'fontFamily' },
  { name: 'w:rStyle', type: 'styleId', mark: 'textStyle', property: 'styleId' },
  { name: 'w:jc', type: 'textAlign', mark: 'textStyle', property: 'textAlign' },
  { name: 'w:ind', type: 'textIndent', mark: 'textStyle', property: 'textIndent' },
  { name: 'w:spacing', type: 'lineHeight', mark: 'textStyle', property: 'lineHeight' },
  { name: 'w:spacing', type: 'letterSpacing', mark: 'textStyle', property: 'letterSpacing' },
  { name: 'link', type: 'link', mark: 'link', property: 'href' },
  { name: 'w:highlight', type: 'highlight', mark: 'highlight', property: 'color' },
  { name: 'w:shd', type: 'highlight', mark: 'highlight', property: 'color' },
  { name: 'w:caps', type: 'textTransform', mark: 'textStyle', property: 'textTransform' },
]);
__publicField(
  _SuperConverter,
  'propertyTypes',
  Object.freeze({
    'w:pPr': 'paragraphProperties',
    'w:rPr': 'runProperties',
    'w:sectPr': 'sectionProperties',
    'w:numPr': 'numberingProperties',
    'w:tcPr': 'tableCellProperties',
  }),
);
__publicField(
  _SuperConverter,
  'elements',
  /* @__PURE__ */ new Set(['w:document', 'w:body', 'w:p', 'w:r', 'w:t', 'w:delText']),
);
let SuperConverter = _SuperConverter;
function generateCustomXml() {
  return DEFAULT_CUSTOM_XML;
}
class OxmlNode extends Node$1 {
  /**
   * @param {import('./types/index.js').OxmlNodeConfig} config
   */
  constructor(config2) {
    super(config2);
    /** @type {string} */
    __publicField(this, 'oXmlName');
    this.oXmlName = config2.oXmlName;
  }
  /**
   * Factory method to construct a new OxmlNode instance.
   *
   * @param {import('./types/index.js').OxmlNodeConfig} config
   * @returns {OxmlNode} A new OxmlNode instance.
   */
  static create(config2) {
    return new OxmlNode(config2);
  }
}
const first = (commands2) => (props) => {
  const items = typeof commands2 === 'function' ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) return true;
  }
  return false;
};
const command = (fn) => (props) => fn(props);
const insertTabChar =
  () =>
  ({ tr }) => {
    tr.insertText('	', tr.selection.from, tr.selection.to);
    return true;
  };
const insertTabCharacter = ({ tr, state, dispatch }) => {
  const { from } = tr.selection;
  const tabText = state.schema.text('	');
  tr = tr.replaceSelectionWith(tabText);
  tr = tr.setSelection(TextSelection.create(tr.doc, from + 1));
  if (dispatch) dispatch(tr);
  return true;
};
const insertTabNode =
  () =>
  ({ tr, state, dispatch }) => {
    const newPos = tr.selection.from;
    const tabNode = state.schema?.nodes?.tab?.create();
    if (!tabNode) return insertTabCharacter({ tr, state, dispatch });
    tr.insert(newPos, tabNode);
    if (dispatch) dispatch(tr);
    return true;
  };
const setMeta =
  (key2, value) =>
  ({ tr }) => {
    tr.setMeta(key2, value);
    return true;
  };
const ensureMarks = (state, splittableMarks) => {
  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());
  if (marks) {
    const filtered = marks.filter((m) => splittableMarks?.includes(m.type.name));
    state.tr.ensureMarks(filtered);
  }
};
const splitBlock =
  ({ keepMarks = true } = {}) =>
  (props) => {
    const { tr, state, dispatch, editor } = props;
    const { selection, doc } = tr;
    const { $from, $to } = selection;
    const extensionAttrs = editor.extensionService.attributes;
    const newAttrs = Attribute.getSplittedAttributes(extensionAttrs, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc, $from.pos)) return false;
      if (dispatch) {
        if (keepMarks) ensureMarks(state, editor.extensionService.splittableMarks);
        tr.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) return false;
    if (dispatch) {
      const atEnd = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof TextSelection) tr.deleteSelection();
      const deflt = $from.depth === 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types = atEnd && deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types = deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          const first2 = tr.mapping.map($from.before());
          const $first = tr.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) ensureMarks(state, editor.extensionService.splittableMarks);
      tr.scrollIntoView();
    }
    return true;
  };
const liftEmptyBlock =
  () =>
  ({ state, dispatch }) =>
    liftEmptyBlock$1(state, dispatch);
const createParagraphNear =
  () =>
  ({ state, dispatch }) => {
    return createParagraphNear$1(state, dispatch);
  };
const newlineInCode =
  () =>
  ({ state, dispatch }) =>
    newlineInCode$1(state, dispatch);
const exitCode =
  () =>
  ({ state, dispatch }) => {
    return exitCode$1(state, dispatch);
  };
function canSetMark(editor, state, tr, newMarkType) {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  let cursor = null;
  if (isTextSelection()) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = state.storedMarks ?? cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  return selection.ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark =
      $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) return false;
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType =
          !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark =
  (typeOrName, attributes = {}) =>
  ({ tr, state, dispatch, editor }) => {
    let { selection } = tr;
    if (editor.options.isHeaderOrFooter) {
      selection = editor.options.lastSelection;
    }
    const { empty, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty) {
        const oldAttributes = Attribute.getMarkAttributes(state, type);
        tr.addStoredMark(
          type.create({
            ...oldAttributes,
            ...attributes,
          }),
        );
      } else {
        ranges.forEach((range) => {
          const from = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from, to, (node, pos) => {
            const trimmedFrom = Math.max(pos, from);
            const trimmedTo = Math.min(pos + node.nodeSize, to);
            const someHasMark = node.marks.find((mark) => mark.type === type);
            if (someHasMark) {
              node.marks.forEach((mark) => {
                if (type === mark.type) {
                  tr.addMark(
                    trimmedFrom,
                    trimmedTo,
                    type.create({
                      ...mark.attrs,
                      ...attributes,
                    }),
                  );
                }
              });
            } else {
              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(editor, state, tr, type);
  };
const unsetMark =
  (typeOrName, options = {}) =>
  ({ tr, state, dispatch, editor }) => {
    const { extendEmptyMarkRange = false } = options;
    let { selection } = tr;
    if (editor.options.isHeaderOrFooter) {
      selection = editor.options.lastSelection;
    }
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty, ranges } = selection;
    if (!dispatch) return true;
    if (empty && extendEmptyMarkRange) {
      let { from, to } = selection;
      const attrs = $from.marks().find((mark) => mark.type === type)?.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from = range.from;
        to = range.to;
      }
      tr.removeMark(from, to, type);
    } else {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr.removeStoredMark(type);
    return true;
  };
const unsetAllMarks =
  () =>
  ({ tr, dispatch, editor }) => {
    let { selection } = tr;
    if (editor.options.isHeaderOrFooter) {
      selection = editor.options.lastSelection;
    }
    const { empty, ranges } = selection;
    if (empty) return true;
    if (dispatch) {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
const toggleMark =
  (typeOrName, attrs = {}, options = {}) =>
  ({ state, commands: commands2 }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive2 = isMarkActive(state, type, attrs);
    if (isActive2) return commands2.unsetMark(type, { extendEmptyMarkRange });
    return commands2.setMark(type, attrs);
  };
const toggleMarkCascade =
  (markName, options = {}) =>
  ({ state, chain, editor }) => {
    const {
      negationAttrs = { value: '0' },
      isNegation = (attrs) => attrs?.value === '0',
      styleDetector = defaultStyleDetector,
      extendEmptyMarkRange = true,
    } = options;
    const selectionMarks = getMarksFromSelection(state) || [];
    const inlineMarks = selectionMarks.filter((m) => m.type?.name === markName);
    const hasNegation = inlineMarks.some((m) => isNegation(m.attrs || {}));
    const hasInline = inlineMarks.some((m) => !isNegation(m.attrs || {}));
    const styleOn = styleDetector({ state, selectionMarks, markName, editor });
    const cmdChain = chain();
    if (hasNegation) return cmdChain.unsetMark(markName, { extendEmptyMarkRange }).run();
    if (hasInline && styleOn) {
      return cmdChain
        .unsetMark(markName, { extendEmptyMarkRange })
        .setMark(markName, negationAttrs, { extendEmptyMarkRange })
        .run();
    }
    if (hasInline) return cmdChain.unsetMark(markName, { extendEmptyMarkRange }).run();
    if (styleOn) return cmdChain.setMark(markName, negationAttrs, { extendEmptyMarkRange }).run();
    return cmdChain.setMark(markName, {}, { extendEmptyMarkRange }).run();
  };
function defaultStyleDetector({ state, selectionMarks, markName, editor }) {
  try {
    const styleId = getEffectiveStyleId(state, selectionMarks);
    if (!styleId || !editor?.converter?.linkedStyles) return false;
    const styles = editor.converter.linkedStyles;
    const seen = /* @__PURE__ */ new Set();
    let current = styleId;
    const key2 = mapMarkToStyleKey(markName);
    while (current && !seen.has(current)) {
      seen.add(current);
      const style = styles.find((s2) => s2.id === current);
      const def = style?.definition?.styles || {};
      if (key2 in def) {
        const raw = def[key2];
        if (raw === void 0) return true;
        const val = raw?.value ?? raw;
        return isStyleTokenEnabled(val);
      }
      current = style?.definition?.attrs?.basedOn || null;
    }
    return false;
  } catch {
    return false;
  }
}
function getEffectiveStyleId(state, selectionMarks) {
  const sidFromMarks = getStyleIdFromMarks(selectionMarks);
  if (sidFromMarks) return sidFromMarks;
  const $from = state.selection.$from;
  const before = $from.nodeBefore;
  const after = $from.nodeAfter;
  if (before && before.marks) {
    const sid = getStyleIdFromMarks(before.marks);
    if (sid) return sid;
  }
  if (after && after.marks) {
    const sid = getStyleIdFromMarks(after.marks);
    if (sid) return sid;
  }
  const ts = selectionMarks.find((m) => m.type?.name === 'textStyle' && m.attrs?.styleId);
  if (ts) return ts.attrs.styleId;
  const pos = state.selection.$from.pos;
  const $pos = state.doc.resolve(pos);
  for (let d2 = $pos.depth; d2 >= 0; d2--) {
    const n = $pos.node(d2);
    if (n?.type?.name === 'paragraph') return n.attrs?.styleId || null;
  }
  return null;
}
function getStyleIdFromMarks(marks) {
  if (!Array.isArray(marks)) return null;
  const textStyleMark = marks.find((m) => m.type?.name === 'textStyle' && m.attrs?.styleId);
  if (textStyleMark) return textStyleMark.attrs.styleId;
  return null;
}
function mapMarkToStyleKey(markName) {
  if (markName === 'textStyle' || markName === 'color') return 'color';
  return markName;
}
function isStyleTokenEnabled(val) {
  if (val === false || val === 0) return false;
  if (typeof val === 'string') {
    const normalized = val.trim().toLowerCase();
    if (!normalized) return false;
    if (['0', 'false', 'none', 'inherit', 'transparent'].includes(normalized)) return false;
    return true;
  }
  return !!val;
}
const clearNodes =
  () =>
  ({ state, tr, dispatch }) => {
    const { selection } = tr;
    const { ranges } = selection;
    if (!dispatch) return true;
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
        if (node.type.isText) return;
        const { doc, mapping } = tr;
        const $mappedFrom = doc.resolve(mapping.map(pos));
        const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) return;
        const targetLiftDepth = liftTarget(nodeRange);
        if (node.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
const setNode =
  (typeOrName, attrs = {}) =>
  ({ state, dispatch, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    if (!type.isTextblock) return false;
    return chain()
      .command(({ commands: commands2 }) => {
        const canSetBlock = setBlockType(type, attrs)(state);
        if (canSetBlock) return true;
        return commands2.clearNodes();
      })
      .command(({ state: updatedState }) => {
        return setBlockType(type, attrs)(updatedState, dispatch);
      })
      .run();
  };
const toggleNode =
  (typeOrName, toggleTypeOrName, attrs = {}) =>
  ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attrs);
    if (isActive2) return commands2.setNode(toggleType);
    return commands2.setNode(type, attrs);
  };
const selectAll =
  () =>
  ({ state, dispatch }) =>
    selectAll$1(state, dispatch);
const deleteSelection =
  () =>
  ({ state, tr, dispatch }) => {
    const { from, to, empty } = state.selection;
    if (empty) {
      return deleteSelection$1(state, dispatch);
    }
    let hasListContent = false;
    state.doc.nodesBetween(from, to, (node) => {
      if (node.type.name === 'orderedList' || node.type.name === 'bulletList' || node.type.name === 'listItem') {
        hasListContent = true;
        return false;
      }
    });
    if (hasListContent) {
      const transaction = tr || state.tr;
      transaction.deleteRange(from, to);
      if (dispatch) {
        dispatch(transaction);
      }
      return true;
    }
    return deleteSelection$1(state, dispatch);
  };
const updateAttributes =
  (typeOrName, attrs = {}) =>
  ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(
      typeof typeOrName === 'string' ? typeOrName : typeOrName.name,
      state.schema,
    );
    if (!schemaType) return false;
    if (schemaType === 'node') {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === 'mark') {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach((range) => {
        const from = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, { ...node.attrs, ...attrs });
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                const trimmedFrom = Math.max(pos, from);
                const trimmedTo = Math.min(pos + node.nodeSize, to);
                tr.addMark(trimmedFrom, trimmedTo, markType.create({ ...mark.attrs, ...attrs }));
              }
            });
          }
        });
      });
    }
    return true;
  };
const resetAttributes =
  (typeOrName, attrs) =>
  ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(
      typeof typeOrName === 'string' ? typeOrName : typeOrName.name,
      state.schema,
    );
    if (!schemaType) return false;
    if (schemaType === 'node') {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === 'mark') {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attrs));
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attrs)));
              }
            });
          }
        });
      });
    }
    return true;
  };
const joinUp =
  () =>
  ({ state, dispatch }) =>
    joinUp$1(state, dispatch);
const joinDown =
  () =>
  ({ state, dispatch }) =>
    joinDown$1(state, dispatch);
const joinBackward =
  () =>
  ({ state, dispatch }) => {
    const { selection, doc } = state;
    const { $from } = selection;
    if (!$from.parent.isTextblock || $from.parentOffset > 0) {
      return joinBackward$1(state, dispatch);
    }
    const beforePos = $from.before();
    const nodeBefore = doc.resolve(beforePos).nodeBefore;
    const nodeAfter = doc.resolve(beforePos).nodeAfter;
    const isList2 = (node) => node?.type.name === 'orderedList' || node?.type.name === 'bulletList';
    if (isList2(nodeBefore) || isList2(nodeAfter)) {
      return false;
    }
    return joinBackward$1(state, dispatch);
  };
const joinForward =
  () =>
  ({ state, dispatch }) => {
    const { selection, doc } = state;
    const { $from } = selection;
    if (!$from.parent.isTextblock || $from.parentOffset > 0) {
      return joinForward$1(state, dispatch);
    }
    const beforePos = $from.before();
    const nodeBefore = doc.resolve(beforePos).nodeBefore;
    const nodeAfter = doc.resolve(beforePos).nodeAfter;
    const isList2 = (node) => node?.type.name === 'orderedList' || node?.type.name === 'bulletList';
    if (isList2(nodeBefore) || isList2(nodeAfter)) {
      return false;
    }
    return joinForward$1(state, dispatch);
  };
const selectNodeBackward =
  () =>
  ({ state, dispatch }) => {
    return selectNodeBackward$1(state, dispatch);
  };
const selectNodeForward =
  () =>
  ({ state, dispatch }) =>
    selectNodeForward$1(state, dispatch);
const selectTextblockStart =
  () =>
  ({ state, dispatch }) =>
    selectTextblockStart$1(state, dispatch);
const selectTextblockEnd =
  () =>
  ({ state, dispatch }) =>
    selectTextblockEnd$1(state, dispatch);
const insertContent =
  (value, options = {}) =>
  ({ tr, state, commands: commands2, editor }) => {
    if (options.contentType) {
      const validTypes = ['html', 'markdown', 'text', 'schema'];
      if (!validTypes.includes(options.contentType)) {
        console.error(`[insertContent] Invalid contentType: "${options.contentType}". Use: ${validTypes.join(', ')}`);
        return false;
      }
      try {
        const processedDoc = processContent({
          content: value,
          type: options.contentType,
          schema: state.schema,
        });
        const jsonContent = processedDoc.toJSON();
        const ok = commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, jsonContent, options);
        if (ok && (options.contentType === 'html' || options.contentType === 'markdown')) {
          Promise.resolve().then(() => editor.migrateListsToV2?.());
        }
        return ok;
      } catch (error) {
        console.error(`[insertContent] Failed to process ${options.contentType}:`, error);
        return false;
      }
    }
    return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
  };
const removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options,
  };
  const isJSONContent = typeof content === 'object' && content !== null;
  const isTextContent = typeof content === 'string';
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error('[super-editor error]: Invalid JSON content', { cause: error });
      }
      console.warn('[super-editor warn]: Invalid content.', 'Passed value:', content, 'Error:', error);
      return createNodeFromContent('', schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = '';
      const contentCheckSchema = new Schema$1({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __supereditor__private__unknown__catch__all__node: {
            content: 'inline*',
            group: 'block',
            parseDOM: () => [
              {
                tag: '*',
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === 'string' ? e : e.outerHTML;
                  return null;
                },
              },
            ],
          },
        }),
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error('[super-editor error]: Invalid HTML content', {
          cause: new Error(`Invalid element found: ${invalidContent}`),
        });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent('', schema, options);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1)) {
    return;
  }
  const map = tr.mapping.maps[last];
  let end = 0;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
const isFragment = (nodeOrFragment) => {
  return !('type' in nodeOrFragment);
};
const insertContentAt =
  (position, value, options) =>
  ({ tr, dispatch, editor }) => {
    if (!dispatch) return true;
    options = {
      parseOptions: {},
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      // optional escape hatch to force literal text insertion
      asText: false,
      ...options,
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: 'full',
          ...options.parseOptions,
        },
        errorOnInvalidContent: options.errorOnInvalidContent ?? editor.options.enableContentCheck,
      });
    } catch (e) {
      editor.emit('contentError', {
        editor,
        error: e,
        disableCollaboration: () => {
          console.error('[super-editor error]: Unable to disable collaboration at this point in time');
        },
      });
      return false;
    }
    let { from, to } =
      typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to };
    const isBareString = typeof value === 'string';
    const looksLikeHTML = isBareString && /^\s*<[a-zA-Z][^>]*>.*<\/[a-zA-Z][^>]*>\s*$/s.test(value);
    const hasNewline = isBareString && /[\r\n]/.test(value);
    const forceTextInsert =
      !!options.asText ||
      (hasNewline && !looksLikeHTML) ||
      (Array.isArray(value) && value.every((v) => typeof v === 'string' || (v && typeof v.text === 'string'))) ||
      (!!value && typeof value === 'object' && typeof value.text === 'string');
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent || forceTextInsert) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => (typeof v === 'string' ? v : (v && v.text) || '')).join('');
      } else if (typeof value === 'object' && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = typeof value === 'string' ? value : '';
      }
      tr.insertText(newContent, from, to);
    } else {
      newContent = content;
      tr.replaceWith(from, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta('applyInputRules', { from, text: newContent });
    }
    if (options.applyPasteRules) {
      tr.setMeta('applyPasteRules', { from, text: newContent });
    }
    return true;
  };
const undoInputRule =
  () =>
  ({ state, dispatch }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
      const plugin = plugins[i];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          const tr = state.tr;
          const toUndo = undoable.transform;
          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            const marks = tr.doc.resolve(undoable.from).marks();
            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
const wrapInList =
  (typeOrName, attrs = {}) =>
  ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList$1(type, attrs)(state, dispatch);
  };
function nearestListAt($pos, OrderedType, BulletType) {
  for (let d2 = $pos.depth; d2 >= 0; d2--) {
    const node = $pos.node(d2);
    if (node.type === OrderedType || node.type === BulletType) {
      return { node, pos: $pos.before(d2), depth: d2 };
    }
  }
  return null;
}
function getEffectiveListKind(node) {
  if (!node) return null;
  const typeName = node.type?.name;
  const style = node.attrs?.['list-style-type'];
  if (typeName === 'bulletList') return 'bullet';
  if (typeName === 'orderedList') {
    if (style === 'bullet') return 'bullet';
    const firstLI = node.firstChild;
    const liFmt = firstLI?.attrs?.listNumberingType;
    if (liFmt === 'bullet') return 'bullet';
    return 'ordered';
  }
  return null;
}
function collectIntersectingTopLists({ doc, selection, OrderedType, BulletType }) {
  const { from, to, $from, $to } = selection;
  const hit = /* @__PURE__ */ new Map();
  const startList = nearestListAt($from, OrderedType, BulletType);
  if (startList) hit.set(startList.pos, startList);
  const endList = nearestListAt($to, OrderedType, BulletType);
  if (endList) hit.set(endList.pos, endList);
  const a = $from.nodeAfter;
  if (a && (a.type === OrderedType || a.type === BulletType)) {
    hit.set($from.pos, { node: a, pos: $from.pos, depth: null });
  }
  const b = $to.nodeBefore;
  if (b && (b.type === OrderedType || b.type === BulletType)) {
    const posB = $to.pos - b.nodeSize;
    hit.set(posB, { node: b, pos: posB, depth: null });
  }
  doc.nodesBetween(from, to, (node, pos, parent) => {
    const isList2 = node.type === OrderedType || node.type === BulletType;
    if (!isList2) return true;
    const parentIsList = parent && (parent.type === OrderedType || parent.type === BulletType);
    if (!parentIsList) hit.set(pos, { node, pos, depth: null });
    return false;
  });
  return Array.from(hit.values()).sort((a2, b2) => b2.pos - a2.pos);
}
function computeListLevels(liNodes) {
  const levelsOut = [];
  const counters = [];
  for (let i = 0; i < liNodes.length; i++) {
    const lvl = Math.max(0, Number(liNodes[i]?.attrs?.level ?? 0));
    while (counters.length <= lvl) counters.push(0);
    counters.splice(lvl + 1);
    counters[lvl] = (counters[lvl] ?? 0) + 1;
    levelsOut.push(counters.slice(0, lvl + 1));
  }
  return levelsOut;
}
function rebuildListNodeWithNewNum({ oldList, toType, editor, schema, fixedNumId }) {
  const OrderedType = schema.nodes.orderedList;
  const isOrdered = toType === OrderedType;
  const numId = fixedNumId ?? ListHelpers.getNewListId(editor);
  if (fixedNumId == null) {
    ListHelpers.generateNewListDefinition?.({ numId: Number(numId), listType: toType, editor });
  }
  const liNodes = [];
  for (let i = 0; i < oldList.childCount; i++) {
    const li = oldList.child(i);
    if (li?.type?.name === 'listItem') liNodes.push(li);
  }
  const computedLevels = isOrdered ? computeListLevels(liNodes) : [];
  const items = [];
  for (let i = 0; i < liNodes.length; i++) {
    const li = liNodes[i];
    const level = Math.max(0, Number(li.attrs?.level ?? 0));
    const listLevel = isOrdered
      ? (computedLevels[i] ?? [i + 1])
      : Array.isArray(li.attrs?.listLevel)
        ? li.attrs.listLevel
        : [level + 1];
    const details =
      ListHelpers.getListDefinitionDetails?.({ numId: Number(numId), level, listType: toType, editor }) || {};
    const effectiveFmt = isOrdered ? details.numFmt || 'decimal' : details.numFmt || 'bullet';
    const effectiveLvlText = isOrdered ? details.lvlText || '%1.' : details.lvlText || '';
    const baseAttrs = li.attrs || {};
    const itemAttrs = {
      ...baseAttrs,
      level,
      listLevel,
      numId,
      numPrType: 'inline',
      listNumberingType: effectiveFmt,
      lvlText: effectiveLvlText,
    };
    const contentJSON = li.content && li.content.size > 0 ? li.content.toJSON() : [{ type: 'paragraph', content: [] }];
    items.push({
      type: 'listItem',
      attrs: itemAttrs,
      content: contentJSON,
    });
  }
  const containerJSON = {
    type: isOrdered ? 'orderedList' : 'bulletList',
    attrs: {
      listId: numId,
      'list-style-type': isOrdered
        ? (items[0]?.attrs?.listNumberingType ?? 'decimal')
        : (items[0]?.attrs?.listNumberingType ?? 'bullet'),
      ...(isOrdered ? { order: 1 } : {}),
    },
    content: items,
  };
  return editor.schema.nodeFromJSON(containerJSON);
}
function buildListContainersFromParagraphs({ paragraphs, targetKind, editor, schema }) {
  const OrderedType = schema.nodes.orderedList;
  const BulletType = schema.nodes.bulletList;
  const toType = targetKind === 'ordered' ? OrderedType : BulletType;
  const numId = ListHelpers.getNewListId(editor);
  ListHelpers.generateNewListDefinition?.({ numId, listType: toType, editor });
  const isOrdered = targetKind === 'ordered';
  const containers = [];
  for (let i = 0; i < paragraphs.length; i++) {
    const { node } = paragraphs[i];
    const level = 0;
    const listLevel = [1];
    const numFmt = isOrdered ? 'decimal' : 'bullet';
    const lvlText = isOrdered ? '%1.' : '';
    const itemJSON = ListHelpers.createListItemNodeJSON({
      level,
      listLevel,
      numId,
      numFmt,
      lvlText,
      contentNode: node.toJSON(),
      // preserve runs
    });
    itemJSON.attrs = {
      ...(itemJSON.attrs || {}),
      level,
      listLevel,
      numId,
      numPrType: 'inline',
      listNumberingType: numFmt,
      lvlText,
    };
    const containerJSON = {
      type: isOrdered ? 'orderedList' : 'bulletList',
      attrs: {
        listId: numId,
        'list-style-type': isOrdered ? 'decimal' : 'bullet',
        ...(isOrdered ? { order: 1 } : {}),
      },
      content: [itemJSON],
    };
    containers.push(editor.schema.nodeFromJSON(containerJSON));
  }
  return containers;
}
function setMappedSelectionSpan(tr, fromBefore, toBefore) {
  const mappedFrom = tr.mapping.map(fromBefore, -1);
  const mappedTo = tr.mapping.map(toBefore, 1);
  const $from = tr.doc.resolve(Math.max(1, Math.min(mappedFrom, tr.doc.content.size)));
  const $to = tr.doc.resolve(Math.max(1, Math.min(mappedTo, tr.doc.content.size)));
  tr.setSelection(TextSelection.between($from, $to));
}
function setCaretInsideFirstTextblockOfNodeAt(tr, containerPos) {
  const node = tr.doc.nodeAt(containerPos);
  if (!node) return;
  let found = null;
  node.descendants((n, p) => {
    if (n.isTextblock) {
      found = containerPos + p + 2;
      return false;
    }
    return true;
  });
  if (found != null) {
    tr.setSelection(TextSelection.create(tr.doc, found, found));
  } else {
    const fallback = Math.min(tr.doc.content.size, Math.max(1, containerPos + 1));
    tr.setSelection(TextSelection.create(tr.doc, fallback, fallback));
  }
}
const toggleList =
  (listType) =>
  ({ editor, state, tr, dispatch }) => {
    const { selection, doc } = state;
    const OrderedType = editor.schema.nodes.orderedList;
    const BulletType = editor.schema.nodes.bulletList;
    const TargetType = typeof listType === 'string' ? editor.schema.nodes[listType] : listType;
    const targetKind = TargetType === OrderedType ? 'ordered' : 'bullet';
    const isListNode = (n) => !!n && (n.type === OrderedType || n.type === BulletType);
    let near = nearestListAt(selection.$from, OrderedType, BulletType);
    if (!near) {
      const after = selection.$from.nodeAfter;
      if (isListNode(after)) {
        near = { node: after, pos: selection.$from.pos, depth: selection.$from.depth + 1 };
      } else {
        const before = selection.$from.nodeBefore;
        if (isListNode(before)) {
          const pos2 = selection.$from.pos - before.nodeSize;
          near = { node: before, pos: pos2, depth: selection.$from.depth + 1 };
        }
      }
    }
    const nearKind = near ? getEffectiveListKind(near.node) : null;
    if (near) {
      const isSameAsTarget = nearKind === targetKind;
      if (isSameAsTarget) {
        const candidateLists = collectIntersectingTopLists({ doc, selection, OrderedType, BulletType });
        let listsToUnwrap = candidateLists.filter(({ node }) => getEffectiveListKind(node) === targetKind);
        if (listsToUnwrap.length === 0 && getEffectiveListKind(near.node) === targetKind) {
          listsToUnwrap = [{ node: near.node, pos: near.pos, depth: near.depth ?? null }];
        }
        if (listsToUnwrap.length === 0) return false;
        let spanFromBefore2 = listsToUnwrap[0].pos;
        let spanToBefore2 = listsToUnwrap[0].pos + listsToUnwrap[0].node.nodeSize;
        for (let i = 1; i < listsToUnwrap.length; i++) {
          const { node, pos: pos2 } = listsToUnwrap[i];
          spanFromBefore2 = Math.min(spanFromBefore2, pos2);
          spanToBefore2 = Math.max(spanToBefore2, pos2 + node.nodeSize);
        }
        const ParagraphType = editor.schema.nodes.paragraph;
        listsToUnwrap.sort((a, b) => b.pos - a.pos);
        for (const { node, pos: pos2 } of listsToUnwrap) {
          const mappedFrom = tr.mapping.map(pos2, -1);
          const mappedTo = tr.mapping.map(pos2 + node.nodeSize, 1);
          const currentListNode = tr.doc.nodeAt(mappedFrom);
          const sourceListNode =
            currentListNode && (currentListNode.type === OrderedType || currentListNode.type === BulletType)
              ? currentListNode
              : node;
          const paragraphs = [];
          for (let i = 0; i < sourceListNode.childCount; i++) {
            const li = sourceListNode.child(i);
            if (li.type !== editor.schema.nodes.listItem) continue;
            const firstChild = li.firstChild;
            paragraphs.push(firstChild || ParagraphType.create());
          }
          if (paragraphs.length === 0) {
            paragraphs.push(ParagraphType.create());
          }
          const replacement = paragraphs.length === 1 ? paragraphs[0] : Fragment.from(paragraphs);
          tr.replaceWith(mappedFrom, mappedTo, replacement);
        }
        setMappedSelectionSpan(tr, spanFromBefore2, spanToBefore2);
        if (dispatch) dispatch(tr);
        return true;
      }
      let touchedLists = collectIntersectingTopLists({ doc, selection, OrderedType, BulletType });
      if (touchedLists.length === 0) {
        touchedLists = [{ node: near.node, pos: near.pos, depth: near.depth }];
      }
      let spanFromBefore = Infinity;
      let spanToBefore = -Infinity;
      for (const { node, pos: pos2 } of touchedLists) {
        spanFromBefore = Math.min(spanFromBefore, pos2);
        spanToBefore = Math.max(spanToBefore, pos2 + node.nodeSize);
      }
      const sharedNumId = ListHelpers.getNewListId(editor);
      ListHelpers.generateNewListDefinition?.({ numId: sharedNumId, listType: TargetType, editor });
      touchedLists.sort((a, b) => b.pos - a.pos);
      for (const { node: oldList, pos: pos2 } of touchedLists) {
        const mapped = tr.mapping.map(pos2);
        const newList = rebuildListNodeWithNewNum({
          oldList,
          toType: TargetType,
          editor,
          schema: editor.schema,
          fixedNumId: String(sharedNumId),
        });
        tr.replaceWith(mapped, mapped + oldList.nodeSize, newList);
      }
      setMappedSelectionSpan(tr, spanFromBefore, spanToBefore);
      if (dispatch) dispatch(tr);
      return true;
    }
    const { from, to, empty } = selection;
    const collectParagraphs = () => {
      const out = [];
      doc.nodesBetween(from, to, (node, pos2) => {
        if (node.type.name === 'paragraph') {
          const nodeFrom = pos2;
          const nodeTo = pos2 + node.nodeSize;
          if (nodeFrom < to && nodeTo > from) out.push({ node, pos: pos2 });
          return false;
        }
        return true;
      });
      return out;
    };
    if (!empty && from !== to) {
      const paragraphs = collectParagraphs();
      if (paragraphs.length >= 1) {
        const first2 = paragraphs[0];
        const last = paragraphs[paragraphs.length - 1];
        const spanFromBefore = first2.pos;
        const spanToBefore = last.pos + last.node.nodeSize;
        const containers2 = buildListContainersFromParagraphs({
          paragraphs,
          targetKind,
          editor,
          schema: editor.schema,
        });
        const replacement = paragraphs.length === 1 ? containers2[0] : Fragment.from(containers2);
        tr.replaceWith(spanFromBefore, spanToBefore, replacement);
        if (paragraphs.length === 1) {
          setCaretInsideFirstTextblockOfNodeAt(tr, spanFromBefore);
        } else {
          setMappedSelectionSpan(tr, spanFromBefore, spanToBefore);
        }
        if (dispatch) dispatch(tr);
        return true;
      }
    }
    const paraAtCursor = findParentNode((n) => n.type.name === 'paragraph')(selection);
    if (!paraAtCursor) return false;
    const { node: paragraph, pos } = paraAtCursor;
    const containers = buildListContainersFromParagraphs({
      paragraphs: [{ node: paragraph, pos }],
      targetKind,
      editor,
      schema: editor.schema,
    });
    tr.replaceWith(pos, pos + paragraph.nodeSize, containers[0]);
    setCaretInsideFirstTextblockOfNodeAt(tr, pos);
    if (dispatch) dispatch(tr);
    return true;
  };
const LIST_NODE_NAMES = /* @__PURE__ */ new Set(['orderedList', 'bulletList']);
const parseLevel = (value) => {
  if (typeof value === 'number') return value;
  const parsed = parseInt(value, 10);
  return Number.isNaN(parsed) ? 0 : parsed;
};
const resolveParentList = ($pos) => {
  if (!$pos) return null;
  for (let depth = $pos.depth; depth >= 0; depth--) {
    const node = $pos.node(depth);
    if (node?.type && LIST_NODE_NAMES.has(node.type.name)) {
      return node;
    }
  }
  return null;
};
const collectTargetListItemPositions = (state, fallbackPos) => {
  const doc = state?.doc;
  const listItemType = state?.schema?.nodes?.listItem;
  if (!doc || !listItemType) {
    return typeof fallbackPos === 'number' ? [fallbackPos] : [];
  }
  const candidates = [];
  const { from, to } = state.selection;
  doc.nodesBetween(from, to, (node, pos) => {
    if (node.type === listItemType) {
      const size = typeof node.nodeSize === 'number' ? node.nodeSize : 0;
      candidates.push({ node, pos, end: pos + size });
    }
  });
  if (!candidates.length && typeof fallbackPos === 'number') {
    return [fallbackPos];
  }
  const filtered = candidates.filter(({ pos, end }) => {
    return !candidates.some((other) => other.pos > pos && other.pos < end);
  });
  const sorted = filtered.map(({ pos }) => pos).sort((a, b) => a - b);
  return sorted.filter((pos, index) => index === 0 || pos !== sorted[index - 1]);
};
const decreaseListIndent =
  (_targetPositions) =>
  ({ editor, tr }) => {
    const { state } = editor;
    const currentItem =
      (ListHelpers.getCurrentListItem && ListHelpers.getCurrentListItem(state)) ||
      findParentNode((n) => n.type && n.type.name === 'listItem')(state.selection);
    const parentOrderedHelper = ListHelpers.getParentOrderedList && ListHelpers.getParentOrderedList(state);
    const parentBulletHelper = ListHelpers.getParentBulletList && ListHelpers.getParentBulletList(state);
    const targetPositions = _targetPositions || collectTargetListItemPositions(state, currentItem?.pos);
    if (!targetPositions.length) return false;
    let parentListsMap = {};
    const mappedNodes = targetPositions.map((originalPos) => {
      const mappedPos = tr.mapping ? tr.mapping.map(originalPos) : originalPos;
      const node =
        (tr.doc && tr.doc.nodeAt(mappedPos)) ||
        (currentItem && originalPos === currentItem.pos ? currentItem.node : null);
      return { originalPos, mappedPos, node };
    });
    const validNodes = mappedNodes.filter(({ node }) => node && node.type.name === 'listItem');
    validNodes.forEach(({ mappedPos, node }) => {
      const attrs = node.attrs || {};
      const currLevel = parseLevel(attrs.level);
      if (currLevel <= 0) {
        return;
      }
      const newLevel = currLevel - 1;
      const $pos = tr.doc ? tr.doc.resolve(mappedPos) : null;
      const parentListNode =
        resolveParentList($pos) ||
        parentOrderedHelper?.node ||
        parentBulletHelper?.node ||
        parentOrderedHelper ||
        parentBulletHelper;
      parentListsMap[mappedPos] = parentListNode;
      if (!parentListNode) {
        return;
      }
      const fallbackListId = parentListNode.attrs?.listId ?? null;
      let numId = fallbackListId ?? attrs.numId ?? null;
      let createdNewId = false;
      if (numId == null && ListHelpers.getNewListId) {
        numId = ListHelpers.getNewListId(editor);
        createdNewId = numId != null;
      }
      if (createdNewId && numId != null && ListHelpers.generateNewListDefinition) {
        ListHelpers.generateNewListDefinition({
          numId,
          listType: parentListNode.type,
          editor,
        });
      }
      tr.setNodeMarkup(mappedPos, null, {
        ...attrs,
        level: newLevel,
        numId,
      });
    });
    return Object.values(parentListsMap).length ? !Object.values(parentListsMap).every((pos) => !pos) : true;
  };
function isVisuallyEmptyParagraph(node) {
  if (!node || node.type.name !== 'paragraph') return false;
  let hasHardBreak = false;
  node.descendants((n) => {
    if (n.type && n.type.name === 'hardBreak') {
      hasHardBreak = true;
      return false;
    }
    return true;
  });
  if (hasHardBreak) return false;
  const text = (node.textContent || '').replace(/\u200b/g, '').trim();
  if (text.length > 0) return false;
  let hasInlineLeaf = false;
  node.descendants((n) => {
    if (n.isInline && n.isLeaf && n.type?.name !== 'hardBreak') {
      hasInlineLeaf = true;
      return false;
    }
    return true;
  });
  if (hasInlineLeaf) return false;
  return true;
}
function tryOutdentOneLevel(props) {
  return decreaseListIndent()(props);
}
const splitListItem = () => (props) => {
  const { tr, state, dispatch } = props;
  const type = getNodeType('listItem', state.schema);
  const { $from, $to, empty } = state.selection;
  tr.setMeta('updateListSync', true);
  const listItemPM = findParentNode((n) => n.type === type)(state.selection);
  if (!listItemPM) return false;
  const { node: listItemNode } = listItemPM;
  if ((state.selection.node && state.selection.node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const paraPM = findParentNode((n) => n.type.name === 'paragraph')(state.selection);
  if (!paraPM) return false;
  const originalParagraphNode = paraPM.node;
  const paraStart = paraPM.pos + 1;
  const listPM = findParentNode((n) => ['orderedList', 'bulletList'].includes(n.type.name))(state.selection);
  if (!listPM) return false;
  const { node: parentListNode, pos: listStart } = listPM;
  const listEnd = listStart + parentListNode.nodeSize;
  let offsetInParagraph;
  if (empty) {
    offsetInParagraph = state.selection.from - paraStart;
  } else {
    offsetInParagraph = $from.pos - paraStart;
  }
  const parentPara = $from.parent;
  const isEmptyPara = isVisuallyEmptyParagraph(parentPara);
  const atEndOfListItem = $from.node(-1).childCount === $from.indexAfter(-1);
  if (isEmptyPara && atEndOfListItem) {
    const currentLevel = typeof listItemNode?.attrs?.level === 'number' ? listItemNode.attrs.level : 0;
    if (currentLevel > 0) {
      const outdented = tryOutdentOneLevel(props);
      if (outdented) {
        tr.scrollIntoView();
        if (dispatch) dispatch(tr);
        return true;
      }
    }
    return handleSplitInEmptyBlock(props, listItemPM);
  }
  if (isVisuallyEmptyParagraph(originalParagraphNode)) {
    const currentLevel = typeof listItemNode?.attrs?.level === 'number' ? listItemNode.attrs.level : 0;
    if (currentLevel > 0) {
      const outdented = tryOutdentOneLevel(props);
      if (outdented) {
        tr.scrollIntoView();
        if (dispatch) dispatch(tr);
        return true;
      }
    }
    return handleSplitInEmptyBlock(props, listItemPM);
  }
  let paragraphContentToSplit = originalParagraphNode.content;
  if (!empty) {
    const selectionStart = $from.pos - paraStart;
    const selectionEnd = $to.pos - paraStart;
    paragraphContentToSplit = originalParagraphNode.content
      .cut(0, selectionStart)
      .append(originalParagraphNode.content.cut(selectionEnd));
    offsetInParagraph = selectionStart;
  }
  const beforeCursor = paragraphContentToSplit.cut(0, Math.max(0, offsetInParagraph));
  const afterCursor = paragraphContentToSplit.cut(Math.max(0, offsetInParagraph));
  const paragraphIndex = $from.index(-1);
  const listItemHasMultipleParagraphs = listItemNode.childCount > 1;
  let firstLI, secondLI;
  if (listItemHasMultipleParagraphs) {
    const contentBefore = [];
    for (let i = 0; i < paragraphIndex; i++) contentBefore.push(listItemNode.child(i));
    const contentAfter = [];
    for (let i = paragraphIndex + 1; i < listItemNode.childCount; i++) contentAfter.push(listItemNode.child(i));
    const firstParas = [
      ...contentBefore,
      originalParagraphNode.type.create(originalParagraphNode.attrs, beforeCursor.size ? beforeCursor : null),
    ].filter(Boolean);
    if (firstParas.length === 0) {
      firstParas.push(state.schema.nodes.paragraph.create(originalParagraphNode.attrs));
    }
    const secondParas = [
      originalParagraphNode.type.create(originalParagraphNode.attrs, afterCursor.size ? afterCursor : null),
      ...contentAfter,
    ].filter(Boolean);
    if (secondParas.length === 0) {
      secondParas.push(state.schema.nodes.paragraph.create(originalParagraphNode.attrs));
    }
    firstLI = state.schema.nodes.listItem.create({ ...listItemNode.attrs }, Fragment.from(firstParas));
    secondLI = state.schema.nodes.listItem.create({ ...listItemNode.attrs }, Fragment.from(secondParas));
  } else {
    const firstParagraph = originalParagraphNode.type.create(
      originalParagraphNode.attrs,
      beforeCursor.size ? beforeCursor : null,
    );
    const secondParagraph = originalParagraphNode.type.create(
      originalParagraphNode.attrs,
      afterCursor.size ? afterCursor : null,
    );
    firstLI = state.schema.nodes.listItem.create({ ...listItemNode.attrs }, firstParagraph);
    secondLI = state.schema.nodes.listItem.create({ ...listItemNode.attrs }, secondParagraph);
  }
  if (!firstLI || !secondLI) return false;
  const ListType = parentListNode.type;
  const firstList = ListType.createAndFill(parentListNode.attrs, Fragment.from(firstLI));
  const secondList = ListType.createAndFill(parentListNode.attrs, Fragment.from(secondLI));
  if (!firstList || !secondList) return false;
  tr.replaceWith(listStart, listEnd, firstList);
  const insertAfterFirst = listStart + firstList.nodeSize;
  tr.insert(insertAfterFirst, secondList);
  const cursorPos = insertAfterFirst + 3;
  tr.setSelection(TextSelection.near(tr.doc.resolve(cursorPos), 1)).scrollIntoView();
  tr.setMeta('splitListItem', true);
  if (dispatch) dispatch(tr);
  return true;
};
const handleSplitInEmptyBlock = (props, currentListItem) => {
  const { state, editor, tr } = props;
  const { schema } = state;
  const { $from } = state.selection;
  const extensionAttrs = editor.extensionService.attributes;
  const listItemNode = currentListItem.node;
  const isEmptyParagraph = isVisuallyEmptyParagraph($from.parent);
  const listItemHasOtherContent = listItemNode.content.size > $from.parent.nodeSize;
  const isAtEndOfListItem = $from.indexAfter(-1) === $from.node(-1).childCount;
  if (isEmptyParagraph && listItemHasOtherContent && isAtEndOfListItem) {
    try {
      const listTypes2 = ['orderedList', 'bulletList'];
      const parentList2 = findParentNode((n) => listTypes2.includes(n.type.name))(state.selection);
      if (!parentList2) return false;
      const newParagraphAttrs2 = Attribute.getSplittedAttributes(extensionAttrs, 'paragraph', {});
      const newParagraph2 = schema.nodes.paragraph.create(newParagraphAttrs2);
      const newListItem = schema.nodes.listItem.create({ ...listItemNode.attrs }, newParagraph2);
      const ListType = parentList2.node.type;
      const newList = ListType.createAndFill(parentList2.node.attrs, Fragment.from(newListItem));
      if (!newList) return false;
      const insertPos = parentList2.pos + parentList2.node.nodeSize;
      tr.insert(insertPos, newList);
      const newPos2 = insertPos + 3;
      tr.setSelection(TextSelection.near(tr.doc.resolve(newPos2)));
      tr.scrollIntoView();
      return true;
    } catch (e) {
      console.error('Error creating new list item:', e);
      return false;
    }
  }
  if (isEmptyParagraph && listItemHasOtherContent && !isAtEndOfListItem) return false;
  const listTypes = ['orderedList', 'bulletList'];
  const parentList = findParentNode((n) => listTypes.includes(n.type.name))(state.selection);
  if (!parentList) return false;
  const newParagraphAttrs = Attribute.getSplittedAttributes(extensionAttrs, 'paragraph', {});
  let newParagraph = schema.nodes.paragraph.createAndFill(newParagraphAttrs);
  if (!newParagraph) newParagraph = schema.nodes.paragraph.create();
  const listStart = parentList.pos;
  const listEnd = parentList.pos + parentList.node.nodeSize;
  tr.replaceWith(listStart, listEnd, newParagraph);
  const newPos = listStart + 1;
  tr.setSelection(TextSelection.near(tr.doc.resolve(newPos)));
  tr.scrollIntoView();
  return true;
};
const sinkListItem =
  (typeOrName) =>
  ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem$1(type)(state, dispatch);
  };
const liftListItem =
  (typeOrName) =>
  ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem$1(type)(state, dispatch);
  };
const deleteListItem = () => (props) => {
  const { tr, state } = props;
  const { selection } = state;
  tr.setMeta('updateListSync', true);
  if (!selection.empty) {
    const { from, to } = selection;
    const fullySelectedBlocks = [];
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (node.isBlock && pos >= from && pos + node.nodeSize <= to) {
        fullySelectedBlocks.push({ pos, size: node.nodeSize });
      }
    });
    if (fullySelectedBlocks.length) {
      fullySelectedBlocks
        .sort((a, b) => b.pos - a.pos)
        .forEach(({ pos, size }) => {
          tr.delete(pos, pos + size);
        });
      const $new = tr.doc.resolve(from);
      tr.setSelection(TextSelection.near($new));
      return true;
    }
    return false;
  }
  const { $from } = state.selection;
  if ($from.parentOffset !== 0) return false;
  const currentListItem = findParentNode((n) => n.type.name === 'listItem')(state.selection);
  if (!currentListItem) return false;
  const listTypes = ['orderedList', 'bulletList'];
  const parentList = findParentNode((n) => listTypes.includes(n.type.name))(state.selection);
  if (!parentList) return false;
  const currentParagraphNode = findParentNode((n) => n.type.name === 'paragraph')(state.selection);
  const paragraphNode = currentListItem.node.content.firstChild;
  if (paragraphNode !== currentParagraphNode.node) return false;
  const listFrom = parentList.pos;
  const listTo = listFrom + parentList.node.nodeSize;
  if (currentListItem.node.content.size === 0) {
    tr.delete(listFrom, listTo);
    return true;
  }
  const listItemContent = currentListItem.node.content;
  const nodes = [];
  listItemContent.forEach((child) => {
    nodes.push(child);
  });
  tr.replaceWith(listFrom, listTo, nodes);
  const $pos = tr.doc.resolve(listFrom + 1);
  tr.setSelection(TextSelection.near($pos));
  return true;
};
const increaseListIndent =
  (_targetPositions) =>
  ({ editor, tr }) => {
    const { state } = editor;
    const currentItem =
      (ListHelpers.getCurrentListItem && ListHelpers.getCurrentListItem(state)) ||
      findParentNode((n) => n.type && n.type.name === 'listItem')(state.selection);
    const parentOrderedHelper = ListHelpers.getParentOrderedList && ListHelpers.getParentOrderedList(state);
    const parentBulletHelper = ListHelpers.getParentBulletList && ListHelpers.getParentBulletList(state);
    const targetPositions = _targetPositions || collectTargetListItemPositions(state, currentItem?.pos);
    if (!targetPositions.length) return false;
    let parentListsMap = {};
    const mappedNodes = targetPositions.map((originalPos) => {
      const mappedPos = tr.mapping ? tr.mapping.map(originalPos) : originalPos;
      const node =
        (tr.doc && tr.doc.nodeAt(mappedPos)) ||
        (currentItem && originalPos === currentItem.pos ? currentItem.node : null);
      return { originalPos, mappedPos, node };
    });
    const validNodes = mappedNodes.filter(({ node }) => node && node.type.name === 'listItem');
    validNodes.forEach(({ mappedPos, node }) => {
      const attrs = node.attrs || {};
      const currentLevel = parseLevel(attrs.level);
      const newLevel = currentLevel + 1;
      const $pos = tr.doc ? tr.doc.resolve(mappedPos) : null;
      const parentListNode =
        resolveParentList($pos) ||
        parentOrderedHelper?.node ||
        parentBulletHelper?.node ||
        parentOrderedHelper ||
        parentBulletHelper;
      parentListsMap[mappedPos] = parentListNode;
      if (!parentListNode) {
        return;
      }
      let numId = attrs.numId;
      if (numId == null) {
        const fallbackListId = parentListNode.attrs?.listId ?? null;
        numId = fallbackListId ?? (ListHelpers.getNewListId ? ListHelpers.getNewListId(editor) : null);
        if (numId != null && ListHelpers.generateNewListDefinition) {
          ListHelpers.generateNewListDefinition({
            numId,
            listType: parentListNode.type,
            editor,
          });
        }
      }
      tr.setNodeMarkup(mappedPos, null, {
        ...attrs,
        level: newLevel,
        numId,
      });
    });
    return Object.values(parentListsMap).length ? !Object.values(parentListsMap).every((pos) => !pos) : true;
  };
const isList = (n) => !!n && (n.type?.name === 'orderedList' || n.type?.name === 'bulletList');
const findNodePosition = (doc, targetNode) => {
  let nodePos = null;
  doc.descendants((node, pos) => {
    if (node === targetNode) {
      nodePos = pos;
      return false;
    }
    return true;
  });
  return nodePos;
};
function getListContext(state) {
  const { $from } = state.selection;
  for (let d2 = $from.depth; d2 > 0; d2--) {
    const node = $from.node(d2 - 1);
    if (isList(node)) {
      const listDepth = d2 - 1;
      const listPos = $from.before(listDepth);
      const listNode = node;
      const liNode = listNode.firstChild || null;
      if (!liNode || liNode.type.name !== 'listItem') return null;
      return { listDepth, listPos, listNode, liNode };
    }
  }
  return null;
}
const handleBackspaceNextToList =
  () =>
  ({ state, dispatch, editor }) => {
    const { selection, doc, schema } = state;
    const { $from } = selection;
    if (!selection.empty) return false;
    if ($from.parent.type.name !== 'paragraph') return false;
    const ctx = getListContext(state);
    if (ctx) {
      const { listPos, listNode, liNode } = ctx;
      const atStartOfParagraph = $from.parentOffset === 0;
      const itemIsEmpty = liNode.childCount > 0 ? liNode.firstChild?.content.size === 0 : true;
      if (!atStartOfParagraph && !itemIsEmpty) return false;
      const level = Number(liNode.attrs?.level ?? 0);
      if (level > 0) {
        const tr1 = state.tr.setMeta('updateListSync', true);
        const didOutdent =
          typeof decreaseListIndent === 'function' &&
          decreaseListIndent()({
            editor,
            state,
            tr: tr1,
            dispatch: (t) => dispatch && t && dispatch(t),
          });
        if (didOutdent) return true;
        const liPos = listPos + 1;
        const newLevel = Math.max(0, level - 1);
        const trFallback = state.tr.setMeta('updateListSync', true);
        trFallback.setNodeMarkup(liPos, null, { ...liNode.attrs, level: newLevel });
        dispatch(trFallback);
        return true;
      }
      const replacement =
        liNode && liNode.content && liNode.content.size > 0
          ? liNode.content
          : Fragment.from(schema.nodes.paragraph.create());
      const from = listPos;
      const to = listPos + listNode.nodeSize;
      const tr2 = state.tr.setMeta('updateListSync', true);
      tr2.replaceWith(from, to, replacement);
      const newPos = from + 1;
      tr2.setSelection(TextSelection.near(tr2.doc.resolve(newPos), 1)).scrollIntoView();
      dispatch(tr2);
      return true;
    }
    if ($from.parentOffset !== 0) return false;
    const parentDepth = $from.depth - 1;
    if (parentDepth < 0) return false;
    const container = $from.node(parentDepth);
    const idx = $from.index(parentDepth);
    if (idx === 0) return false;
    const beforeNode = container.child(idx - 1);
    if (!beforeNode || !isList(beforeNode)) return false;
    const listItem = beforeNode.lastChild;
    if (!listItem || listItem.type.name !== 'listItem') return false;
    const targetPara = listItem.lastChild;
    if (!targetPara || targetPara.type.name !== 'paragraph') return false;
    const paraStartPos = findNodePosition(doc, targetPara);
    if (paraStartPos == null) return false;
    const inlineContent = Fragment.from($from.parent.content);
    const tr = state.tr.setMeta('updateListSync', true);
    const thisParaStart = $from.before();
    tr.delete(thisParaStart, thisParaStart + $from.parent.nodeSize);
    const insertPos = paraStartPos + 1 + targetPara.content.size;
    tr.insert(insertPos, inlineContent);
    tr.setSelection(TextSelection.near(tr.doc.resolve(insertPos), 1));
    dispatch(tr);
    return true;
  };
function getParaCtx(state) {
  const { $from } = state.selection;
  for (let d2 = $from.depth; d2 >= 0; d2--) {
    const n = $from.node(d2);
    if (n.type.name === 'paragraph') {
      const before = $from.before(d2);
      const endInside = before + 1 + n.content.size;
      return { para: n, paraDepth: d2, before, endInside };
    }
  }
  return null;
}
function atVisualParaEnd(state, ctx) {
  const { $from } = state.selection;
  const { para, paraDepth, endInside } = ctx;
  if ($from.parent.type.name === 'paragraph' && $from.parentOffset === $from.parent.content.size) return true;
  if ($from.parent.type.name === 'run' && $from.parentOffset === $from.parent.content.size) {
    const idxInPara = $from.index(paraDepth);
    return idxInPara === para.childCount - 1;
  }
  return $from.pos === endInside;
}
function getNextSiblingAtDepth(state, depth) {
  const pos = state.selection.$from.after(depth);
  if (pos == null) return { pos: null, next: null };
  const $pos = state.doc.resolve(pos);
  return { pos, next: $pos.nodeAfter || null };
}
const handleDeleteNextToList =
  () =>
  ({ state, dispatch }) => {
    const { selection } = state;
    const { $from } = selection;
    if (!selection.empty) return false;
    const ctx = getParaCtx(state);
    if (!ctx) return false;
    const { paraDepth, endInside: paraEnd } = ctx;
    if (!atVisualParaEnd(state, ctx)) return false;
    const tr = state.tr;
    tr.setMeta('suppressAutoList', true);
    const insertAtParaEnd = (frag) => {
      const mapped = tr.mapping.map(paraEnd, 1);
      tr.insert(mapped, frag);
      return mapped;
    };
    let listItemDepth = -1;
    let listDepth = -1;
    for (let d2 = $from.depth; d2 > 0; d2--) {
      const maybeLI = $from.node(d2 - 1);
      if (maybeLI.type.name === 'listItem') {
        listItemDepth = d2 - 1;
        if (d2 - 2 >= 0 && isList($from.node(d2 - 2))) listDepth = d2 - 2;
        break;
      }
    }
    if (listItemDepth !== -1 && listDepth !== -1) {
      const li = $from.node(listItemDepth);
      const paraIdxInLI = $from.index(listItemDepth + 1);
      if (paraIdxInLI < li.childCount - 1) return false;
    }
    const currentBlockDepth = listItemDepth !== -1 && listDepth !== -1 ? listDepth : paraDepth;
    const { pos: nextBeforePos, next: nextNode } = getNextSiblingAtDepth(state, currentBlockDepth);
    if (nextBeforePos == null || !nextNode) return false;
    const mergeParagraphAt = (beforePos) => {
      const livePara = tr.doc.resolve(beforePos).nodeAfter;
      if (!livePara || livePara.type.name !== 'paragraph') return false;
      if (livePara.content.size === 0) {
        tr.delete(beforePos, beforePos + livePara.nodeSize);
        dispatch?.(tr);
        return true;
      }
      const ins = insertAtParaEnd(Fragment.from(livePara.content));
      const delFrom = tr.mapping.map(beforePos, 1);
      const delTo = tr.mapping.map(beforePos + livePara.nodeSize, 1);
      tr.delete(delFrom, delTo);
      const selPos = tr.mapping.map(ins + livePara.content.size, -1);
      tr.setSelection(TextSelection.near(tr.doc.resolve(selPos), -1)).scrollIntoView();
      dispatch?.(tr);
      return true;
    };
    const mergeListAt = (beforePos) => {
      const liveList = tr.doc.resolve(beforePos).nodeAfter;
      if (!liveList || !isList(liveList)) return true;
      const li = liveList.firstChild;
      if (!li || li.type.name !== 'listItem' || li.childCount === 0) {
        tr.delete(beforePos, beforePos + liveList.nodeSize);
        dispatch?.(tr);
        return true;
      }
      let content = null;
      for (let i = 0; i < li.childCount; i++) {
        const ch = li.child(i);
        if (ch.type.name === 'paragraph' && ch.content.size > 0) {
          content = ch.content;
          break;
        }
      }
      if (content) insertAtParaEnd(Fragment.from(content));
      const delFrom = tr.mapping.map(beforePos, 1);
      const delTo = tr.mapping.map(beforePos + liveList.nodeSize, 1);
      tr.delete(delFrom, delTo);
      const endPos = tr.mapping.map(paraEnd + (content ? content.size : 0), -1);
      tr.setSelection(TextSelection.near(tr.doc.resolve(endPos), -1)).scrollIntoView();
      dispatch?.(tr);
      return true;
    };
    if (nextNode.isTextblock) {
      const changed = mergeParagraphAt(nextBeforePos);
      return changed ? true : false;
    }
    if (isList(nextNode)) {
      return mergeListAt(nextBeforePos);
    }
    return false;
  };
const restoreSelection =
  () =>
  ({ editor, state, tr }) => {
    if (editor.options.lastSelection) {
      const selectionTr = tr.setSelection(
        TextSelection.create(state.doc, editor.options.lastSelection.from, editor.options.lastSelection.to),
      );
      editor.view.dispatch(selectionTr);
    }
  };
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));
const setTextSelection =
  ({ from, to }) =>
  ({ state, dispatch, editor }) => {
    if (typeof from !== 'number' && typeof to !== 'number') {
      return false;
    }
    const doc = state.doc;
    const docSize = doc.content.size;
    const nextFrom = clamp(typeof from === 'number' ? from : state.selection.from, 0, docSize);
    const nextToBase = typeof to === 'number' ? to : nextFrom;
    const nextTo = clamp(nextToBase, 0, docSize);
    const [head, anchor] = nextFrom <= nextTo ? [nextFrom, nextTo] : [nextTo, nextFrom];
    const selection = TextSelection.create(doc, head, anchor);
    if (dispatch) {
      const transaction = state.tr.setSelection(selection);
      dispatch(transaction);
    }
    if (editor?.view?.focus) {
      editor.view.focus();
    }
    return true;
  };
const getSelectionMarks =
  () =>
  ({ state, tr }) => {
    tr.setMeta('preventDispatch', true);
    const marks = getMarksFromSelection(state) ?? [];
    const uniqueByType = /* @__PURE__ */ new Map();
    for (const mark of marks) {
      const typeName = typeof mark?.type === 'string' ? mark.type : mark?.type?.name;
      if (!typeName) continue;
      const existing = uniqueByType.get(typeName);
      if (!existing) {
        uniqueByType.set(typeName, mark);
        continue;
      }
      const existingAttrs = existing?.attrs ?? {};
      const nextAttrs = mark?.attrs ?? {};
      const existingHasValues = Object.values(existingAttrs).some((value) => value != null);
      const nextHasValues = Object.values(nextAttrs).some((value) => value != null);
      if (!existingHasValues && nextHasValues) {
        uniqueByType.set(typeName, mark);
      }
    }
    return Array.from(uniqueByType.values());
  };
const commands$1 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      atVisualParaEnd,
      clearNodes,
      collectIntersectingTopLists,
      command,
      createParagraphNear,
      decreaseListIndent,
      defaultStyleDetector,
      deleteListItem,
      deleteSelection,
      exitCode,
      first,
      getEffectiveStyleId,
      getParaCtx,
      getSelectionMarks,
      getStyleIdFromMarks,
      handleBackspaceNextToList,
      handleDeleteNextToList,
      increaseListIndent,
      insertContent,
      insertContentAt,
      insertTabChar,
      insertTabCharacter,
      insertTabNode,
      isStyleTokenEnabled,
      joinBackward,
      joinDown,
      joinForward,
      joinUp,
      liftEmptyBlock,
      liftListItem,
      mapMarkToStyleKey,
      nearestListAt,
      newlineInCode,
      rebuildListNodeWithNewNum,
      resetAttributes,
      restoreSelection,
      selectAll,
      selectNodeBackward,
      selectNodeForward,
      selectTextblockEnd,
      selectTextblockStart,
      setMappedSelectionSpan,
      setMark,
      setMeta,
      setNode,
      setTextSelection,
      sinkListItem,
      splitBlock,
      splitListItem,
      toggleList,
      toggleMark,
      toggleMarkCascade,
      toggleNode,
      undoInputRule,
      unsetAllMarks,
      unsetMark,
      updateAttributes,
      wrapInList,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
const Commands = Extension.create({
  name: 'commands',
  addCommands() {
    return { ...commands$1 };
  },
});
const handleEnter = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.splitRun(),
    () => commands2.newlineInCode(),
    () => commands2.createParagraphNear(),
    () => commands2.liftEmptyBlock(),
    () => commands2.splitBlock(),
  ]);
};
const handleBackspace = (editor) => {
  return editor.commands.first(({ commands: commands2, tr }) => [
    () => commands2.undoInputRule(),
    () => {
      tr.setMeta('inputType', 'deleteContentBackward');
      return false;
    },
    () => commands2.deleteSelection(),
    () => commands2.handleBackspaceNextToList(),
    () => commands2.deleteListItem(),
    () => commands2.joinBackward(),
    () => commands2.selectNodeBackward(),
  ]);
};
const handleDelete = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.deleteSelection(),
    () => commands2.handleDeleteNextToList(),
    () => commands2.joinForward(),
    () => commands2.selectNodeForward(),
  ]);
};
const Keymap = Extension.create({
  name: 'keymap',
  addShortcuts() {
    const baseKeymap = {
      Enter: () => handleEnter(this.editor),
      'Shift-Enter': () => this.editor.commands.insertLineBreak(),
      'Mod-Enter': () => this.editor.commands.exitCode(),
      Backspace: () => handleBackspace(this.editor),
      'Mod-Backspace': () => handleBackspace(this.editor),
      'Shift-Backspace': () => handleBackspace(this.editor),
      Delete: () => handleDelete(this.editor),
      'Mod-Delete': () => handleDelete(this.editor),
      'Mod-a': () => this.editor.commands.selectAll(),
      Tab: () => this.editor.commands.insertTabNode(),
    };
    const pcBaseKeymap = {
      ...baseKeymap,
    };
    const macBaseKeymap = {
      ...baseKeymap,
      'Ctrl-h': () => handleBackspace(this.editor),
      'Alt-Backspace': () => handleBackspace(this.editor),
      'Ctrl-d': () => handleDelete(this.editor),
      'Ctrl-Alt-Backspace': () => handleDelete(this.editor),
      'Alt-Delete': () => handleDelete(this.editor),
      'Alt-d': () => handleDelete(this.editor),
      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),
      'Ctrl-t': () => this.editor.commands.insertTabChar(),
    };
    if (isMacOS() || isIOS()) {
      return macBaseKeymap;
    }
    return pcBaseKeymap;
  },
});
const Editable = Extension.create({
  name: 'editable',
  addPmPlugins() {
    const editablePlugin = new Plugin({
      key: new PluginKey('editable'),
      props: {
        editable: () => {
          return this.editor.options.editable;
        },
      },
    });
    return [editablePlugin];
  },
});
const EditorFocus = Extension.create({
  name: 'editorFocus',
  addPmPlugins() {
    const editor = this.editor;
    const editorFocusPlugin = new Plugin({
      key: new PluginKey('editorFocus'),
      props: {
        handleDOMEvents: {
          focus: (view, event) => {
            editor.isFocused = true;
            const tr = editor.state.tr.setMeta('focus', { event }).setMeta('addToHistory', false);
            view.dispatch(tr);
            return false;
          },
          blur: (view, event) => {
            editor.isFocused = false;
            const tr = editor.state.tr.setMeta('blur', { event }).setMeta('addToHistory', false);
            view.dispatch(tr);
            return false;
          },
        },
      },
    });
    return [editorFocusPlugin];
  },
});
const schemaModules = /* @__PURE__ */ Object.assign({});
const metadataModules = /* @__PURE__ */ Object.assign({});
const rawSchemaModules = /* @__PURE__ */ Object.assign({});
Object.entries(metadataModules).reduce((acc, [key2, loader]) => {
  const match = key2.match(/versions\/([^/]+)\/metadata\.json$/);
  if (match?.[1]) acc[match[1]] = loader;
  return acc;
}, {});
Object.entries(schemaModules).reduce((acc, [key2, loader]) => {
  const match = key2.match(/versions\/([^/]+)\/schema\.js$/);
  if (match?.[1]) acc[match[1]] = loader;
  return acc;
}, {});
Object.entries(rawSchemaModules).reduce((acc, [key2, loader]) => {
  const match = key2.match(/versions\/([^/]+)\/schema\.js$/);
  if (match?.[1]) acc[match[1]] = loader;
  return acc;
}, {});
class EventEmitter {
  constructor() {
    __privateAdd(this, _events, /* @__PURE__ */ new Map());
  }
  /**
   * Subscribe to the event.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  on(name, fn) {
    const callbacks = __privateGet(this, _events).get(name);
    if (callbacks) callbacks.push(fn);
    else __privateGet(this, _events).set(name, [fn]);
  }
  /**
   * Emit event.
   * @param {string} name Event name.
   * @param {...any} args  Arguments to pass to each listener.
   * @returns {void}
   */
  emit(name, ...args) {
    const callbacks = __privateGet(this, _events).get(name);
    if (!callbacks) return;
    for (const fn of callbacks) {
      fn.apply(this, args);
    }
  }
  /**
   * Remove a specific callback from event
   * or all event subscriptions.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  off(name, fn) {
    const callbacks = __privateGet(this, _events).get(name);
    if (!callbacks) return;
    if (fn) {
      __privateGet(this, _events).set(
        name,
        callbacks.filter((cb) => cb !== fn),
      );
    } else {
      __privateGet(this, _events).delete(name);
    }
  }
  /**
   * Subscribe to an event that will be called only once.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  once(name, fn) {
    const wrapper = (...args) => {
      this.off(name, wrapper);
      fn.apply(this, args);
    };
    this.on(name, wrapper);
  }
  /**
   * Remove all registered events and subscriptions.
   */
  removeAllListeners() {
    __privateSet(this, _events, /* @__PURE__ */ new Map());
  }
}
_events = new WeakMap();
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
const _ExtensionService = class _ExtensionService {
  constructor(extensions, userExtensions, editor) {
    __privateAdd(this, _ExtensionService_instances);
    __publicField(this, 'editor');
    __publicField(this, 'schema');
    __publicField(this, 'extensions');
    __publicField(this, 'externalExtensions', []);
    __publicField(this, 'splittableMarks', []);
    this.editor = editor;
    this.externalExtensions = userExtensions || [];
    this.externalExtensions = this.externalExtensions.map((extension) => {
      return {
        ...extension,
        isExternal: true,
      };
    });
    this.extensions = _ExtensionService.getResolvedExtensions([...extensions, ...this.externalExtensions]);
    this.schema = Schema.createSchemaByExtensions(this.extensions, editor);
    __privateMethod(this, _ExtensionService_instances, setupExtensions_fn).call(this);
  }
  /**
   * Static method for creating ExtensionService.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new _ExtensionService(...args);
  }
  /**
   * Get an array of resolved extensions (e.g. sorted by priority).
   * @param extensions Array of extensions.
   * @returns Array of resolved extensions.
   */
  static getResolvedExtensions(extensions) {
    const resolvedExtensions = _ExtensionService.sortByPriority(extensions);
    return resolvedExtensions;
  }
  /**
   * Sort extensions by priority.
   * @param extensions Array of extensions.
   * @returns Array of sorted extensions by priority.
   */
  static sortByPriority(extensions) {
    const defaultValue = 100;
    return extensions.sort((a, b) => {
      const priorityA = getExtensionConfigField(a, 'priority') || defaultValue;
      const priorityB = getExtensionConfigField(b, 'priority') || defaultValue;
      if (priorityA > priorityB) return -1;
      if (priorityA < priorityB) return 1;
      return 0;
    });
  }
  /**
   * Get all attributes defined in the extensions.
   * @returns Array of attributes.
   */
  get attributes() {
    return Attribute.getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all commands defined in the extensions.
   * @returns Object with commands (key - command name, value - function).
   */
  get commands() {
    let commandsObject = {};
    for (const extension of this.extensions) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema),
      };
      const addCommands = getExtensionConfigField(extension, 'addCommands', context);
      if (addCommands) {
        commandsObject = {
          ...commandsObject,
          ...addCommands(),
        };
      }
    }
    return commandsObject;
  }
  /**
   * Get all helper methods defined in the extensions.
   * Each extension can define its own helper methods.
   * Example: editor.helpers.linkedStyles.getStyles()
   * @returns {Object} Object with helper methods for extensions.
   */
  get helpers() {
    const helpersObject = {};
    for (const extension of this.extensions) {
      const name = extension.name;
      if (!name) continue;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema),
      };
      const addHelpers = getExtensionConfigField(extension, 'addHelpers', context);
      if (addHelpers) {
        helpersObject[name] = addHelpers();
      }
    }
    return helpersObject;
  }
  /**
   * Get all PM plugins defined in the extensions.
   * And also keyboard shortcuts.
   * @returns Array of PM plugins.
   */
  get plugins() {
    const editor = this.editor;
    const extensions = _ExtensionService.sortByPriority([...this.extensions].reverse());
    const inputRules = [];
    const allPlugins = extensions
      .map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getSchemaTypeByName(extension.name, this.schema),
        };
        const plugins = [];
        const addShortcuts = getExtensionConfigField(extension, 'addShortcuts', context);
        let bindingsObject = {};
        if (addShortcuts) {
          const entries = Object.entries(addShortcuts()).map(([shortcut, method]) => {
            return [shortcut, (...args) => method({ editor, keymapArgs: args })];
          });
          bindingsObject = { ...Object.fromEntries(entries) };
        }
        plugins.push(keymap(bindingsObject));
        const addInputRules = getExtensionConfigField(extension, 'addInputRules', context);
        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
          inputRules.push(...addInputRules());
        }
        const addPmPlugins = getExtensionConfigField(extension, 'addPmPlugins', context);
        if (addPmPlugins) {
          const pmPlugins = addPmPlugins();
          plugins.push(...pmPlugins);
        }
        return plugins;
      })
      .flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules,
      }),
      ...allPlugins,
    ];
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views.
   */
  get nodeViews() {
    const { editor } = this;
    const nodeExtensions = this.extensions.filter((e) => e.type === 'node');
    const entries = nodeExtensions
      .filter((extension) => !!getExtensionConfigField(extension, 'addNodeView'))
      .map((extension) => {
        const extensionAttrs = this.attributes.filter((a) => a.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getNodeType(extension.name, this.schema),
        };
        const addNodeView = getExtensionConfigField(extension, 'addNodeView', context);
        if (!addNodeView) return null;
        const nodeViewFunction = addNodeView();
        if (!nodeViewFunction) return null;
        const nodeview = (node, _view, getPos, decorations) => {
          const htmlAttributes = Attribute.getAttributesToRender(node, extensionAttrs);
          return nodeViewFunction({
            editor,
            node,
            getPos,
            decorations,
            htmlAttributes,
            extension,
          });
        };
        return [extension.name, nodeview];
      })
      .filter(Boolean);
    return Object.fromEntries(entries);
  }
};
_ExtensionService_instances = new WeakSet();
/**
 * Install all extensions.
 * Create extension storage in the editor, attach editor events.
 */
setupExtensions_fn = function () {
  for (const extension of this.extensions) {
    this.editor.extensionStorage[extension.name] = extension.storage;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor: this.editor,
      type: getSchemaTypeByName(extension.name, this.schema),
    };
    if (extension.type === 'mark') {
      const keepOnSplit = callOrGet(getExtensionConfigField(extension, 'keepOnSplit', context)) ?? true;
      if (keepOnSplit) {
        this.splittableMarks.push(extension.name);
      }
    }
    __privateMethod(this, _ExtensionService_instances, attachEditorEvents_fn).call(this, extension);
  }
};
/**
 * Attach editor events to extension
 * if callbacks are defined in the extension config.
 * @param extension Extension.
 */
attachEditorEvents_fn = function (extension) {
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage,
    editor: this.editor,
    type: getSchemaTypeByName(extension.name, this.schema),
  };
  const onBeforeCreate = getExtensionConfigField(extension, 'onBeforeCreate', context);
  const onCreate = getExtensionConfigField(extension, 'onCreate', context);
  const onUpdate = getExtensionConfigField(extension, 'onUpdate', context);
  const onSelectionUpdate = getExtensionConfigField(extension, 'onSelectionUpdate', context);
  const onTransaction = getExtensionConfigField(extension, 'onTransaction', context);
  const onFocus = getExtensionConfigField(extension, 'onFocus', context);
  const onBlur = getExtensionConfigField(extension, 'onBlur', context);
  const onDestroy = getExtensionConfigField(extension, 'onDestroy', context);
  if (onBeforeCreate) this.editor.on('beforeCreate', onBeforeCreate);
  if (onCreate) this.editor.on('create', onCreate);
  if (onUpdate) this.editor.on('update', onUpdate);
  if (onSelectionUpdate) this.editor.on('selectionUpdate', onSelectionUpdate);
  if (onTransaction) this.editor.on('transaction', onTransaction);
  if (onFocus) this.editor.on('focus', onFocus);
  if (onBlur) this.editor.on('blur', onBlur);
  if (onDestroy) this.editor.on('destroy', onDestroy);
};
let ExtensionService = _ExtensionService;
const findTrackedMarkBetween = ({
  tr,
  from,
  to,
  markName,
  attrs = {},
  offset = 1,
  // To get non-inclusive marks.
}) => {
  const { doc } = tr;
  const startPos = Math.max(from - offset, 0);
  const endPos = Math.min(to + offset, doc.content.size);
  let markFound;
  doc.nodesBetween(startPos, endPos, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    const mark = node.marks.find(
      (mark2) => mark2.type.name === markName && Object.keys(attrs).every((attr) => mark2.attrs[attr] === attrs[attr]),
    );
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node.nodeSize,
        mark,
      };
    }
  });
  return markFound;
};
const markInsertion = ({ tr, from, to, user, date }) => {
  tr.removeMark(from, to, tr.doc.type.schema.marks[TrackDeleteMarkName]);
  tr.removeMark(from, to, tr.doc.type.schema.marks[TrackInsertMarkName]);
  let trackedMark = findTrackedMarkBetween({
    tr,
    from,
    to,
    markName: TrackInsertMarkName,
    attrs: { authorEmail: user.email },
  });
  let id;
  if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = v4();
  }
  const insertionMark = tr.doc.type.schema.marks[TrackInsertMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    authorImage: user.image,
    date,
  });
  tr.addMark(from, to, insertionMark);
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (pos < from || ['bulletList', 'orderedList'].includes(node.type.name)) {
      return true;
    } else if (node.isInline || ['tableRow', 'tableCell'].includes(node.type.name)) {
      return false;
    }
    if (node.attrs.track);
    if (node.type.name === 'table') {
      return false;
    }
  });
  return insertionMark;
};
const markDeletion = ({ tr, from, to, user, date, id: providedId }) => {
  let trackedMark = findTrackedMarkBetween({
    tr,
    from,
    to,
    markName: TrackDeleteMarkName,
    attrs: { authorEmail: user.email },
  });
  let id;
  if (providedId) {
    id = providedId;
  } else if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = v4();
  }
  const deletionMark = tr.doc.type.schema.marks[TrackDeleteMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    authorImage: user.image,
    date,
  });
  const deletionMap = new Mapping();
  let nodes = [];
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (node.type.name.includes('table')) {
      return;
    }
    if (
      node.isInline &&
      node.marks.find((mark) => mark.type.name === TrackInsertMarkName && mark.attrs.authorEmail === user.email)
    ) {
      const removeStep = new ReplaceStep(
        deletionMap.map(Math.max(from, pos)),
        deletionMap.map(Math.min(to, pos + node.nodeSize)),
        Slice.empty,
      );
      if (!tr.maybeStep(removeStep).failed) {
        deletionMap.appendMap(removeStep.getMap());
      }
    } else if (node.isInline && !node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      nodes.push(node);
      tr.addMark(
        deletionMap.map(Math.max(from, pos)),
        deletionMap.map(Math.min(to, pos + node.nodeSize)),
        deletionMark,
      );
    } else if (
      node.attrs.track &&
      !node.attrs.track.find((trackAttr) => trackAttr.type === TrackDeleteMarkName) &&
      !['bulletList', 'orderedList'].includes(node.type.name)
    );
  });
  return { deletionMark, deletionMap, nodes };
};
const flatten = (node, descend = true) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  }
  const result = [];
  node.descendants((child, pos) => {
    result.push({ node: child, pos });
    if (!descend) {
      return false;
    }
  });
  return result;
};
const findChildren$3 = (node, predicate, descend) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  } else if (!predicate) {
    throw new Error('Invalid "predicate" parameter');
  }
  return flatten(node, descend).filter((child) => predicate(child.node));
};
const findInlineNodes = (node, descend) => {
  return findChildren$3(node, (child) => child.isInline, descend);
};
const getTrackChanges = (state, id = null) => {
  const trackedChanges = [];
  const allInlineNodes = findInlineNodes(state.doc);
  if (!allInlineNodes.length) {
    return trackedChanges;
  }
  allInlineNodes.forEach(({ node, pos }) => {
    const { marks } = node;
    const trackedMarks = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
    if (marks.length > 0) {
      marks.forEach((mark) => {
        if (trackedMarks.includes(mark.type.name)) {
          trackedChanges.push({
            mark,
            from: pos,
            to: pos + node.nodeSize,
          });
        }
      });
    }
  });
  if (id) {
    return trackedChanges.filter(({ mark }) => mark.attrs.id === id);
  }
  return trackedChanges;
};
const TrackChangesBasePluginKey = new PluginKey('TrackChangesBase');
const TrackChangesBasePlugin = () => {
  return new Plugin({
    key: TrackChangesBasePluginKey,
    state: {
      init(_, state) {
        const decorations = getTrackChangesDecorations(state, false, false);
        return {
          isTrackChangesActive: false,
          onlyOriginalShown: false,
          onlyModifiedShown: false,
          decorations,
        };
      },
      apply(tr, oldState, prevEditorState, newEditorState) {
        const meta = tr.getMeta(TrackChangesBasePluginKey);
        if (meta && meta.type === 'TRACK_CHANGES_ENABLE') {
          return {
            ...oldState,
            isTrackChangesActive: meta.value === true,
            decorations: getTrackChangesDecorations(
              newEditorState,
              oldState.onlyOriginalShown,
              oldState.onlyModifiedShown,
            ),
          };
        }
        if (meta && meta.type === 'SHOW_ONLY_ORIGINAL') {
          return {
            ...oldState,
            onlyOriginalShown: meta.value === true,
            onlyModifiedShown: false,
            decorations: getTrackChangesDecorations(newEditorState, meta.value === true, false),
          };
        }
        if (meta && meta.type === 'SHOW_ONLY_MODIFIED') {
          return {
            ...oldState,
            onlyOriginalShown: false,
            onlyModifiedShown: meta.value === true,
            decorations: getTrackChangesDecorations(newEditorState, false, meta.value === true),
          };
        }
        if (!tr.docChanged) {
          return oldState;
        }
        if (!meta) {
          let mightAffectTrackChanges = false;
          tr.steps.forEach((step) => {
            if (step.slice || step.from !== step.to) {
              mightAffectTrackChanges = true;
            }
          });
          if (mightAffectTrackChanges) {
            return {
              ...oldState,
              decorations: getTrackChangesDecorations(
                newEditorState,
                oldState.onlyOriginalShown,
                oldState.onlyModifiedShown,
              ),
            };
          }
          return {
            ...oldState,
            decorations: oldState.decorations.map(tr.mapping, tr.doc),
          };
        }
        return {
          ...oldState,
          decorations: getTrackChangesDecorations(
            newEditorState,
            oldState.onlyOriginalShown,
            oldState.onlyModifiedShown,
          ),
        };
      },
    },
    props: {
      decorations(state) {
        return this.getState(state)?.decorations;
      },
    },
  });
};
const getTrackChangesDecorations = (state, onlyOriginalShown, onlyModifiedShown) => {
  if (!state.doc || !state.doc.nodeSize || (onlyModifiedShown && onlyOriginalShown)) {
    return DecorationSet.empty;
  }
  const decorations = [];
  const trackedChanges = getTrackChanges(state);
  if (!trackedChanges.length) {
    return DecorationSet.empty;
  }
  trackedChanges.forEach(({ mark, from, to }) => {
    if (mark.type.name === TrackInsertMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from, to, {
          class: 'track-insert-dec hidden',
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from, to, {
          class: 'track-insert-dec normal',
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from, to, {
          class: 'track-insert-dec highlighted',
        });
        decorations.push(decoration);
      }
    }
    if (mark.type.name === TrackDeleteMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from, to, {
          class: 'track-delete-dec normal',
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from, to, {
          class: 'track-delete-dec hidden',
        });
        decorations.push(decoration);
      } else {
        const decorationInline = Decoration.inline(from, to, {
          class: 'track-delete-dec highlighted',
          // 'hidden'
        });
        decorations.push(decorationInline);
        const decorationWidget = Decoration.widget(
          from,
          () => {
            const span = document.createElement('span');
            span.classList.add('track-delete-widget');
            return span;
          },
          {
            ignoreSelection: true,
            key: 'stable-key',
          },
        );
        decorations.push(decorationWidget);
      }
    }
    if (mark.type.name === TrackFormatMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from, to, {
          class: 'track-format-dec before',
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from, to, {
          class: 'track-format-dec normal',
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from, to, {
          class: 'track-format-dec highlighted',
        });
        decorations.push(decoration);
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
};
const CommentMarkName = 'commentMark';
const resolveCommentMeta = ({ converter, importedId }) => {
  const comments = converter?.comments || [];
  const matchingImportedComment = comments.find((c) => c.importedId == importedId);
  const resolvedCommentId = matchingImportedComment?.commentId ?? (importedId ? String(importedId) : v4());
  const internal = matchingImportedComment?.internal ?? matchingImportedComment?.isInternal ?? false;
  return {
    resolvedCommentId,
    importedId,
    internal,
    matchingImportedComment,
  };
};
const ensureFallbackComment = ({ converter, matchingImportedComment, commentId, importedId }) => {
  if (matchingImportedComment || !converter) return;
  converter.comments = converter.comments || [];
  const alreadyExists = converter.comments.some((comment) => comment.commentId === commentId);
  if (alreadyExists) return;
  converter.comments.push({
    commentId,
    importedId,
    textJson: null,
    creatorName: null,
    creatorEmail: null,
    createdTime: null,
    isDone: false,
  });
};
const removeCommentsById = ({ commentId, state, tr, dispatch }) => {
  const positions = getCommentPositionsById(commentId, state.doc);
  positions.forEach(({ from, to }) => {
    tr.removeMark(from, to, state.schema.marks[CommentMarkName]);
  });
  dispatch(tr);
};
const getCommentPositionsById = (commentId, doc) => {
  const positions = [];
  doc.descendants((node, pos) => {
    const { marks } = node;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      const { attrs } = commentMark;
      const { commentId: currentCommentId } = attrs;
      if (commentId === currentCommentId) {
        positions.push({ from: pos, to: pos + node.nodeSize });
      }
    }
  });
  return positions;
};
const prepareCommentsForExport = (doc, tr, schema, comments = []) => {
  const startNodes = [];
  const endNodes = [];
  const seen = /* @__PURE__ */ new Set();
  doc.descendants((node, pos) => {
    const commentMarks = node.marks?.filter((mark) => mark.type.name === CommentMarkName);
    commentMarks.forEach((commentMark) => {
      if (commentMark) {
        const { attrs = {} } = commentMark;
        const { commentId } = attrs;
        if (commentId === 'pending') return;
        if (seen.has(commentId)) return;
        seen.add(commentId);
        const commentStartNodeAttrs = getPreparedComment(commentMark.attrs);
        const startNode = schema.nodes.commentRangeStart.create(commentStartNodeAttrs);
        startNodes.push({
          pos,
          node: startNode,
        });
        const endNode = schema.nodes.commentRangeEnd.create(commentStartNodeAttrs);
        endNodes.push({
          pos: pos + node.nodeSize,
          node: endNode,
        });
        const parentId = commentId;
        if (parentId) {
          const childComments = comments
            .filter((c) => c.parentCommentId === parentId)
            .sort((a, b) => a.createdTime - b.createdTime);
          childComments.forEach((c) => {
            const childMark = getPreparedComment(c);
            const childStartNode = schema.nodes.commentRangeStart.create(childMark);
            seen.add(c.commentId);
            startNodes.push({
              pos,
              node: childStartNode,
            });
            const childEndNode = schema.nodes.commentRangeEnd.create(childMark);
            endNodes.push({
              pos: pos + node.nodeSize,
              node: childEndNode,
            });
          });
        }
      }
    });
  });
  startNodes.forEach((n) => {
    const { pos, node } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node);
  });
  endNodes.forEach((n) => {
    const { pos, node } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node);
  });
  return tr;
};
const getPreparedComment = (attrs) => {
  const { commentId, internal } = attrs;
  return {
    'w:id': commentId,
    internal,
  };
};
const prepareCommentsForImport = (doc, tr, schema, converter) => {
  const toMark = [];
  const toDelete = [];
  doc.descendants((node, pos) => {
    const { type } = node;
    const commentNodes = ['commentRangeStart', 'commentRangeEnd', 'commentReference'];
    if (!commentNodes.includes(type.name)) return;
    const { resolvedCommentId, importedId, internal, matchingImportedComment } = resolveCommentMeta({
      converter,
      importedId: node.attrs['w:id'],
    });
    if (type.name === 'commentRangeStart') {
      toMark.push({
        commentId: resolvedCommentId,
        importedId,
        internal,
        start: pos,
      });
      ensureFallbackComment({
        converter,
        matchingImportedComment,
        commentId: resolvedCommentId,
        importedId,
      });
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type.name === 'commentRangeEnd') {
      const itemToMark = toMark.find((p) => p.importedId === importedId);
      if (!itemToMark) return;
      const { start } = itemToMark;
      const markAttrs = {
        commentId: itemToMark.commentId,
        importedId,
        internal: itemToMark.internal,
      };
      tr.addMark(start, pos + 1, schema.marks[CommentMarkName].create(markAttrs));
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type.name === 'commentReference') {
      toDelete.push({ start: pos, end: pos + 1 });
    }
  });
  toDelete
    .sort((a, b) => b.start - a.start)
    .forEach(({ start, end }) => {
      tr.delete(start, end);
    });
};
const translateFormatChangesToEnglish = (attrs = {}) => {
  const { before = [], after = [] } = attrs;
  const beforeTypes = new Set(before.map((mark) => mark.type));
  const afterTypes = new Set(after.map((mark) => mark.type));
  const added = [...afterTypes].filter((type) => !beforeTypes.has(type));
  const removed = [...beforeTypes].filter((type) => !afterTypes.has(type));
  const messages = [];
  const nonTextStyleAdded = added.filter((type) => !['textStyle', 'commentMark'].includes(type));
  if (nonTextStyleAdded.length) {
    messages.push(`Added formatting: ${nonTextStyleAdded.join(', ')}`);
  }
  const nonTextStyleRemoved = removed.filter((type) => !['textStyle', 'commentMark'].includes(type));
  if (nonTextStyleRemoved.length) {
    messages.push(`Removed formatting: ${nonTextStyleRemoved.join(', ')}`);
  }
  const beforeTextStyle = before.find((mark) => mark.type === 'textStyle')?.attrs || {};
  const afterTextStyle = after.find((mark) => mark.type === 'textStyle')?.attrs || {};
  const textStyleChanges = [];
  const formatAttrName = (attr) => attr.replace(/([a-z])([A-Z])/g, '$1 $2').toLowerCase();
  Object.keys({ ...beforeTextStyle, ...afterTextStyle }).forEach((attr) => {
    const beforeValue = beforeTextStyle[attr];
    const afterValue = afterTextStyle[attr];
    if (beforeValue !== afterValue) {
      if (afterValue === null) {
        return;
      } else if (attr === 'color') {
        textStyleChanges.push(`Changed color`);
      } else {
        const label = formatAttrName(attr);
        if (beforeValue === void 0 || beforeValue === null) {
          textStyleChanges.push(`Set ${label} to ${afterValue}`);
        } else {
          textStyleChanges.push(`Changed ${label} from ${beforeValue} to ${afterValue}`);
        }
      }
    }
  });
  if (textStyleChanges.length) {
    messages.push(`Modified text style: ${textStyleChanges.join(', ')}`);
  }
  return messages.length ? messages.join('. ') : 'No formatting changes.';
};
const getHighlightColor = ({ activeThreadId, threadId, isInternal, editor }) => {
  if (!editor.options.isInternal && isInternal) return 'transparent';
  const pluginState = CommentsPluginKey.getState(editor.state);
  const color = isInternal ? pluginState.internalColor : pluginState.externalColor;
  const alpha = activeThreadId == threadId ? '44' : '22';
  return `${color}${alpha}`;
};
const updateYdocDocxData = async (editor, ydoc) => {
  ydoc = ydoc || editor.options.ydoc;
  if (!ydoc) return;
  if (!editor || editor.isDestroyed) return;
  const metaMap = ydoc.getMap('meta');
  const docxValue = metaMap.get('docx');
  let docx = [];
  if (Array.isArray(docxValue)) {
    docx = [...docxValue];
  } else if (docxValue && typeof docxValue.toArray === 'function') {
    docx = docxValue.toArray();
  } else if (docxValue && typeof docxValue[Symbol.iterator] === 'function') {
    docx = Array.from(docxValue);
  }
  if (!docx.length && Array.isArray(editor.options.content)) {
    docx = [...editor.options.content];
  }
  const newXml = await editor.exportDocx({ getUpdatedDocs: true });
  Object.keys(newXml).forEach((key2) => {
    const fileIndex = docx.findIndex((item) => item.name === key2);
    if (fileIndex > -1) {
      docx.splice(fileIndex, 1);
    }
    docx.push({
      name: key2,
      content: newXml[key2],
    });
  });
  ydoc.transact(
    () => {
      metaMap.set('docx', docx);
    },
    { event: 'docx-update', user: editor.options.user },
  );
};
const STYLE_ISOLATION_CLASS = 'sd-editor-scoped';
const applyStyleIsolationClass = (target) => {
  if (!target || !target.classList) return;
  target.classList.add(STYLE_ISOLATION_CLASS);
};
const isHeadless = (editor) => {
  return editor?.options?.isHeadless ?? false;
};
const shouldSkipNodeView = (editor) => {
  return isHeadless(editor);
};
const PaginationPluginKey = new PluginKey('paginationPlugin');
const initPaginationData = async (editor) => {
  if (isHeadless(editor) || !editor.converter) return;
  const sectionData = { headers: {}, footers: {} };
  const headerIds = editor.converter.headerIds.ids;
  const footerIds = editor.converter.footerIds.ids;
  for (let key2 in headerIds) {
    const sectionId = headerIds[key2];
    if (!sectionId) continue;
    const dataForThisSection = editor.converter.headers[sectionId];
    if (!sectionData.headers[sectionId]) sectionData.headers[sectionId] = {};
    sectionData.headers[sectionId].data = dataForThisSection;
    const { height, sectionEditor, sectionContainer } = await getSectionHeight(editor, dataForThisSection);
    sectionData.headers[sectionId].height = height;
    sectionData.headers[sectionId].sectionEditor = sectionEditor;
    sectionData.headers[sectionId].sectionContainer = sectionContainer;
  }
  for (let key2 in footerIds) {
    const sectionId = footerIds[key2];
    if (!sectionId) continue;
    const dataForThisSection = editor.converter.footers[sectionId];
    if (!sectionData.headers[sectionId]) sectionData.footers[sectionId] = {};
    sectionData.footers[sectionId].data = dataForThisSection;
    const { height, sectionEditor, sectionContainer } = await getSectionHeight(editor, dataForThisSection);
    sectionData.footers[sectionId].height = height;
    sectionData.footers[sectionId].sectionEditor = sectionEditor;
    sectionData.footers[sectionId].sectionContainer = sectionContainer;
  }
  return sectionData;
};
const getSectionHeight = async (editor, data) => {
  if (!data) return {};
  return new Promise((resolve) => {
    const editorContainer = document.createElement('div');
    editorContainer.className = 'super-editor';
    applyStyleIsolationClass(editorContainer);
    editorContainer.style.padding = '0';
    editorContainer.style.margin = '0';
    const sectionEditor = createHeaderFooterEditor({ editor, data, editorContainer });
    sectionEditor.on('create', () => {
      sectionEditor.setEditable(false, false);
      requestAnimationFrame(() => {
        const height = editorContainer.offsetHeight;
        document.body.removeChild(editorContainer);
        resolve({ height, sectionEditor, sectionContainer: editorContainer });
      });
    });
  });
};
const createHeaderFooterEditor = ({
  editor,
  data,
  editorContainer,
  appendToBody = true,
  sectionId,
  type,
  availableHeight,
  currentPageNumber,
}) => {
  const parentStyles = editor.converter.getDocumentDefaultStyles();
  const { fontSizePt, typeface, fontFamilyCss } = parentStyles;
  const fontSizeInPixles = fontSizePt * 1.3333;
  const lineHeight = fontSizeInPixles * 1.2;
  applyStyleIsolationClass(editorContainer);
  Object.assign(editorContainer.style, {
    padding: '0',
    margin: '0',
    border: 'none',
    boxSizing: 'border-box',
    position: 'absolute',
    top: '0',
    left: '0',
    width: 'auto',
    maxWidth: 'none',
    fontFamily: fontFamilyCss || typeface,
    fontSize: `${fontSizeInPixles}px`,
    lineHeight: `${lineHeight}px`,
  });
  Object.assign(editorContainer.style, {
    padding: '0',
    margin: '0',
    border: 'none',
    boxSizing: 'border-box',
    height: availableHeight + 'px',
    overflow: 'hidden',
  });
  if (appendToBody) document.body.appendChild(editorContainer);
  const headerFooterEditor = new Editor({
    role: editor.options.role,
    loadFromSchema: true,
    mode: 'docx',
    element: editorContainer,
    content: data,
    extensions: getStarterExtensions(),
    documentId: sectionId || 'sectionId',
    media: editor.storage.image.media,
    mediaFiles: editor.storage.image.media,
    fonts: editor.options.fonts,
    isHeaderOrFooter: true,
    isHeadless: editor.options.isHeadless,
    annotations: true,
    currentPageNumber,
    parentEditor: editor,
    editable: false,
    documentMode: 'viewing',
    onCreate: (evt) => setEditorToolbar(evt, editor),
    onBlur: (evt) => onHeaderFooterDataUpdate(evt, editor, sectionId, type),
  });
  headerFooterEditor.setEditable(false, false);
  const pm = editorContainer.querySelector('.ProseMirror');
  if (pm) {
    pm.style.maxHeight = '100%';
    pm.style.minHeight = '100%';
    pm.style.outline = 'none';
    pm.style.border = 'none';
    pm.setAttribute('role', 'textbox');
    pm.setAttribute('aria-multiline', true);
    pm.setAttribute('aria-label', `${type} content area. Double click to start typing.`);
  }
  return headerFooterEditor;
};
const broadcastEditorEvents = (editor, sectionEditor) => {
  const eventNames = [
    'fieldAnnotationDropped',
    'fieldAnnotationPaste',
    'fieldAnnotationSelected',
    'fieldAnnotationClicked',
    'fieldAnnotationDoubleClicked',
    'fieldAnnotationDeleted',
  ];
  eventNames.forEach((eventName) => {
    sectionEditor.on(eventName, (...args) => {
      editor.emit(eventName, ...args);
      console.debug('broadcastEditorEvents', { eventName, args });
    });
  });
};
const toggleHeaderFooterEditMode = ({ editor, focusedSectionEditor, isEditMode, documentMode }) => {
  if (isHeadless(editor)) return;
  editor.converter.headerEditors.forEach((item) => {
    item.editor.setEditable(isEditMode, false);
    item.editor.view.dom.setAttribute('aria-readonly', !isEditMode);
    item.editor.view.dom.setAttribute('documentmode', documentMode);
  });
  editor.converter.footerEditors.forEach((item) => {
    item.editor.setEditable(isEditMode, false);
    item.editor.view.dom.setAttribute('aria-readonly', !isEditMode);
    item.editor.view.dom.setAttribute('documentmode', documentMode);
  });
  if (isEditMode) {
    const pm = editor.view?.dom || editor.options.element?.querySelector?.('.ProseMirror');
    if (pm) {
      pm.classList.add('header-footer-edit');
      pm.setAttribute('aria-readonly', true);
    }
  }
  if (focusedSectionEditor) {
    focusedSectionEditor.view.focus();
  }
};
const onHeaderFooterDataUpdate = async ({ editor, transaction }, mainEditor, sectionId, type) => {
  if (!type || !sectionId) return;
  const updatedData = editor.getUpdatedJson();
  mainEditor.converter[`${type}Editors`].forEach((item) => {
    if (item.id === sectionId) {
      item.editor.setOptions({
        media: editor.options.media,
        mediaFiles: editor.options.mediaFiles,
      });
      item.editor.replaceContent(updatedData);
    }
    item.editor.setOptions({
      lastSelection: transaction?.selection,
    });
  });
  mainEditor.converter[`${type}s`][sectionId] = updatedData;
  mainEditor.setOptions({ isHeaderFooterChanged: editor.docChanged });
  await updateYdocDocxData(mainEditor);
};
const setEditorToolbar = ({ editor }, mainEditor) => {
  editor.setToolbar(mainEditor.toolbar);
};
const normalizeCommentEventPayload = ({ conversation, editorOptions, fallbackCommentId, fallbackInternal }) => {
  const { user, documentId } = editorOptions || {};
  const normalized = {
    ...conversation,
    commentId: conversation?.commentId ?? fallbackCommentId,
    isInternal: conversation?.isInternal ?? fallbackInternal,
  };
  if (!normalized.commentText && normalized.text) {
    normalized.commentText = normalized.text;
    delete normalized.text;
  }
  if ('skipEmit' in normalized) delete normalized.skipEmit;
  if (!normalized.creatorName && user?.name) {
    normalized.creatorName = user.name;
  }
  if (!normalized.creatorEmail && user?.email) {
    normalized.creatorEmail = user.email;
  }
  if (!normalized.creatorImage && user?.image) {
    normalized.creatorImage = user.image;
  }
  if (!normalized.createdTime) {
    normalized.createdTime = Date.now();
  }
  if (!normalized.fileId && documentId) {
    normalized.fileId = documentId;
  }
  if (!normalized.documentId && documentId) {
    normalized.documentId = documentId;
  }
  return normalized;
};
const updatePosition = ({ allCommentPositions, threadId, pos, currentBounds, node }) => {
  let bounds = {};
  if (currentBounds instanceof DOMRect) {
    bounds = {
      top: currentBounds.top,
      bottom: currentBounds.bottom,
      left: currentBounds.left,
      right: currentBounds.right,
    };
  } else {
    bounds = { ...currentBounds };
  }
  if (!allCommentPositions[threadId]) {
    allCommentPositions[threadId] = {
      threadId,
      start: pos,
      end: pos + node.nodeSize,
      bounds,
    };
  } else {
    const existing = allCommentPositions[threadId];
    existing.start = Math.min(existing.start, pos);
    existing.end = Math.max(existing.end, pos + node.nodeSize);
    existing.bounds.top = Math.min(existing.bounds.top, currentBounds.top);
    existing.bounds.bottom = Math.max(existing.bounds.bottom, currentBounds.bottom);
  }
};
const TRACK_CHANGE_MARKS = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
const CommentsPluginKey = new PluginKey('comments');
const CommentsPlugin = Extension.create({
  name: 'comments',
  addCommands() {
    return {
      insertComment:
        (conversation = {}) =>
        ({ tr, dispatch }) => {
          const { selection } = tr;
          const { $from, $to } = selection;
          const skipEmit = conversation?.skipEmit;
          const resolvedCommentId = conversation?.commentId ?? v4();
          const resolvedInternal = conversation?.isInternal ?? false;
          tr.setMeta(CommentsPluginKey, { event: 'add' });
          tr.addMark(
            $from.pos,
            $to.pos,
            this.editor.schema.marks[CommentMarkName].create({
              commentId: resolvedCommentId,
              internal: resolvedInternal,
            }),
          );
          if (dispatch) dispatch(tr);
          const shouldEmit = !skipEmit && resolvedCommentId !== 'pending';
          if (shouldEmit) {
            const commentPayload = normalizeCommentEventPayload({
              conversation,
              editorOptions: this.editor.options,
              fallbackCommentId: resolvedCommentId,
              fallbackInternal: resolvedInternal,
            });
            const activeCommentId = commentPayload.commentId || commentPayload.importedId || null;
            const event = {
              type: comments_module_events.ADD,
              comment: commentPayload,
              ...(activeCommentId && { activeCommentId }),
            };
            this.editor.emit('commentsUpdate', event);
          }
          return true;
        },
      removeComment:
        ({ commentId, importedId }) =>
        ({ tr, dispatch, state }) => {
          tr.setMeta(CommentsPluginKey, { event: 'deleted' });
          removeCommentsById({ commentId, state, tr, dispatch });
        },
      setActiveComment:
        ({ commentId }) =>
        ({ tr }) => {
          tr.setMeta(CommentsPluginKey, { type: 'setActiveComment', activeThreadId: commentId, forceUpdate: true });
          return true;
        },
      setCommentInternal:
        ({ commentId, isInternal }) =>
        ({ tr, dispatch, state }) => {
          const { doc } = state;
          let foundStartNode;
          let foundPos;
          tr.setMeta(CommentsPluginKey, { event: 'update' });
          doc.descendants((node, pos) => {
            if (foundStartNode) return;
            const { marks = [] } = node;
            const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
            if (commentMark) {
              const { attrs } = commentMark;
              const wid = attrs.commentId;
              if (wid === commentId) {
                foundStartNode = node;
                foundPos = pos;
              }
            }
          });
          if (!foundStartNode) return false;
          tr.addMark(
            foundPos,
            foundPos + foundStartNode.nodeSize,
            this.editor.schema.marks[CommentMarkName].create({
              commentId,
              internal: isInternal,
            }),
          );
          tr.setMeta(CommentsPluginKey, { type: 'setCommentInternal' });
          dispatch(tr);
          return true;
        },
      resolveComment:
        ({ commentId }) =>
        ({ tr, dispatch, state }) => {
          tr.setMeta(CommentsPluginKey, { event: 'update' });
          removeCommentsById({ commentId, state, tr, dispatch });
        },
      setCursorById:
        (id) =>
        ({ state, editor }) => {
          const { from } = findRangeById(state.doc, id) || {};
          if (from != null) {
            state.tr.setSelection(TextSelection.create(state.doc, from));
            editor.view.focus();
            return true;
          }
          return false;
        },
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    let shouldUpdate;
    if (editor.options.isHeadless) return [];
    const commentsPlugin = new Plugin({
      key: CommentsPluginKey,
      state: {
        init() {
          return {
            activeThreadId: null,
            externalColor: '#B1124B',
            internalColor: '#078383',
            decorations: DecorationSet.empty,
            allCommentPositions: {},
            allCommentIds: [],
            changedActiveThread: false,
            trackedChanges: {},
          };
        },
        apply(tr, pluginState, _, newEditorState) {
          const paginationMeta = tr.getMeta(PaginationPluginKey);
          const isPaginationInit = paginationMeta?.isReadyToInit;
          if (isPaginationInit) shouldUpdate = true;
          const meta = tr.getMeta(CommentsPluginKey);
          const { type } = meta || {};
          if (type === 'force' || type === 'forceTrackChanges') shouldUpdate = true;
          if (type === 'setActiveComment') {
            shouldUpdate = true;
            pluginState.activeThreadId = meta.activeThreadId;
            return {
              ...pluginState,
              activeThreadId: meta.activeThreadId,
              changedActiveThread: true,
            };
          }
          if (!isPaginationInit && !shouldUpdate && meta && meta.decorations) {
            return {
              ...pluginState,
              decorations: meta.decorations,
              allCommentPositions: meta.allCommentPositions,
            };
          }
          const trackedChangeMeta = tr.getMeta(TrackChangesBasePluginKey);
          const currentTrackedChanges = pluginState.trackedChanges;
          if (trackedChangeMeta) {
            pluginState.trackedChanges = handleTrackedChangeTransaction(
              trackedChangeMeta,
              currentTrackedChanges,
              newEditorState,
              editor,
            );
          }
          const trChangedActiveComment = meta?.type === 'setActiveComment';
          if ((!tr.docChanged && tr.selectionSet) || trChangedActiveComment) {
            const { selection } = tr;
            let currentActiveThread = getActiveCommentId(newEditorState.doc, selection);
            if (trChangedActiveComment) currentActiveThread = meta.activeThreadId;
            const previousSelectionId = pluginState.activeThreadId;
            if (previousSelectionId !== currentActiveThread) {
              pluginState.activeThreadId = currentActiveThread;
              const update = {
                type: comments_module_events.SELECTED,
                activeCommentId: currentActiveThread ? currentActiveThread : null,
              };
              shouldUpdate = true;
              editor.emit('commentsUpdate', update);
              const { tr: newTr } = editor.view.state;
              const { dispatch } = editor.view;
              newTr.setMeta(CommentsPluginKey, { type: 'force' });
              dispatch(newTr);
            }
          }
          return pluginState;
        },
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        },
      },
      view() {
        let prevDoc = null;
        let prevActiveThreadId = null;
        let prevAllCommentPositions = {};
        let hasEverEmitted = false;
        return {
          update(view) {
            const { state } = view;
            const { doc, tr } = state;
            const pluginState = CommentsPluginKey.getState(state);
            const currentActiveThreadId = pluginState.activeThreadId;
            const meta = tr.getMeta(CommentsPluginKey);
            if (meta?.type === 'setActiveComment' || meta?.forceUpdate) {
              shouldUpdate = true;
            }
            const docChanged = !prevDoc || !prevDoc.eq(doc);
            if (docChanged) shouldUpdate = true;
            const activeThreadChanged = prevActiveThreadId !== currentActiveThreadId;
            if (activeThreadChanged) {
              shouldUpdate = true;
              prevActiveThreadId = currentActiveThreadId;
            }
            const isInitialLoad = prevDoc === null;
            const onlyActiveThreadChanged = !isInitialLoad && !docChanged && activeThreadChanged;
            if (!shouldUpdate) return;
            prevDoc = doc;
            shouldUpdate = false;
            const decorations = [];
            const allCommentPositions = onlyActiveThreadChanged ? prevAllCommentPositions : {};
            doc.descendants((node, pos) => {
              const { marks = [] } = node;
              const commentMarks = marks.filter((mark) => mark.type.name === CommentMarkName);
              let hasActive = false;
              commentMarks.forEach((commentMark) => {
                const { attrs } = commentMark;
                const threadId = attrs.commentId || attrs.importedId;
                if (!onlyActiveThreadChanged) {
                  const currentBounds = view.coordsAtPos(pos);
                  updatePosition({
                    allCommentPositions,
                    threadId,
                    pos,
                    currentBounds,
                    node,
                  });
                }
                const isInternal = attrs.internal;
                if (!hasActive) hasActive = currentActiveThreadId === threadId;
                let color = getHighlightColor({
                  activeThreadId: currentActiveThreadId,
                  threadId,
                  isInternal,
                  editor,
                });
                const deco = Decoration.inline(pos, pos + node.nodeSize, {
                  style: `background-color: ${color};`,
                  'data-thread-id': threadId,
                  class: 'sd-editor-comment-highlight',
                });
                if (hasActive && currentActiveThreadId !== threadId) return;
                decorations.push(deco);
              });
              const trackedChangeMark = findTrackedMark({
                doc,
                from: pos,
                to: pos + node.nodeSize,
              });
              if (trackedChangeMark) {
                if (!onlyActiveThreadChanged) {
                  const currentBounds = view.coordsAtPos(pos);
                  const { id } = trackedChangeMark.mark.attrs;
                  updatePosition({
                    allCommentPositions,
                    threadId: id,
                    pos,
                    currentBounds,
                    node,
                  });
                }
                const isActiveTrackedChange = currentActiveThreadId === trackedChangeMark.mark.attrs.id;
                if (isActiveTrackedChange) {
                  const trackedChangeDeco = Decoration.inline(pos, pos + node.nodeSize, {
                    style: `border-width: 2px;`,
                    'data-thread-id': trackedChangeMark.mark.attrs.id,
                    class: 'sd-editor-tracked-change-highlight',
                  });
                  decorations.push(trackedChangeDeco);
                }
              }
            });
            const decorationSet = DecorationSet.create(doc, decorations);
            const oldDecorations = pluginState.decorations;
            const same = oldDecorations.eq(decorationSet);
            if (!same) {
              const tr2 = state.tr.setMeta(CommentsPluginKey, {
                decorations: decorationSet,
                allCommentPositions,
                forceUpdate: true,
              });
              view.dispatch(tr2);
            }
            if (!onlyActiveThreadChanged) {
              const positionsChanged = hasPositionsChanged(prevAllCommentPositions, allCommentPositions);
              const hasComments = Object.keys(allCommentPositions).length > 0;
              const shouldEmitPositions = positionsChanged || (!hasEverEmitted && hasComments);
              if (shouldEmitPositions) {
                prevAllCommentPositions = allCommentPositions;
                hasEverEmitted = true;
                editor.emit('comment-positions', { allCommentPositions });
              }
            }
          },
        };
      },
    });
    return [commentsPlugin];
  },
});
const hasPositionsChanged = (prevPositions, currPositions) => {
  const prevKeys = Object.keys(prevPositions);
  const currKeys = Object.keys(currPositions);
  if (prevKeys.length !== currKeys.length) return true;
  for (const key2 of currKeys) {
    const prev = prevPositions[key2];
    const curr = currPositions[key2];
    if (!prev || !prev.bounds || !curr.bounds) {
      return true;
    }
    if (prev.bounds.top !== curr.bounds.top || prev.bounds.left !== curr.bounds.left) {
      return true;
    }
  }
  return false;
};
const getActiveCommentId = (doc, selection) => {
  if (!selection) return;
  const { $from, $to } = selection;
  if ($from.pos !== $to.pos) return;
  const nodeAtPos = doc.nodeAt($from.pos);
  if (!nodeAtPos) return;
  const trackedChangeMark = findTrackedMark({
    doc,
    from: $from.pos,
    to: $to.pos,
  });
  if (trackedChangeMark) {
    return trackedChangeMark.mark.attrs.id;
  }
  const overlaps = [];
  let found = false;
  doc.descendants((node, pos) => {
    if (found) return;
    const end = pos + node.nodeSize;
    if ($from.pos < pos || $from.pos >= end) {
      return;
    }
    const { marks = [] } = node;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      overlaps.push({
        node,
        pos,
        size: node.nodeSize,
      });
    }
    if (pos > $from.pos) {
      found = true;
    }
  });
  let closest = null;
  let closestCommentRangeStart = null;
  overlaps.forEach(({ pos, node }) => {
    if (!closest) closest = $from.pos - pos;
    const diff = $from.pos - pos;
    if (diff >= 0 && diff <= closest) {
      closestCommentRangeStart = node;
      closest = diff;
    }
  });
  const { marks: closestMarks = [] } = closestCommentRangeStart || {};
  const closestCommentMark = closestMarks.find((mark) => mark.type.name === CommentMarkName);
  return closestCommentMark?.attrs?.commentId || closestCommentMark?.attrs?.importedId;
};
const findTrackedMark = ({
  doc,
  from,
  to,
  offset = 1,
  // To get non-inclusive marks.
}) => {
  const startPos = Math.max(from - offset, 0);
  const endPos = Math.min(to + offset, doc.content.size);
  let markFound;
  doc.nodesBetween(startPos, endPos, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    const mark = node.marks.find((mark2) => TRACK_CHANGE_MARKS.includes(mark2.type.name));
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node.nodeSize,
        mark,
      };
    }
  });
  return markFound;
};
const handleTrackedChangeTransaction = (trackedChangeMeta, trackedChanges, newEditorState, editor) => {
  const { insertedMark, deletionMark, formatMark, deletionNodes } = trackedChangeMeta;
  if (!insertedMark && !deletionMark && !formatMark) {
    return;
  }
  const newTrackedChanges = { ...trackedChanges };
  let id = insertedMark?.attrs?.id || deletionMark?.attrs?.id || formatMark?.attrs?.id;
  if (!id) {
    return trackedChanges;
  }
  let isNewChange = false;
  if (!newTrackedChanges[id]) {
    newTrackedChanges[id] = {};
    isNewChange = true;
  }
  if (insertedMark) newTrackedChanges[id].insertion = id;
  if (deletionMark) newTrackedChanges[id].deletion = deletionMark.attrs?.id;
  if (formatMark) newTrackedChanges[id].format = formatMark.attrs?.id;
  const { step } = trackedChangeMeta;
  let nodes = step?.slice?.content?.content || [];
  if (!nodes.length) {
    newEditorState.doc.descendants((node) => {
      const hasFormatMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      if (hasFormatMark) {
        nodes = [node];
        return false;
      }
    });
  }
  const emitParams = createOrUpdateTrackedChangeComment({
    documentId: editor.options.documentId,
    event: isNewChange ? 'add' : 'update',
    marks: {
      insertedMark,
      deletionMark,
      formatMark,
    },
    deletionNodes,
    nodes,
    newEditorState,
  });
  if (emitParams) editor.emit('commentsUpdate', emitParams);
  return newTrackedChanges;
};
const getTrackedChangeText = ({ nodes, mark, trackedChangeType, isDeletionInsertion }) => {
  let trackedChangeText = '';
  let deletionText = '';
  if (trackedChangeType === TrackInsertMarkName) {
    trackedChangeText = nodes.reduce((acc, node) => {
      if (!node.marks.find((nodeMark) => nodeMark.type.name === mark.type.name)) return acc;
      acc += node?.text || node?.textContent || '';
      return acc;
    }, '');
  }
  if (trackedChangeType === TrackFormatMarkName) {
    trackedChangeText = translateFormatChangesToEnglish(mark.attrs);
  }
  if (trackedChangeType === TrackDeleteMarkName || isDeletionInsertion) {
    deletionText = nodes.reduce((acc, node) => {
      if (!node.marks.find((nodeMark) => nodeMark.type.name === TrackDeleteMarkName)) return acc;
      acc += node?.text || node?.textContent || '';
      return acc;
    }, '');
  }
  return {
    deletionText,
    trackedChangeText,
  };
};
const createOrUpdateTrackedChangeComment = ({ event, marks, deletionNodes, nodes, newEditorState, documentId }) => {
  const trackedMark = marks.insertedMark || marks.deletionMark || marks.formatMark;
  const { type, attrs } = trackedMark;
  const { name: trackedChangeType } = type;
  const { author, authorEmail, authorImage, date, importedAuthor } = attrs;
  const id = attrs.id;
  const node = nodes[0];
  const isDeletionInsertion = !!(marks.insertedMark && marks.deletionMark);
  let nodesWithMark = [];
  newEditorState.doc.descendants((node2) => {
    const { marks: marks2 = [] } = node2;
    const changeMarks = marks2.filter((mark) => TRACK_CHANGE_MARKS.includes(mark.type.name));
    if (!changeMarks.length) return;
    const hasMatchingId = changeMarks.find((mark) => mark.attrs.id === id);
    if (hasMatchingId) nodesWithMark.push(node2);
  });
  const { deletionText, trackedChangeText } = getTrackedChangeText({
    nodes: nodesWithMark.length ? nodesWithMark : [node],
    mark: trackedMark,
    trackedChangeType,
    isDeletionInsertion,
  });
  if (!deletionText && !trackedChangeText) {
    return;
  }
  const params = {
    event: comments_module_events.ADD,
    type: 'trackedChange',
    documentId,
    changeId: id,
    trackedChangeType: isDeletionInsertion ? 'both' : trackedChangeType,
    trackedChangeText,
    deletedText: marks.deletionMark ? deletionText : null,
    author,
    authorEmail,
    ...(authorImage && { authorImage }),
    date,
    ...(importedAuthor && {
      importedAuthor: {
        name: importedAuthor,
      },
    }),
  };
  if (event === 'add') params.event = comments_module_events.ADD;
  else if (event === 'update') params.event = comments_module_events.UPDATE;
  return params;
};
function findRangeById(doc, id) {
  let from = null,
    to = null;
  doc.descendants((node, pos) => {
    const trackedMark = node.marks.find((m) => TRACK_CHANGE_MARKS.includes(m.type.name) && m.attrs.id === id);
    if (trackedMark) {
      if (from === null || pos < from) from = pos;
      if (to === null || pos + node.nodeSize > to) to = pos + node.nodeSize;
    }
    const commentMark = node.marks.find(
      (m) => m.type.name === CommentMarkName && (m.attrs.commentId === id || m.attrs.importedId === id),
    );
    if (commentMark) {
      if (from === null || pos < from) from = pos;
      if (to === null || pos + node.nodeSize > to) to = pos + node.nodeSize;
    }
  });
  return from !== null && to !== null ? { from, to } : null;
}
const replaceStep = ({ state, tr, step, newTr, map, user, date, originalStep, originalStepIndex }) => {
  const deletionMarkSchema = state.schema.marks[TrackDeleteMarkName];
  const deletionMark = findMark(state, deletionMarkSchema, false);
  const positionTo = deletionMark ? deletionMark.to : step.to;
  const newStep = new ReplaceStep(
    positionTo,
    // We insert all the same steps, but with "from"/"to" both set to "to" in order not to delete content. Mapped as needed.
    positionTo,
    step.slice,
    step.structure,
  );
  const invertStep = originalStep.invert(tr.docs[originalStepIndex]).map(map);
  map.appendMap(invertStep.getMap());
  const meta = {};
  if (newStep) {
    const trTemp = state.apply(newTr).tr;
    if (trTemp.maybeStep(newStep).failed) {
      return;
    }
    const mappedNewStepTo = newStep.getMap().map(newStep.to);
    const insertedMark = markInsertion({
      tr: trTemp,
      from: newStep.from,
      to: mappedNewStepTo,
      user,
      date,
    });
    const condensedStep = new ReplaceStep(newStep.from, newStep.to, trTemp.doc.slice(newStep.from, mappedNewStepTo));
    newTr.step(condensedStep);
    const mirrorIndex = map.maps.length - 1;
    map.appendMap(condensedStep.getMap(), mirrorIndex);
    if (newStep.from !== mappedNewStepTo) {
      meta.insertedMark = insertedMark;
      meta.step = condensedStep;
    }
    if (!newTr.selection.eq(trTemp.selection)) {
      newTr.setSelection(trTemp.selection);
    }
  }
  if (step.from !== step.to) {
    const {
      deletionMark: deletionMark2,
      deletionMap,
      nodes: deletionNodes,
    } = markDeletion({
      tr: newTr,
      from: step.from,
      to: step.to,
      user,
      date,
      id: meta.insertedMark?.attrs?.id,
    });
    meta.deletionNodes = deletionNodes;
    meta.deletionMark = deletionMark2;
    map.appendMapping(deletionMap);
  }
  newTr.setMeta(TrackChangesBasePluginKey, meta);
  newTr.setMeta(CommentsPluginKey, { type: 'force' });
};
const addMarkStep = ({ state, step, newTr, doc, user, date }) => {
  const meta = {};
  doc.nodesBetween(step.from, step.to, (node, pos) => {
    if (!node.isInline) {
      return;
    }
    if (node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      return false;
    }
    const existingChangeMark = node.marks.find((mark) =>
      [TrackDeleteMarkName, TrackFormatMarkName].includes(mark.type.name),
    );
    const wid = existingChangeMark ? existingChangeMark.attrs.id : v4();
    newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), step.mark);
    const allowedMarks = ['bold', 'italic', 'strike', 'underline', 'textStyle'];
    if (allowedMarks.includes(step.mark.type.name) && !node.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundBefore = formatChangeMark.attrs.before.find((mark) => {
          if (mark.type === 'textStyle') {
            return mark.type === step.mark.type.name && objectIncludes(mark.attrs, step.mark.attrs);
          }
          return mark.type === step.mark.type.name;
        });
        if (foundBefore) {
          before = [...formatChangeMark.attrs.before.filter((mark) => mark.type !== step.mark.type.name)];
          after = [...formatChangeMark.attrs.after];
        } else {
          before = [...formatChangeMark.attrs.before];
          after = [
            ...formatChangeMark.attrs.after,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs },
            },
          ];
        }
      } else {
        before = node.marks.map((mark) => ({
          type: mark.type.name,
          attrs: { ...mark.attrs },
        }));
        after = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs },
          },
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state.schema.marks[TrackFormatMarkName].create({
          id: wid,
          author: user.name,
          authorEmail: user.email,
          authorImage: user.image,
          date,
          before,
          after,
        });
        newTr.addMark(
          step.from,
          // Math.max(step.from, pos)
          step.to,
          // Math.min(step.to, pos + node.nodeSize),
          newFormatMark,
        );
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: 'force' });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), formatChangeMark);
      }
    }
  });
};
const removeMarkStep = ({ state, step, newTr, doc, user, date }) => {
  const meta = {};
  doc.nodesBetween(step.from, step.to, (node, pos) => {
    if (!node.isInline) {
      return true;
    }
    if (node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      return false;
    }
    newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), step.mark);
    const allowedMarks = ['bold', 'italic', 'strike', 'underline', 'textStyle'];
    if (allowedMarks.includes(step.mark.type.name) && node.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundAfter = formatChangeMark.attrs.after.find((mark) => mark.type === step.mark.type.name);
        if (foundAfter) {
          after = [...formatChangeMark.attrs.after.filter((mark) => mark.type !== step.mark.type.name)];
          before = [...formatChangeMark.attrs.before];
        } else {
          after = [...formatChangeMark.attrs.after];
          before = [
            ...formatChangeMark.attrs.before,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs },
            },
          ];
        }
      } else {
        after = [];
        before = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs },
          },
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state.schema.marks[TrackFormatMarkName].create({
          id: v4(),
          author: user.name,
          authorEmail: user.email,
          authorImage: user.image,
          date,
          before,
          after,
        });
        newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), newFormatMark);
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: 'force' });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), formatChangeMark);
      }
    }
  });
};
const trackedTransaction = ({ tr, state, user }) => {
  const onlyInputTypeMeta = ['inputType', 'uiEvent', 'paste', 'pointer'];
  const notAllowedMeta = ['historyUndo', 'historyRedo', 'acceptReject'];
  const isProgrammaticInput = tr.getMeta('inputType') === 'programmatic';
  if (
    !tr.steps.length ||
    (tr.meta && !Object.keys(tr.meta).every((meta) => onlyInputTypeMeta.includes(meta)) && !isProgrammaticInput) ||
    notAllowedMeta.includes(tr.getMeta('inputType')) ||
    tr.getMeta(CommentsPluginKey)
  ) {
    return tr;
  }
  const newTr = state.tr;
  const map = new Mapping();
  const fixedTimeTo10Mins = Math.floor(Date.now() / 6e5) * 6e5;
  const date = new Date(fixedTimeTo10Mins).toISOString();
  tr.steps.forEach((originalStep, originalStepIndex) => {
    const step = originalStep.map(map);
    const { doc } = newTr;
    if (!step) {
      return;
    }
    if (step instanceof ReplaceStep) {
      replaceStep({
        state,
        tr,
        step,
        newTr,
        map,
        user,
        date,
        originalStep,
        originalStepIndex,
      });
    } else if (step instanceof AddMarkStep) {
      addMarkStep({
        state,
        step,
        newTr,
        doc,
        user,
        date,
      });
    } else if (step instanceof RemoveMarkStep) {
      removeMarkStep({
        state,
        step,
        newTr,
        doc,
        user,
        date,
      });
    } else {
      newTr.step(step);
    }
  });
  if (tr.getMeta('inputType')) {
    newTr.setMeta('inputType', tr.getMeta('inputType'));
  }
  if (tr.getMeta('uiEvent')) {
    newTr.setMeta('uiEvent', tr.getMeta('uiEvent'));
  }
  if (tr.getMeta('addToHistory') !== void 0) {
    newTr.setMeta('addToHistory', tr.getMeta('addToHistory'));
  }
  if (tr.selectionSet) {
    const deletionMarkSchema = state.schema.marks[TrackDeleteMarkName];
    const deletionMark = findMark(state, deletionMarkSchema, false);
    if (
      tr.selection instanceof TextSelection &&
      (tr.selection.from < state.selection.from || tr.getMeta('inputType') === 'deleteContentBackward')
    ) {
      const caretPos = map.map(tr.selection.from, -1);
      newTr.setSelection(new TextSelection(newTr.doc.resolve(caretPos)));
    } else if (tr.selection.from > state.selection.from && deletionMark) {
      const caretPos = map.map(deletionMark.to + 1, 1);
      newTr.setSelection(new TextSelection(newTr.doc.resolve(caretPos)));
    } else {
      newTr.setSelection(tr.selection.map(newTr.doc, map));
    }
  } else if (state.selection.from - tr.selection.from > 1 && tr.selection.$head.depth > 1) {
    const caretPos = map.map(tr.selection.from - 2, -1);
    newTr.setSelection(new TextSelection(newTr.doc.resolve(caretPos)));
  } else;
  if (tr.storedMarksSet) {
    newTr.setStoredMarks(tr.storedMarks);
  }
  if (tr.scrolledIntoView) {
    newTr.scrollIntoView();
  }
  return newTr;
};
const migration_after_0_4_14 = (editor) => {
  const { state } = editor;
  const { dispatch } = editor.view;
  const { tr } = state;
  if (!dispatch) return;
  state.doc.descendants((node, pos) => {
    if (node.type.name === 'paragraph') {
      const { attrs } = node;
      const { spacing } = attrs;
      if (!spacing) return;
      const newSpacing = {
        line: twipsToLines(pixelsToTwips(spacing.line)),
        lineSpaceBefore: twipsToLines(pixelsToTwips(spacing.lineSpaceBefore)),
        lineSpaceAfter: twipsToLines(pixelsToTwips(spacing.lineSpaceAfter)),
      };
      tr.setNodeMarkup(pos, void 0, {
        ...attrs,
        spacing: {
          ...spacing,
          ...newSpacing,
        },
      });
    }
  });
  dispatch(tr);
  return true;
};
const DOCUMENT_MIGRATIONS = {
  initial: migration_after_0_4_14,
};
const getNecessaryMigrations = (version2) => {
  if (version2 === 'initial' || version2 === '0.4.14') return Object.values(DOCUMENT_MIGRATIONS);
};
const getFieldAttrs = (field, value, input) => {
  const { type } = field.attrs;
  const annotatorHandlers = {
    html: annotateHtml,
    text: annotateText,
    checkbox: annotateCheckbox,
    image: annotateImage,
    link: annotateLink,
    yesno: annotateYesNo,
    date: annotateDate,
  };
  const handler2 = annotatorHandlers[type];
  if (!handler2) return {};
  return handler2(value, input);
};
const annotateHtml = (value) => ({ rawHtml: value });
const annotateText = (value) => ({ displayLabel: value });
const annotateImage = (value) => ({ imageSrc: value });
const annotateCheckbox = (value) => ({ displayLabel: value });
const annotateDate = (value, input) => {
  const formatted = getFormattedDate(value, input.input_format);
  return { displayLabel: formatted };
};
const annotateLink = (value) => {
  if (!value.startsWith('http')) value = `http://${value}`;
  return { linkUrl: value };
};
const annotateYesNo = (value) => {
  const yesNoValues = {
    YES: 'Yes',
    NO: 'No',
  };
  const parsedValue = yesNoValues[value[0].toUpperCase()];
  return { displayLabel: parsedValue };
};
const processTables = ({ state, tr, annotationValues }) => {
  const { doc } = state;
  const tables = [];
  doc.descendants((node, pos) => {
    if (node.type.name === 'table') tables.push({ node, pos });
  });
  tables.reverse().forEach(({ pos }) => {
    const currentTableNode = tr.doc.nodeAt(pos);
    if (!currentTableNode || currentTableNode.type.name !== 'table') return;
    try {
      generateTableIfNecessary({ tableNode: { node: currentTableNode, pos }, annotationValues, tr, state });
    } catch (error) {
      console.error('Error generating table at pos', pos, ':', error);
    }
  });
  return tr;
};
const generateTableIfNecessary = ({ tableNode, annotationValues, tr, state }) => {
  const {
    tableRow: RowType,
    tableCell: CellType,
    fieldAnnotation: FieldType,
    paragraph: ParaType,
  } = state.schema.nodes;
  const rows = [];
  tableNode.node.descendants((node, pos) => {
    if (node.type === RowType) {
      rows.push({ node, pos });
    }
  });
  let rowNodeToGenerate = null;
  for (const row of rows) {
    let hasArrayAnnotation = false;
    row.node.descendants((node) => {
      if (node.type === FieldType) {
        const annotationValue = getAnnotationValue(node.attrs.fieldId, annotationValues);
        if (Array.isArray(annotationValue) && node.attrs.generatorIndex === null) {
          hasArrayAnnotation = true;
        }
      }
    });
    if (hasArrayAnnotation) {
      rowNodeToGenerate = row;
      break;
    }
  }
  if (!rowNodeToGenerate) return;
  const { node: rowNode, pos: rowStartPos } = rowNodeToGenerate;
  const absoluteRowStart = tableNode.pos + 1 + rowStartPos;
  let rowsToGenerate = 0;
  rowNode.descendants((childNode) => {
    if (childNode.type === FieldType) {
      const annotationValue = getAnnotationValue(childNode.attrs.fieldId, annotationValues);
      if (Array.isArray(annotationValue)) {
        rowsToGenerate = Math.max(rowsToGenerate, annotationValue.length);
      }
    }
  });
  if (rowsToGenerate <= 1) return;
  const validateAttributes = (attrs) => {
    const cleaned = {};
    for (const [key2, value] of Object.entries(attrs)) {
      if (value !== void 0 && value !== null) {
        if (key2 === 'displayLabel') {
          cleaned[key2] = String(value);
        } else if (key2 === 'rawHtml' || key2 === 'linkUrl' || key2 === 'imageSrc') {
          cleaned[key2] = String(value);
        } else if (typeof value === 'string' && value.length > 0) {
          cleaned[key2] = value;
        } else if (typeof value !== 'string') {
          cleaned[key2] = value;
        }
      }
    }
    return cleaned;
  };
  const rebuildCell = (cellNode, rowIndex) => {
    try {
      const updatedBlocks = cellNode.content.content.map((blockNode) => {
        if (blockNode.type !== ParaType) return blockNode;
        const updatedInlines = blockNode.content.content.map((inlineNode) => {
          if (inlineNode.type !== FieldType) return inlineNode;
          let matchedAnnotationValues = getAnnotationValue(inlineNode.attrs.fieldId, annotationValues);
          if (!Array.isArray(matchedAnnotationValues)) {
            matchedAnnotationValues = [matchedAnnotationValues];
          }
          const value = matchedAnnotationValues[rowIndex];
          let extraAttrs = {};
          try {
            const rawExtraAttrs = getFieldAttrs(inlineNode, value, null);
            extraAttrs = validateAttributes(rawExtraAttrs || {});
          } catch (error) {
            console.error('Error getting field attrs:', error);
            extraAttrs = {};
          }
          const baseAttrs = validateAttributes(inlineNode.attrs || {});
          const newAttrs = {
            ...baseAttrs,
            ...extraAttrs,
            generatorIndex: rowIndex,
          };
          try {
            return FieldType.create(newAttrs, inlineNode.content || Fragment.empty, inlineNode.marks || []);
          } catch (error) {
            console.error('Error creating field node:', error);
            try {
              const fallbackAttrs = {
                ...baseAttrs,
                generatorIndex: rowIndex,
                displayLabel: String(value || ''),
              };
              return FieldType.create(
                validateAttributes(fallbackAttrs),
                inlineNode.content || Fragment.empty,
                inlineNode.marks || [],
              );
            } catch (fallbackError) {
              console.error('Fallback also failed:', fallbackError);
              return inlineNode;
            }
          }
        });
        try {
          return ParaType.create(
            validateAttributes(blockNode.attrs || {}),
            Fragment.from(updatedInlines),
            blockNode.marks || [],
          );
        } catch (error) {
          console.error('Error creating paragraph node:', error);
          return blockNode;
        }
      });
      return CellType.create(
        validateAttributes(cellNode.attrs || {}),
        Fragment.from(updatedBlocks),
        cellNode.marks || [],
      );
    } catch (error) {
      console.error(`Failed to rebuild cell for row ${rowIndex}:`, error);
      throw error;
    }
  };
  try {
    const newRows = [];
    for (let rowIndex = 0; rowIndex < rowsToGenerate; rowIndex++) {
      const newCells = rowNode.content.content.map((cellNode) => rebuildCell(cellNode, rowIndex));
      const newRow = RowType.create(
        validateAttributes(rowNode.attrs || {}),
        Fragment.from(newCells),
        rowNode.marks || [],
      );
      newRows.push(newRow);
    }
    const mappedRowStart = tr.mapping.map(absoluteRowStart);
    const rowEnd = mappedRowStart + rowNode.nodeSize;
    tr.replaceWith(mappedRowStart, rowEnd, Fragment.from(newRows));
    tr.setMeta('tableGeneration', true);
  } catch (error) {
    console.error('Error during row generation:', error);
    throw error;
  }
};
const getAnnotationValue = (id, annotationValues) => {
  return annotationValues.find((value) => value.input_id === id)?.input_value || null;
};
const getAllHeaderFooterEditors = (editor) => {
  const sections = {
    header: editor.converter.headers || {},
    footer: editor.converter.footers || {},
  };
  const allEditors = [];
  Object.entries(sections).forEach(([type, items]) => {
    const editorsKey = `${type}Editors`;
    Object.entries(items).forEach(([sectionId, data]) => {
      let sectionEditor = editor.converter[editorsKey][sectionId];
      if (!sectionEditor) {
        sectionEditor = {
          id: sectionId,
          editor: createHeaderFooterEditor({
            editor,
            data,
            editorContainer: document.createElement('div'),
            appendToBody: false,
            sectionId,
            type,
          }),
        };
        editor.converter[editorsKey].push(sectionEditor);
        allEditors.push({
          ...sectionEditor,
          key: editorsKey,
          type,
          sectionId,
        });
      }
    });
  });
  return allEditors;
};
const annotateHeadersAndFooters = ({
  editor,
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false,
}) => {
  const allEditors = getAllHeaderFooterEditors(editor);
  allEditors.forEach(({ sectionId, editor: sectionEditor, type }) => {
    sectionEditor.annotate(annotationValues, hiddenFieldIds, removeEmptyFields);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const annotateDocument = ({
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false,
  schema,
  tr,
  editor,
}) => {
  annotateHeadersAndFooters({ editor, annotationValues, hiddenFieldIds, removeEmptyFields });
  const annotations = [];
  const FieldType = schema.nodes.fieldAnnotation;
  tr.doc.descendants((node, pos) => {
    if (node.type === FieldType) {
      annotations.push({ node, pos, size: node.nodeSize });
    }
  });
  const toDelete = /* @__PURE__ */ new Set();
  if (hiddenFieldIds.length) {
    for (const { node, pos } of annotations) {
      if (hiddenFieldIds.includes(node.attrs.fieldId)) {
        toDelete.add(pos);
      }
    }
  }
  for (const { node, pos } of annotations) {
    const { type, fieldType, fieldId } = node.attrs;
    if (toDelete.has(pos)) continue;
    let newValue = null;
    const input = annotationValues.find((i) => i.input_id === fieldId);
    if (!input) {
      const checkboxInputs = annotationValues.filter((i) => i.input_field_type === 'CHECKBOXINPUT');
      inputsLoop: for (const cb of checkboxInputs) {
        for (const opt of cb.input_options) {
          if (opt.itemid === fieldId) {
            newValue = cb.input_link_value[opt.itemid] || ' ';
            break inputsLoop;
          }
        }
      }
    }
    newValue = newValue || input?.input_value || null;
    if (Array.isArray(newValue) && node.attrs.generatorIndex != null) {
      continue;
    }
    if (type === 'checkbox' || fieldType === 'CHECKBOXINPUT') {
      const isEmptyOrSquare = !newValue || (typeof newValue === 'string' && newValue.codePointAt(0) === 9744);
      if (isEmptyOrSquare) newValue = ' ';
    }
    if (!newValue) {
      toDelete.add(pos);
    } else {
      const attrs = getFieldAttrs(node, newValue, input);
      tr = tr.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        ...attrs,
      });
    }
  }
  if (removeEmptyFields) {
    Array.from(toDelete)
      .sort((a, b) => b - a)
      .forEach((pos) => {
        const ann = annotations.find((a) => a.pos === pos);
        if (!ann) return;
        tr = tr.delete(pos, pos + ann.node.nodeSize);
      });
  }
  return tr;
};
const getFormattedDate = (input = null, format = '') => {
  const date = input ? new Date(input) : /* @__PURE__ */ new Date();
  if (isNaN(date.getTime())) {
    return input;
  }
  if (format) return dateFormat(date, format);
  return date.toLocaleDateString('en-US', {
    month: 'short',
    // e.g. May
    day: '2-digit',
    // e.g. 05
    year: 'numeric',
    // e.g. 2025
  });
};
const updateHeaderFooterFieldAnnotations = ({ editor, fieldIdOrArray, attrs = {} }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type }) => {
    sectionEditor.commands.updateFieldAnnotations(fieldIdOrArray, attrs);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const deleteHeaderFooterFieldAnnotations = ({ editor, fieldIdOrArray }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type }) => {
    sectionEditor.commands.deleteFieldAnnotations(fieldIdOrArray);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const resetHeaderFooterFieldAnnotations = ({ editor }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type }) => {
    sectionEditor.commands.resetFieldAnnotations();
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const AnnotatorHelpers = {
  getFieldAttrs,
  processTables,
  annotateDocument,
  annotateHeadersAndFooters,
  getAllHeaderFooterEditors,
  updateHeaderFooterFieldAnnotations,
  deleteHeaderFooterFieldAnnotations,
  resetHeaderFooterFieldAnnotations,
};
const isXmlLike = (name) => /\.xml$|\.rels$/i.test(name);
function sniffEncoding(u8) {
  if (u8.length >= 2) {
    const b0 = u8[0],
      b1 = u8[1];
    if (b0 === 255 && b1 === 254) return 'utf-16le';
    if (b0 === 254 && b1 === 255) return 'utf-16be';
  }
  let nul = 0;
  for (let i = 0; i < Math.min(64, u8.length); i++) if (u8[i] === 0) nul++;
  if (nul > 16) return 'utf-16le';
  return 'utf-8';
}
function stripBOM(str) {
  return str && str.charCodeAt(0) === 65279 ? str.slice(1) : str;
}
function ensureXmlString(content) {
  if (typeof content === 'string') return stripBOM(content);
  let u8 = null;
  if (content && typeof content === 'object') {
    if (content instanceof Uint8Array) {
      u8 = content;
    } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(content)) {
      u8 = new Uint8Array(content.buffer, content.byteOffset, content.byteLength);
    } else if (ArrayBuffer.isView && ArrayBuffer.isView(content)) {
      u8 = new Uint8Array(content.buffer, content.byteOffset, content.byteLength);
    } else if (content.constructor && (content instanceof ArrayBuffer || content.constructor.name === 'ArrayBuffer')) {
      u8 = new Uint8Array(content);
    }
  }
  if (!u8) throw new Error('Unsupported content type for XML');
  const enc = sniffEncoding(u8);
  let xml = new TextDecoder(enc).decode(u8);
  return stripBOM(xml);
}
class DocxZipper {
  constructor(params = {}) {
    this.debug = params.debug || false;
    this.zip = new JSZip();
    this.files = [];
    this.media = {};
    this.mediaFiles = {};
    this.fonts = {};
  }
  /**
   * Get all docx data from the zipped docx
   *
   * [ContentTypes].xml
   * _rels/.rels
   * word/document.xml
   * word/_rels/document.xml.rels
   * word/footnotes.xml
   * word/endnotes.xml
   * word/header1.xml
   * word/theme/theme1.xml
   * word/settings.xml
   * word/styles.xml
   * word/webSettings.xml
   * word/fontTable.xml
   * docProps/core.xml
   * docProps/app.xml
   * */
  async getDocxData(file, isNode = false) {
    const extractedFiles = await this.unzip(file);
    const files = Object.entries(extractedFiles.files);
    for (const [, zipEntry] of files) {
      const name = zipEntry.name;
      if (isXmlLike(name)) {
        const u8 = await zipEntry.async('uint8array');
        const content = ensureXmlString(u8);
        this.files.push({ name, content });
      } else if (
        (name.startsWith('word/media') && name !== 'word/media/') ||
        (zipEntry.name.startsWith('media') && zipEntry.name !== 'media/') ||
        (name.startsWith('media') && name !== 'media/')
      ) {
        if (isNode) {
          const buffer = await zipEntry.async('nodebuffer');
          const fileBase64 = buffer.toString('base64');
          this.mediaFiles[name] = fileBase64;
        } else {
          const blob = await zipEntry.async('blob');
          const extension = this.getFileExtension(name);
          const fileBase64 = await zipEntry.async('base64');
          this.mediaFiles[name] = `data:image/${extension};base64,${fileBase64}`;
          const fileObj = new File([blob], name, { type: blob.type });
          const imageUrl = URL.createObjectURL(fileObj);
          this.media[name] = imageUrl;
        }
      } else if (name.startsWith('word/fonts') && name !== 'word/fonts/') {
        const uint8array = await zipEntry.async('uint8array');
        this.fonts[name] = uint8array;
      }
    }
    return this.files;
  }
  getFileExtension(fileName) {
    const fileSplit = fileName.split('.');
    if (fileSplit.length < 2) return null;
    return fileSplit[fileSplit.length - 1];
  }
  /**
   * Update [Content_Types].xml with extensions of new Image annotations
   */
  async updateContentTypes(docx, media, fromJson, updatedDocs = {}) {
    const additionalPartNames = Object.keys(updatedDocs || {});
    const newMediaTypes = Object.keys(media)
      .map((name) => {
        return this.getFileExtension(name);
      })
      .filter(Boolean);
    const contentTypesPath = '[Content_Types].xml';
    let contentTypesXml;
    if (fromJson) {
      if (Array.isArray(docx.files)) {
        contentTypesXml = docx.files.find((file) => file.name === contentTypesPath)?.content || '';
      } else {
        contentTypesXml = docx.files?.[contentTypesPath] || '';
      }
    } else contentTypesXml = await docx.file(contentTypesPath).async('string');
    let typesString = '';
    const defaultMediaTypes = getContentTypesFromXml(contentTypesXml);
    const seenTypes = /* @__PURE__ */ new Set();
    for (let type of newMediaTypes) {
      if (defaultMediaTypes.includes(type)) continue;
      if (seenTypes.has(type)) continue;
      const newContentType = `<Default Extension="${type}" ContentType="image/${type}"/>`;
      typesString += newContentType;
      seenTypes.add(type);
    }
    const xmlJson = JSON.parse(xmljs.xml2json(contentTypesXml, null, 2));
    const types = xmlJson.elements?.find((el) => el.name === 'Types') || {};
    const hasComments = types.elements?.some(
      (el) => el.name === 'Override' && el.attributes.PartName === '/word/comments.xml',
    );
    const hasCommentsExtended = types.elements?.some(
      (el) => el.name === 'Override' && el.attributes.PartName === '/word/commentsExtended.xml',
    );
    const hasCommentsIds = types.elements?.some(
      (el) => el.name === 'Override' && el.attributes.PartName === '/word/commentsIds.xml',
    );
    const hasCommentsExtensible = types.elements?.some(
      (el) => el.name === 'Override' && el.attributes.PartName === '/word/commentsExtensible.xml',
    );
    const hasFile = (filename) => {
      if (!docx?.files) return false;
      if (!fromJson) return Boolean(docx.files[filename]);
      if (Array.isArray(docx.files)) return docx.files.some((file) => file.name === filename);
      return Boolean(docx.files[filename]);
    };
    if (hasFile('word/comments.xml')) {
      const commentsDef = `<Override PartName="/word/comments.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml" />`;
      if (!hasComments) typesString += commentsDef;
    }
    if (hasFile('word/commentsExtended.xml')) {
      const commentsExtendedDef = `<Override PartName="/word/commentsExtended.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml" />`;
      if (!hasCommentsExtended) typesString += commentsExtendedDef;
    }
    if (hasFile('word/commentsIds.xml')) {
      const commentsIdsDef = `<Override PartName="/word/commentsIds.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml" />`;
      if (!hasCommentsIds) typesString += commentsIdsDef;
    }
    if (hasFile('word/commentsExtensible.xml')) {
      const commentsExtendedDef = `<Override PartName="/word/commentsExtensible.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml" />`;
      if (!hasCommentsExtensible) typesString += commentsExtendedDef;
    }
    const partNames = new Set(additionalPartNames);
    if (docx?.files) {
      if (fromJson && Array.isArray(docx.files)) {
        docx.files.forEach((file) => partNames.add(file.name));
      } else {
        Object.keys(docx.files).forEach((key2) => partNames.add(key2));
      }
    }
    partNames.forEach((name) => {
      if (name.includes('.rels')) return;
      if (!name.includes('header') && !name.includes('footer')) return;
      const hasExtensible = types.elements?.some(
        (el) => el.name === 'Override' && el.attributes.PartName === `/${name}`,
      );
      const type = name.includes('header') ? 'header' : 'footer';
      const extendedDef = `<Override PartName="/${name}" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.${type}+xml"/>`;
      if (!hasExtensible) {
        typesString += extendedDef;
      }
    });
    const beginningString = '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
    let updatedContentTypesXml = contentTypesXml.replace(beginningString, `${beginningString}${typesString}`);
    let relationshipsXml = updatedDocs['word/_rels/document.xml.rels'];
    if (!relationshipsXml) {
      if (fromJson) {
        if (Array.isArray(docx.files)) {
          relationshipsXml = docx.files.find((file) => file.name === 'word/_rels/document.xml.rels')?.content;
        } else {
          relationshipsXml = docx.files?.['word/_rels/document.xml.rels'];
        }
      } else {
        relationshipsXml = await docx.file('word/_rels/document.xml.rels')?.async('string');
      }
    }
    if (relationshipsXml) {
      try {
        const relJson = xmljs.xml2js(relationshipsXml, { compact: false });
        const relationships = relJson.elements?.find((el) => el.name === 'Relationships');
        relationships?.elements?.forEach((rel) => {
          const type = rel.attributes?.Type;
          const target = rel.attributes?.Target;
          if (!type || !target) return;
          const isHeader = type.includes('/header');
          const isFooter = type.includes('/footer');
          if (!isHeader && !isFooter) return;
          let sanitizedTarget = target.replace(/^\.\//, '');
          if (sanitizedTarget.startsWith('../')) sanitizedTarget = sanitizedTarget.slice(3);
          if (sanitizedTarget.startsWith('/')) sanitizedTarget = sanitizedTarget.slice(1);
          const partName = sanitizedTarget.startsWith('word/') ? sanitizedTarget : `word/${sanitizedTarget}`;
          partNames.add(partName);
        });
      } catch (error) {
        console.warn('Failed to parse document relationships while updating content types', error);
      }
    }
    partNames.forEach((name) => {
      if (name.includes('.rels')) return;
      if (!name.includes('header') && !name.includes('footer')) return;
      if (updatedContentTypesXml.includes(`PartName="/${name}"`)) return;
      const type = name.includes('header') ? 'header' : 'footer';
      const extendedDef = `<Override PartName="/${name}" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.${type}+xml"/>`;
      updatedContentTypesXml = updatedContentTypesXml.replace('</Types>', `${extendedDef}</Types>`);
    });
    if (fromJson) return updatedContentTypesXml;
    docx.file(contentTypesPath, updatedContentTypesXml);
  }
  async unzip(file) {
    const zip = await this.zip.loadAsync(file);
    return zip;
  }
  async updateZip({ docx, updatedDocs, originalDocxFile, media, fonts, isHeadless: isHeadless2 }) {
    let zip;
    if (originalDocxFile) {
      zip = await this.exportFromOriginalFile(originalDocxFile, updatedDocs, media);
    } else {
      zip = await this.exportFromCollaborativeDocx(docx, updatedDocs, media, fonts);
    }
    const exportType = isHeadless2 ? 'nodebuffer' : 'blob';
    return await zip.generateAsync({ type: exportType });
  }
  /**
   * Export the Editor content to a docx file, updating changed docs
   * @param {Object} docx An object containing the unzipped docx files (keys are relative file names)
   * @param {Object} updatedDocs An object containing the updated docs (keys are relative file names)
   * @returns {Promise<JSZip>} The unzipped but updated docx file ready for zipping
   */
  async exportFromCollaborativeDocx(docx, updatedDocs, media, fonts) {
    const zip = new JSZip();
    for (const file of docx) {
      const content = file.content;
      zip.file(file.name, content);
    }
    Object.keys(updatedDocs).forEach((key2) => {
      const content = updatedDocs[key2];
      zip.file(key2, content);
    });
    Object.keys(media).forEach((path) => {
      const binaryData = Buffer.from(media[path], 'base64');
      zip.file(path, binaryData);
    });
    for (const [fontName, fontUintArray] of Object.entries(fonts)) {
      zip.file(fontName, fontUintArray);
    }
    await this.updateContentTypes(zip, media, false, updatedDocs);
    return zip;
  }
  /**
   * Export the Editor content to a docx file, updating changed docs
   * Requires the original docx file
   * @param {File} originalDocxFile The original docx file
   * @param {Object} updatedDocs An object containing the updated docs (keys are relative file names)
   * @returns {Promise<JSZip>} The unzipped but updated docx file ready for zipping
   */
  async exportFromOriginalFile(originalDocxFile, updatedDocs, media) {
    const unzippedOriginalDocx = await this.unzip(originalDocxFile);
    const filePromises = [];
    unzippedOriginalDocx.forEach((relativePath, zipEntry) => {
      const promise = zipEntry.async('string').then((content) => {
        unzippedOriginalDocx.file(zipEntry.name, content);
      });
      filePromises.push(promise);
    });
    await Promise.all(filePromises);
    Object.keys(updatedDocs).forEach((key2) => {
      unzippedOriginalDocx.file(key2, updatedDocs[key2]);
    });
    Object.keys(media).forEach((path) => {
      unzippedOriginalDocx.file(path, media[path]);
    });
    await this.updateContentTypes(unzippedOriginalDocx, media, false, updatedDocs);
    return unzippedOriginalDocx;
  }
}
const CollaborationPluginKey = new PluginKey('collaboration');
const Collaboration = Extension.create({
  name: 'collaboration',
  priority: 1e3,
  addOptions() {
    return {
      ydoc: null,
      field: 'supereditor',
      fragment: null,
      isReady: false,
    };
  },
  addPmPlugins() {
    if (!this.editor.options.ydoc) return [];
    this.options.ydoc = this.editor.options.ydoc;
    initSyncListener(this.options.ydoc, this.editor, this);
    initDocumentListener({ ydoc: this.options.ydoc, editor: this.editor });
    const [syncPlugin, fragment] = createSyncPlugin(this.options.ydoc, this.editor);
    this.options.fragment = fragment;
    const metaMap = this.options.ydoc.getMap('media');
    metaMap.observe((event) => {
      event.changes.keys.forEach((_, key2) => {
        if (!(key2 in this.editor.storage.image.media)) {
          const fileData = metaMap.get(key2);
          this.editor.storage.image.media[key2] = fileData;
        }
      });
    });
    return [syncPlugin];
  },
  addCommands() {
    return {
      addImageToCollaboration:
        ({ mediaPath, fileData }) =>
        () => {
          if (!this.options.ydoc || !mediaPath || !fileData) return false;
          const mediaMap = this.options.ydoc.getMap('media');
          mediaMap.set(mediaPath, fileData);
          return true;
        },
    };
  },
});
const createSyncPlugin = (ydoc, editor) => {
  const fragment = ydoc.getXmlFragment('supereditor');
  const onFirstRender = () => {
    if (!editor.options.isNewFile) return;
    initializeMetaMap(ydoc, editor);
  };
  return [ySyncPlugin(fragment, { onFirstRender }), fragment];
};
const initializeMetaMap = (ydoc, editor) => {
  const metaMap = ydoc.getMap('meta');
  metaMap.set('docx', editor.options.content);
  metaMap.set('fonts', editor.options.fonts);
  const mediaMap = ydoc.getMap('media');
  Object.entries(editor.options.mediaFiles).forEach(([key2, value]) => {
    mediaMap.set(key2, value);
  });
};
const checkDocxChanged = (transaction) => {
  if (!transaction.changed) return false;
  for (const [, value] of transaction.changed.entries()) {
    if (value instanceof Set && value.has('docx')) {
      return true;
    }
  }
  return false;
};
const initDocumentListener = ({ ydoc, editor }) => {
  const debouncedUpdate = debounce((editor2) => {
    updateYdocDocxData(editor2);
  }, 1e3);
  ydoc.on('afterTransaction', (transaction) => {
    const { local } = transaction;
    const hasChangedDocx = checkDocxChanged(transaction);
    if (!hasChangedDocx && transaction.changed?.size && local) {
      debouncedUpdate(editor);
    }
  });
};
const debounce = (fn, wait) => {
  let timeout = null;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn.apply(void 0, args), wait);
  };
};
const initSyncListener = (ydoc, editor, extension) => {
  const provider = editor.options.collaborationProvider;
  if (!provider) return;
  const emit = () => {
    extension.options.isReady = true;
    provider.off('synced', emit);
    editor.emit('collaborationReady', { editor, ydoc });
  };
  if (provider.synced) {
    setTimeout(() => {
      emit();
    }, 250);
    return;
  }
  provider.on('synced', emit);
};
const generateCollaborationData = async (editor) => {
  const ydoc = prosemirrorToYDoc(editor.state.doc, 'supereditor');
  initializeMetaMap(ydoc, editor);
  await updateYdocDocxData(editor, ydoc);
  return encodeStateAsUpdate(ydoc);
};
const isHighContrastMode = ref(false);
function useHighContrastMode() {
  const setHighContrastMode = (value) => {
    isHighContrastMode.value = value;
  };
  return {
    isHighContrastMode,
    setHighContrastMode,
  };
}
const findWordBounds = (doc, pos) => {
  const $pos = doc.resolve(pos);
  const parent = $pos.parent;
  const offsetInParent = $pos.parentOffset;
  let offset = 0;
  let targetNode = null;
  let nodeStart = 0;
  parent.forEach((child, childOffset) => {
    if (child.isText) {
      const start = offset;
      const end = offset + child.nodeSize;
      if (start <= offsetInParent && offsetInParent <= end) {
        targetNode = child;
        nodeStart = childOffset;
      }
      offset = end;
    } else {
      offset += child.nodeSize;
    }
  });
  if (!targetNode) return;
  const text = targetNode.text;
  const cursorOffset = offsetInParent - nodeStart;
  const isWordChar = (ch) => /\w/.test(ch);
  const isPunctOrSpace = (ch) => /[.,;:!-?=()[\]{}"'\s]/.test(ch);
  let from, to;
  if (isPunctOrSpace(text[cursorOffset])) {
    from = $pos.start() + nodeStart + cursorOffset;
    to = from + 1;
  } else {
    let start = cursorOffset;
    while (start > 0 && isWordChar(text[start - 1])) start--;
    let end = cursorOffset;
    while (end < text.length && isWordChar(text[end])) end++;
    if (start === end) return;
    from = $pos.start() + nodeStart + start;
    to = $pos.start() + nodeStart + end;
  }
  return { from, to };
};
const setWordSelection = (view, pos) => {
  const { state, dispatch } = view;
  const word = findWordBounds(state.doc, pos);
  if (!word) return;
  const tr = state.tr.setSelection(TextSelection.create(state.doc, word.from, word.to));
  dispatch(tr);
};
const setImageNodeSelection = (view, pos) => {
  const { doc } = view.state;
  const node = doc.nodeAt(pos);
  if (node && node.type.name === 'image') {
    const tr = view.state.tr.setSelection(NodeSelection.create(doc, pos));
    view.dispatch(tr);
    return true;
  }
  return false;
};
function canRenderFont(fontName, fallbackFont = 'sans-serif') {
  const _canRenderFont = (fontName2, fallbackFont2) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'top';
    const text = 'abcdefghijklmnopqrstuvwxyz0123456789';
    ctx.font = `72px ${fallbackFont2}`;
    const initialTextMeasurement = ctx.measureText(text);
    const fallbackWidth = initialTextMeasurement.width;
    const fallbackHeight = initialTextMeasurement.actualBoundingBoxDescent;
    ctx.font = `72px "${fontName2}", ${fallbackFont2}`;
    const customTextMeasurement = ctx.measureText(text);
    const customFontWidth = customTextMeasurement.width;
    const customFontHeight = customTextMeasurement.actualBoundingBoxDescent;
    const isAvailable = customFontWidth !== fallbackWidth || customFontHeight !== fallbackHeight;
    return isAvailable;
  };
  if (_canRenderFont(fontName, fallbackFont)) {
    return true;
  }
  const oppositeFallbackFont = fallbackFont === 'sans-serif' ? 'serif' : 'sans-serif';
  return _canRenderFont(fontName, oppositeFallbackFont);
}
const { findChildren: findChildren$2 } = helpers;
function getAllFieldAnnotations(state) {
  let fieldAnnotations = findChildren$2(state.doc, (node) => node.type.name === 'fieldAnnotation');
  return fieldAnnotations;
}
const { findChildren: findChildren$1 } = helpers;
function findFieldAnnotationsByFieldId(fieldIdOrArray, state) {
  let fieldAnnotations = findChildren$1(state.doc, (node) => {
    let isFieldAnnotation = node.type.name === 'fieldAnnotation';
    if (Array.isArray(fieldIdOrArray)) {
      return isFieldAnnotation && fieldIdOrArray.includes(node.attrs.fieldId);
    } else {
      return isFieldAnnotation && node.attrs.fieldId === fieldIdOrArray;
    }
  });
  return fieldAnnotations;
}
function findFieldAnnotationsBetween(from, to, doc) {
  let fieldAnnotations = [];
  doc.nodesBetween(from, to, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    if (node.type.name === 'fieldAnnotation') {
      fieldAnnotations.push({
        node,
        pos,
      });
    }
  });
  return fieldAnnotations;
}
function findRemovedFieldAnnotations(tr) {
  let removedNodes = [];
  if (
    !tr.steps.length ||
    (tr.meta && !Object.keys(tr.meta).every((meta) => ['inputType', 'uiEvent', 'paste'].includes(meta))) ||
    ['historyUndo', 'historyRedo'].includes(tr.getMeta('inputType')) ||
    ['drop'].includes(tr.getMeta('uiEvent')) ||
    tr.getMeta('fieldAnnotationUpdate') === true ||
    tr.getMeta('tableGeneration') === true
  ) {
    return removedNodes;
  }
  const hasDeletion = transactionDeletedAnything(tr);
  if (!hasDeletion) return removedNodes;
  tr.steps.forEach((step, stepIndex) => {
    if (step instanceof ReplaceStep && step.from !== step.to) {
      let mapping = tr.mapping.maps[stepIndex];
      let originalDoc = tr.before;
      originalDoc.nodesBetween(step.from, step.to, (node, pos) => {
        if (node.type.name === 'fieldAnnotation') {
          let mappedPos = mapping.mapResult(pos);
          if (mappedPos.deleted) {
            removedNodes.push({ node, pos });
          }
        }
      });
    }
  });
  return removedNodes;
}
function transactionDeletedAnything(tr) {
  return tr.steps.some((step) => {
    if (step instanceof ReplaceStep || step instanceof ReplaceAroundStep) {
      return step.from !== step.to;
    }
    return false;
  });
}
function trackFieldAnnotationsDeletion(editor, tr) {
  let removedAnnotations = [];
  try {
    removedAnnotations = findRemovedFieldAnnotations(tr);
  } catch {}
  if (removedAnnotations.length > 0) {
    setTimeout(() => {
      editor.emit('fieldAnnotationDeleted', {
        editor,
        removedNodes: removedAnnotations,
      });
    }, 0);
  }
}
const migrateListsToV2IfNecessary = (editor) => {
  const replacements = [];
  const numbering = editor.converter.numbering;
  if (!numbering) return replacements;
  const { state } = editor;
  const { doc } = state;
  const { dispatch } = editor.view;
  const LIST_TYPES = ['orderedList', 'bulletList'];
  let lastListEndPos = 0;
  doc.descendants((node, pos) => {
    if (!LIST_TYPES.includes(node.type.name)) return;
    if (pos < lastListEndPos) return;
    const extracted = flattenListCompletely(node, editor, 0);
    if (extracted.length > 0) {
      replacements.push({
        from: pos,
        to: pos + node.nodeSize,
        listNode: node,
        replacement: extracted,
      });
    }
    lastListEndPos = pos + node.nodeSize;
  });
  let tr = state.tr;
  if (replacements.length > 0) {
    for (let i = replacements.length - 1; i >= 0; i--) {
      const { from, to, replacement, listNode } = replacements[i];
      const nodesToInsert = [];
      for (const item of replacement) {
        if (item.node.type.name === 'listItem') {
          const singleItemList = listNode.type.create(listNode.attrs, [item.node]);
          nodesToInsert.push(singleItemList);
        } else {
          nodesToInsert.push(item.node);
        }
      }
      tr = tr.replaceWith(from, to, nodesToInsert);
    }
  }
  tr.setMeta('listsv2migration', replacements);
  editor.options.migrated = true;
  dispatch(tr);
  return replacements;
};
function flattenListCompletely(listNode, editor, baseLevel = 0, sharedNumId = null) {
  const result = [];
  const listTypes = ['orderedList', 'bulletList'];
  const currentListType = listNode.type.name;
  const needsMigration = shouldMigrateList(listNode);
  const hasValidDefinition = checkValidDefinition(listNode, editor);
  if (!needsMigration) {
    if (!hasValidDefinition) {
      return generateMissingListDefinition(listNode, editor);
    } else {
      return result;
    }
  }
  let numId = parseInt(listNode.attrs?.listId);
  if (!numId || Number.isNaN(numId)) numId = ListHelpers.getNewListId(editor);
  const listHasDef = ListHelpers.getListDefinitionDetails({ numId, level: baseLevel, editor });
  if (!listHasDef || (!sharedNumId && !numId)) {
    numId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId,
      listType: currentListType,
      editor,
    });
  }
  if (!sharedNumId) sharedNumId = numId;
  for (const listItem of listNode.content.content) {
    if (!listItem.content.content?.length) {
      result.push({ node: listItem, baseLevel });
    } else if (listItem.content.content.length === 1) {
      const contentNode = listItem.content.content[0];
      if (listTypes.includes(contentNode.type.name)) {
        const flattened = flattenListCompletely(contentNode, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        const newList = ListHelpers.createSchemaOrderedListNode({
          level: baseLevel,
          numId: sharedNumId,
          listType: listNode.type.name,
          editor,
          contentNode: contentNode.toJSON(),
          listLevel: listItem.attrs.listLevel || [1],
        });
        result.push({ node: newList, baseLevel });
      }
    } else {
      const firstItem = listItem.content.content[0];
      if (listTypes.includes(firstItem.type.name)) {
        const flattened = flattenListCompletely(firstItem, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        if (firstItem.type.name === 'paragraph' || firstItem.isTextblock) {
          const newList = ListHelpers.createSchemaOrderedListNode({
            level: baseLevel,
            numId: sharedNumId,
            listType: listNode.type.name,
            editor,
            contentNode: firstItem.toJSON(),
            listLevel: listItem.attrs.listLevel || [1],
          });
          result.push({ node: newList, baseLevel });
        } else {
          result.push({ node: firstItem });
        }
      }
      for (let contentItem of listItem.content.content.slice(1)) {
        if (listTypes.includes(contentItem.type.name)) {
          const flattened = flattenListCompletely(contentItem, editor, baseLevel + 1, sharedNumId);
          result.push(...flattened);
        } else {
          result.push({ node: contentItem });
        }
      }
    }
  }
  return result;
}
const shouldMigrateList = (listItem) => {
  const content = listItem.content;
  if (content?.content?.length > 1) {
    return true;
  }
  const firstChild = content.firstChild;
  if (firstChild && firstChild.type.name === 'listItem') {
    const { attrs } = firstChild;
    const { level, listNumberingType } = attrs || {};
    if (typeof level === 'undefined' || !listNumberingType) {
      return true;
    }
    const childContent = firstChild?.content?.content;
    const nestedLists = childContent.filter((child) => ['bulletList', 'orderedList'].includes(child.type.name));
    return nestedLists.length > 0;
  }
  return false;
};
const checkValidDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId, level } = attrs || {};
  const listDef = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const { abstract } = listDef || {};
  if (abstract) return true;
  return false;
};
const generateMissingListDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId } = attrs || {};
  return ListHelpers.generateNewListDefinition({
    numId,
    listType,
    editor,
  });
};
const migrateParagraphFieldsListsV2 = async (annotationValues = [], editor) => {
  const annotations = getAllFieldAnnotations(editor.state);
  const newValues = [];
  if (!annotations.length) {
    return annotationValues;
  }
  for (const annotation of annotations) {
    const type = annotation.node?.attrs?.type;
    const matchedAnnotation = annotationValues.find((v) => v.input_id === annotation.node.attrs.fieldId);
    if (!!matchedAnnotation && (!type || type !== 'html')) {
      newValues.push(matchedAnnotation);
      continue;
    }
    const value = matchedAnnotation?.input_value;
    if (!value) continue;
    await new Promise((resolve, reject) => {
      const element = document.createElement('div');
      editor.createChildEditor({
        element,
        html: value,
        onCreate: ({ editor: localEditor }) => {
          const { migrated } = localEditor.options;
          if (migrated) {
            const newHTML = localEditor.getHTML();
            matchedAnnotation.input_value = newHTML;
            newValues.push(matchedAnnotation);
          }
          resolve();
        },
        onError: (error) => {
          reject(error);
        },
      });
    });
  }
  return newValues;
};
const createLinkedChildEditor = (currentEditor, options = {}) => {
  if (currentEditor.options.isChildEditor) {
    return null;
  }
  const editor = new Editor({
    ...currentEditor.options,
    pagination: false,
    suppressDefaultDocxStyles: true,
    ydoc: null,
    collaborationProvider: null,
    fileSource: null,
    initialState: null,
    documentId: null,
    isCommentsEnabled: false,
    isNewFile: false,
    fragment: false,
    onCreate: () => null,
    onListDefinitionsChange: linkListDefinitionsChange,
    // Options overrides
    ...options,
    isChildEditor: true,
    parentEditor: currentEditor,
  });
  return editor;
};
const linkListDefinitionsChange = (options) => {
  const { editor, numbering } = options;
  const { parentEditor = {} } = editor.options;
  const { converter: parentConverter } = parentEditor;
  if (!parentConverter) return;
  parentConverter.numbering = numbering;
  const { tr } = parentEditor.state;
  const { dispatch } = parentEditor.view;
  tr.setMeta('updatedListItemNodeViews', true);
  dispatch(tr);
};
function createLogger(debug, additionalPrefixes = []) {
  const basePrefix = '[SuperValidator]';
  const style = 'color: teal; font-weight: bold;';
  const allPrefixes = [basePrefix, ...additionalPrefixes.map((p) => `[${p}]`)];
  const format = allPrefixes.map(() => '%c%s').join(' ');
  const styledPrefixes = allPrefixes.map((p) => [style, p]).flat();
  return {
    debug: (...args) => {
      if (!debug) return;
      console.debug(format, ...styledPrefixes, ...args);
    },
    withPrefix: (prefix) => createLogger(debug, [...additionalPrefixes, prefix]),
  };
}
function ensureValidImageRID(images, editor, tr, logger) {
  let modified = false;
  const results = [];
  images.forEach(({ node, pos }) => {
    const { rId, src } = node.attrs;
    if (!rId && src) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(src, editor);
      if (newId) logger.debug('Reusing existing rId for image:', newId, 'at pos:', pos);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(src, 'image', editor);
        logger.debug('Creating new rId for image at pos:', pos, 'with src:', src);
      }
      tr.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        rId: newId,
      });
      results.push(`Added missing rId to image at pos ${pos}`);
      modified = true;
    }
  });
  return { modified, results };
}
function createImageNodeValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const images = analysis.image || [];
    const ruleResults = [ensureValidImageRID(images, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    nodes: ['image'],
  };
  return validator;
}
function ensureValidLinkRID(links, editor, tr, logger) {
  let modified = false;
  const results = [];
  links.forEach(({ mark, from, to }) => {
    const { rId, href, anchor } = mark.attrs;
    if (!rId && href && !anchor) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(href, editor);
      if (newId) logger.debug('Reusing existing rId for link:', newId, 'from pos:', from, 'to pos:', to);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(href, 'hyperlink', editor);
        logger.debug('Creating new rId for link from pos:', from, 'to pos:', to, 'with href:', href);
      }
      if (newId) {
        const linkMarkType = editor.schema.marks.link;
        const newMark = linkMarkType.create({
          ...mark.attrs,
          rId: newId,
        });
        tr.removeMark(from, to, linkMarkType);
        tr.addMark(from, to, newMark);
        results.push(`Added missing rId to link from pos ${from} to ${to}`);
        modified = true;
      }
    }
  });
  return { modified, results };
}
function createLinkMarkValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const links = analysis.link || [];
    const ruleResults = [ensureValidLinkRID(links, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    marks: ['link'],
  };
  return validator;
}
const StateValidators = {
  imageNodeValidator: createImageNodeValidator,
  linkMarkValidator: createLinkMarkValidator,
};
function createNumberingValidator({ editor, logger }) {
  return () => {
    const results = [];
    let modified = false;
    const convertedXml = editor?.converter?.convertedXml;
    const path = 'word/numbering.xml';
    const numbering = convertedXml?.[path];
    if (!numbering || !numbering.elements?.length || !numbering.elements[0].elements?.length) {
      results.push(`${path} is not a valid xml`);
      return { results, modified };
    }
    const removed = [];
    let elements = numbering.elements[0];
    pruneInvalidNumNodes(elements, removed);
    if (removed.length) {
      modified = true;
      results.push(`Removed invalid <w:num> by numId:` + removed.join(', '));
      logger?.debug?.(`Removed invalid <w:num> by numId: ${removed.join(', ')}`);
    } else {
      results.push('No <w:num> entries with null/invalid numId found.');
    }
    return { results, modified };
  };
}
function pruneInvalidNumNodes(node, removed) {
  if (!node || !Array.isArray(node.elements)) return;
  const next = [];
  for (const el of node.elements) {
    if (el?.type === 'element') {
      if (el.name === 'w:num') {
        const attrs = el.attributes || {};
        const raw = attrs['w:numId'];
        const v = raw == null ? null : String(raw).trim();
        const isInvalid = v == null || v === '' || /^null$/i.test(v) || !/^\d+$/.test(v);
        if (isInvalid) {
          removed.push(v ?? 'missing node');
          continue;
        }
      }
      if (Array.isArray(el.elements) && el.elements.length) {
        pruneInvalidNumNodes(el, removed);
      }
    }
    next.push(el);
  }
  node.elements = next;
}
function createRelationshipsValidator({ editor, logger }) {
  return () => {
    const results = [];
    let modified = false;
    const convertedXml = editor?.converter?.convertedXml;
    if (!convertedXml || typeof convertedXml !== 'object') {
      return { results, modified };
    }
    const { relsKey, wasNormalized } = findAndNormalizeRelationshipsFile(convertedXml, results);
    if (!relsKey) {
      return { results, modified };
    }
    if (wasNormalized) modified = true;
    const { root, wasFixed } = validateRelationshipsRoot(convertedXml[relsKey], relsKey, results);
    if (!root) {
      return { results, modified };
    }
    if (wasFixed) modified = true;
    const wasCleaned = cleanupRootChildren(root);
    if (wasCleaned) modified = true;
    const { filteredIds, binMediaTargets, wasProcessed } = processRelationships(root, convertedXml, results);
    if (wasProcessed) modified = true;
    const wasDocumentFixed = fixMissingDocumentRefs(convertedXml, filteredIds, results, logger);
    if (wasDocumentFixed) modified = true;
    const contentTypesKey = '[Content_Types].xml';
    const contentTypesXml = convertedXml[contentTypesKey];
    if (binMediaTargets.size > 0 || contentTypesXml) {
      const wasContentTypesUpdated = updateContentTypes(convertedXml, binMediaTargets, results);
      if (wasContentTypesUpdated) modified = true;
    } else {
      results.push('[Content_Types].xml not found or not parseable. Skipped content types patch.');
    }
    return { results, modified };
  };
}
function findAndNormalizeRelationshipsFile(convertedXml, results) {
  const candidateKeys = [
    'word/_rels/document.xml.rels',
    'word/document.xml.rels',
    '_rels/document.xml.rels',
    'document.xml.rels',
  ];
  const relsKey = candidateKeys.find((k2) => convertedXml?.[k2]?.elements);
  if (!relsKey) return { relsKey: null, wasNormalized: false };
  const canonicalKey = 'word/_rels/document.xml.rels';
  if (relsKey !== canonicalKey) {
    convertedXml[canonicalKey] = convertedXml[relsKey];
    delete convertedXml[relsKey];
    results.push(`Normalized relationships location to ${canonicalKey} (was ${relsKey})`);
    return { relsKey: canonicalKey, wasNormalized: true };
  }
  return { relsKey, wasNormalized: false };
}
function validateRelationshipsRoot(relsTree, relsKey, results) {
  const root = relsTree?.elements?.[0];
  if (!root || root.type !== 'element') {
    results.push(`${relsKey} is not a valid xml`);
    return { root: null, wasFixed: false };
  }
  const RELS_NS = 'http://schemas.openxmlformats.org/package/2006/relationships';
  let wasFixed = false;
  if (root.name !== 'Relationships') {
    root.name = 'Relationships';
    results.push(`Fixed relationships root element name to "Relationships"`);
    wasFixed = true;
  }
  root.attributes = root.attributes || {};
  if (root.attributes.xmlns !== RELS_NS) {
    root.attributes.xmlns = RELS_NS;
    results.push(`Set relationships xmlns to ${RELS_NS}`);
    wasFixed = true;
  }
  return { root, wasFixed };
}
function cleanupRootChildren(root) {
  const validChildren =
    root.elements?.filter((child) => child?.type === 'element' && child.name === 'Relationship') || [];
  if (root.elements?.length !== validChildren.length) {
    root.elements = validChildren;
    return true;
  }
  return false;
}
function processRelationships(root, convertedXml, results) {
  const binMediaTargets = /* @__PURE__ */ new Set();
  const filteredIds = /* @__PURE__ */ new Set();
  let wasProcessed = false;
  const ridNum = (id) => {
    const m = /^rId(\d+)$/.exec(String(id || ''));
    return m ? parseInt(m[1], 10) : null;
  };
  const isType = (type, tail) => typeof type === 'string' && new RegExp(`/relationships/${tail}$`, 'i').test(type);
  const isHyperlinkType = (type) => isType(type, 'hyperlink');
  const isImageType = (type) => isType(type, 'image');
  const looksExternal = (target) => /^https?:\/\//i.test(target || '') || /^mailto:/i.test(target || '');
  const usedIds = /* @__PURE__ */ new Set();
  let maxRid = 0;
  for (const el of root.elements) {
    el.attributes = el.attributes || {};
    const id = el.attributes.Id;
    const n = ridNum(id);
    if (Number.isInteger(n)) maxRid = Math.max(maxRid, n);
    if (typeof id === 'string' && id) {
      usedIds.add(id);
    }
  }
  let ridCounter = maxRid;
  const allocateId = (preferred) => {
    let newId;
    do {
      ridCounter += 1;
      newId = `rId${ridCounter}`;
    } while (usedIds.has(newId));
    usedIds.add(newId);
    return newId;
  };
  const seenIds = /* @__PURE__ */ new Set();
  const filtered = [];
  function extractStringAttr(attrs, key2) {
    return typeof attrs[key2] === 'string' ? attrs[key2].trim() : '';
  }
  for (const rel of root.elements) {
    rel.attributes = rel.attributes || {};
    const attrs = rel.attributes;
    let id = extractStringAttr(attrs, 'Id');
    const type = extractStringAttr(attrs, 'Type');
    let target = extractStringAttr(attrs, 'Target');
    let targetMode = extractStringAttr(attrs, 'TargetMode');
    if (!target) {
      results.push(`Removed relationship "${id}" without Target`);
      wasProcessed = true;
      continue;
    }
    if (isHyperlinkType(type) && looksExternal(target) && targetMode.toLowerCase() !== 'external') {
      attrs.TargetMode = 'External';
      targetMode = 'External';
      results.push(`Set TargetMode="External" for hyperlink ${id}`);
      wasProcessed = true;
    }
    if (isImageType(type)) {
      const relPath = `word/${target.replace(/^\.?\//, '')}`;
      if (/^media\/.+\.bin$/i.test(target) && relPath in convertedXml) {
        binMediaTargets.add(`/${relPath}`);
      }
    }
    if (targetMode.toLowerCase() !== 'external' && !looksExternal(target)) {
      const likelyPath = `word/${target.replace(/^\.?\//, '')}`;
      if (!(likelyPath in convertedXml)) {
        if (!isImageType(type)) {
          results.push(`Removed relationship ${id} with missing target: ${target}`);
          wasProcessed = true;
          continue;
        } else {
          results.push(`Warning: image relationship ${id} target not found: ${target}.`);
        }
      }
    }
    if (!id) {
      const newId = allocateId();
      attrs.Id = newId;
      results.push(`Assigned missing Id "${newId}"`);
      wasProcessed = true;
      id = newId;
    }
    if (seenIds.has(id)) {
      results.push(`Removed duplicate relationship with ID "${id}"`);
      wasProcessed = true;
      continue;
    }
    seenIds.add(id);
    filtered.push(rel);
  }
  if (root.elements.length !== filtered.length) {
    root.elements = filtered;
    wasProcessed = true;
  } else {
    const contentChanged = root.elements.some((el, i) => el !== filtered[i]);
    if (contentChanged) {
      root.elements = filtered;
      wasProcessed = true;
    }
  }
  for (const rel of root.elements) {
    const id = rel.attributes?.Id;
    if (typeof id === 'string' && id) {
      filteredIds.add(id);
    }
  }
  return { filteredIds, binMediaTargets, wasProcessed };
}
function fixMissingDocumentRefs(convertedXml, filteredIds, results, logger) {
  const documentPath = 'word/document.xml';
  const document2 = convertedXml[documentPath];
  if (document2?.elements?.length) {
    const documentRoot = document2.elements[0];
    if (documentRoot?.type === 'element') {
      const missingRefs = [];
      processDocumentForMissingRefs(documentRoot, filteredIds, missingRefs);
      if (missingRefs.length) {
        results.push(`Fixed ${missingRefs.length} missing relationship references`);
        logger?.debug?.(`Fixed ${missingRefs.length} missing relationship references in document`);
        return true;
      }
    }
  }
  return false;
}
function updateContentTypes(convertedXml, binMediaTargets, results) {
  const contentTypesKey = '[Content_Types].xml';
  const contentTypesXml = convertedXml[contentTypesKey];
  if (typeof contentTypesXml === 'string') {
    return updateContentTypesString(contentTypesXml, binMediaTargets, results, convertedXml, contentTypesKey);
  } else if (contentTypesXml?.elements?.length) {
    return updateContentTypesElements(contentTypesXml, binMediaTargets, results);
  } else {
    return false;
  }
}
function updateContentTypesString(contentTypesXml, binMediaTargets, results, convertedXml, contentTypesKey) {
  const CONTENT_TYPES_NS = '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
  const ensureDefault = (xmlString, ext, contentType) => {
    const defRe = new RegExp(`<Default\\s+Extension="${ext}"\\b`, 'i');
    if (defRe.test(xmlString)) return xmlString;
    return xmlString.replace(
      CONTENT_TYPES_NS,
      `${CONTENT_TYPES_NS}<Default Extension="${ext}" ContentType="${contentType}"/>`,
    );
  };
  const ensureOverride = (xmlString, partName, contentType) => {
    const esc = partName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const ovRe = new RegExp(`<Override\\s+PartName="${esc}"\\b`, 'i');
    if (ovRe.test(xmlString)) return xmlString;
    return xmlString.replace(
      CONTENT_TYPES_NS,
      `${CONTENT_TYPES_NS}<Override PartName="${partName}" ContentType="${contentType}" />`,
    );
  };
  let updated = contentTypesXml;
  updated = ensureDefault(updated, 'rels', 'application/vnd.openxmlformats-package.relationships+xml');
  updated = ensureDefault(updated, 'xml', 'application/xml');
  for (const partName of binMediaTargets) {
    updated = ensureOverride(updated, partName, 'image/png');
    results.push(`Added Content Types Override for "${partName}" as image/png`);
  }
  if (updated !== contentTypesXml) {
    convertedXml[contentTypesKey] = updated;
    return true;
  }
  return false;
}
function updateContentTypesElements(contentTypesXml, binMediaTargets, results) {
  const typesRoot = contentTypesXml.elements.find((el) => el.name === 'Types') || contentTypesXml.elements[0];
  typesRoot.elements = typesRoot.elements || [];
  const hasDefault = (ext) =>
    typesRoot.elements.some((el) => el.name === 'Default' && el.attributes?.Extension === ext);
  const addDefault = (ext, ct) => {
    typesRoot.elements.unshift({
      type: 'element',
      name: 'Default',
      attributes: { Extension: ext, ContentType: ct },
    });
  };
  const hasOverride = (part) =>
    typesRoot.elements.some((el) => el.name === 'Override' && el.attributes?.PartName === part);
  const addOverride = (part, ct) => {
    typesRoot.elements.unshift({
      type: 'element',
      name: 'Override',
      attributes: { PartName: part, ContentType: ct },
    });
  };
  let wasUpdated = false;
  if (!hasDefault('rels')) {
    addDefault('rels', 'application/vnd.openxmlformats-package.relationships+xml');
    wasUpdated = true;
  }
  if (!hasDefault('xml')) {
    addDefault('xml', 'application/xml');
    wasUpdated = true;
  }
  for (const partName of binMediaTargets) {
    if (!hasOverride(partName)) {
      addOverride(partName, 'image/png');
      results.push(`Added Content Types Override for "${partName}" as image/png`);
      wasUpdated = true;
    }
  }
  return wasUpdated;
}
function processDocumentForMissingRefs(node, usedIds, fixed) {
  if (!node?.elements?.length) return;
  for (const element of node.elements) {
    if (element?.type !== 'element') continue;
    const rIdValue = element.attributes?.['r:id'];
    if (typeof rIdValue === 'string' && !usedIds.has(rIdValue)) {
      delete element.attributes['r:id'];
      fixed.push(`Removed invalid r:id="${rIdValue}"`);
    }
    processDocumentForMissingRefs(element, usedIds, fixed);
  }
}
const XmlValidators = {
  numberingValidator: createNumberingValidator,
  relationshipsValidator: createRelationshipsValidator,
};
class SuperValidator {
  /**
   * Create a SuperValidator instance.
   * @param {SuperValidatorOptions} options - Options for the validator.
   */
  constructor(options) {
    __privateAdd(this, _SuperValidator_instances);
    /** @type {Editor} */
    __privateAdd(this, _editor);
    /** @type {any} */
    __privateAdd(this, _stateValidators);
    /** @type {any} */
    __privateAdd(this, _xmlValidators);
    /** @type {Set<string>} */
    __privateAdd(this, _requiredNodeTypes);
    /** @type {Set<string>} */
    __privateAdd(this, _requiredMarkTypes);
    __privateSet(this, _editor, options.editor);
    this.dryRun = options.dryRun || false;
    this.debug = options.debug || false;
    this.logger = createLogger(this.debug);
    const { stateValidators, xmlValidators, nodeTypes, markTypes } = __privateMethod(
      this,
      _SuperValidator_instances,
      initializeValidators_fn,
    ).call(this);
    __privateSet(this, _stateValidators, stateValidators);
    __privateSet(this, _xmlValidators, xmlValidators);
    __privateSet(this, _requiredNodeTypes, nodeTypes);
    __privateSet(this, _requiredMarkTypes, markTypes);
  }
  /**
   * Validate the active document in the editor. Triggered automatically on editor initialization.
   * @returns {{ modified: boolean, results: Array<{ key: string, results: string[] }> }}
   */
  validateActiveDocument() {
    const { tr } = __privateGet(this, _editor).state;
    const { dispatch } = __privateGet(this, _editor).view;
    const documentAnalysis = __privateMethod(this, _SuperValidator_instances, analyzeDocument_fn).call(this);
    this.logger.debug('Document analysis:', documentAnalysis);
    let hasModifiedDocument = false;
    const validationResults = [];
    Object.entries(__privateGet(this, _stateValidators)).forEach(([key2, validator]) => {
      this.logger.debug(` Validating with ${key2}...`);
      const { results, modified } = validator(tr, documentAnalysis);
      validationResults.push({ key: key2, results });
      hasModifiedDocument = hasModifiedDocument || modified;
    });
    if (!this.dryRun) dispatch(tr);
    else this.logger.debug('DRY RUN: No changes applied to the document.');
    this.logger.debug('Results:', validationResults);
    return { modified: hasModifiedDocument, results: validationResults };
  }
  /**
   * Validate the exported document in the editor. Triggered automatically on editor export.
   * @returns {{ modified: boolean, results: Array<{ key: string, results: string[] }> }}
   */
  validateDocumentExport() {
    const { tr } = __privateGet(this, _editor).state;
    const { dispatch } = __privateGet(this, _editor).view;
    let hasModifiedDocument = false;
    const validationResults = [];
    Object.entries(__privateGet(this, _xmlValidators)).forEach(([key2, validator]) => {
      this.logger.debug(` Validating export with ${key2}...`);
      const { results, modified } = validator();
      validationResults.push({ key: key2, results });
      hasModifiedDocument = hasModifiedDocument || modified;
    });
    if (!this.dryRun && hasModifiedDocument) dispatch(tr);
    else this.logger.debug('DRY RUN: No export changes applied to the document.');
    this.logger.debug('Export validation results:', validationResults);
    return { modified: hasModifiedDocument, results: validationResults };
  }
}
_editor = new WeakMap();
_stateValidators = new WeakMap();
_xmlValidators = new WeakMap();
_requiredNodeTypes = new WeakMap();
_requiredMarkTypes = new WeakMap();
_SuperValidator_instances = new WeakSet();
/**
 * Initialize all validators and collect their element requirements
 * @returns {{ stateValidators: Record<string, ValidatorFunction>, xmlValidators: Record<string, ValidatorFunction>, nodeTypes: Set<string>, markTypes: Set<string> }}
 */
initializeValidators_fn = function () {
  const requiredNodes = /* @__PURE__ */ new Set();
  const requiredMarks = /* @__PURE__ */ new Set();
  const initializeValidatorSet = (validatorFactories) => {
    return Object.fromEntries(
      Object.entries(validatorFactories).map(([key2, factory]) => {
        const validatorLogger = this.logger.withPrefix(key2);
        const validator = factory({ editor: __privateGet(this, _editor), logger: validatorLogger });
        __privateMethod(this, _SuperValidator_instances, collectValidatorRequirements_fn).call(
          this,
          validator,
          requiredNodes,
          requiredMarks,
        );
        return [key2, validator];
      }),
    );
  };
  const stateValidators = initializeValidatorSet(StateValidators);
  const xmlValidators = initializeValidatorSet(XmlValidators);
  return {
    stateValidators,
    xmlValidators,
    nodeTypes: requiredNodes,
    markTypes: requiredMarks,
  };
};
/**
 * Extract and collect requirements from a validator
 * @param {ValidatorFunction} validator
 * @param {Set<string>} requiredNodes
 * @param {Set<string>} requiredMarks
 */
collectValidatorRequirements_fn = function (validator, requiredNodes, requiredMarks) {
  if (!validator.requiredElements) return;
  if (typeof validator.requiredElements === 'object') {
    if (validator.requiredElements.nodes) {
      validator.requiredElements.nodes.forEach((nodeType) => {
        requiredNodes.add(nodeType);
      });
    }
    if (validator.requiredElements.marks) {
      validator.requiredElements.marks.forEach((markType) => {
        requiredMarks.add(markType);
      });
    }
  }
};
/**
 * Analyze the document to collect all required elements
 * @returns {DocumentAnalysis}
 */
analyzeDocument_fn = function () {
  const { doc } = __privateGet(this, _editor).state;
  const analysis = {};
  __privateGet(this, _requiredNodeTypes).forEach((type) => (analysis[type] = []));
  __privateGet(this, _requiredMarkTypes).forEach((type) => (analysis[type] = []));
  const collectElements = (node, pos) => {
    if (__privateGet(this, _requiredNodeTypes).has(node.type.name)) {
      analysis[node.type.name].push({ node, pos });
    }
    if (node.isText && node.marks) {
      node.marks.forEach(
        /** @param {Mark} mark */
        (mark) => {
          if (__privateGet(this, _requiredMarkTypes).has(mark.type.name)) {
            analysis[mark.type.name].push({
              mark,
              node,
              pos,
              from: pos,
              to: pos + node.nodeSize,
            });
          }
        },
      );
    }
  };
  doc.descendants(collectElements);
  return analysis;
};
const transformListsInCopiedContent = (html) => {
  const container = document.createElement('div');
  container.innerHTML = html;
  const result = [];
  const stack = [];
  const flushStackUntil = (level) => {
    while (stack.length && stack[stack.length - 1].level >= level) {
      const top = stack.pop();
      if (stack.length) {
        stack[stack.length - 1].el.appendChild(top.el);
      } else {
        result.push(top.el.outerHTML);
      }
    }
  };
  Array.from(container.childNodes).forEach((node) => {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      result.push(node.outerHTML || node.textContent);
      return;
    }
    if (node.tagName.toLowerCase() === 'ol' || node.tagName.toLowerCase() === 'ul') {
      const child = getFirstElementChild(node);
      const level = getLevel(child);
      const numFmt = child.getAttribute('data-num-fmt');
      const lvlText = child.getAttribute('data-lvl-text');
      const tag = node.tagName.toLowerCase();
      const li = child.cloneNode(true);
      li.setAttribute('aria-level', level + 1);
      li.style['list-style-type'] = getListStyleType(numFmt, lvlText);
      if (!stack.length || stack[stack.length - 1].level < level) {
        const newList = document.createElement(tag);
        stack.push({ tag, level, el: newList });
      } else if (stack[stack.length - 1].level > level) {
        flushStackUntil(level + 1);
      } else if (stack[stack.length - 1].tag !== tag) {
        flushStackUntil(level);
        const newList = document.createElement(tag);
        stack.push({ tag, level, el: newList });
      }
      stack[stack.length - 1].el.appendChild(li);
    } else {
      flushStackUntil(0);
      result.push(node.outerHTML);
    }
  });
  flushStackUntil(0);
  return result.join('');
};
const getListStyleType = (numFmt, lvlText) => {
  const bulletFmtMap = /* @__PURE__ */ new Map([
    ['', 'disc'],
    ['', 'circle'],
    ['', 'square'],
  ]);
  if (numFmt === 'bullet') return bulletFmtMap.get(lvlText) || 'disc';
  const fmtMap = /* @__PURE__ */ new Map([
    ['decimal', 'decimal'],
    ['lowerLetter', 'lower-alpha'],
    ['upperLetter', 'upper-alpha'],
    ['lowerRoman', 'lower-roman'],
    ['upperRoman', 'upper-roman'],
  ]);
  return lvlText.startsWith('0') ? 'decimal-leading-zero' : fmtMap.get(numFmt);
};
function getFirstElementChild(node) {
  return Array.from(node.childNodes).find((n) => n.nodeType === Node.ELEMENT_NODE) || null;
}
const getLevel = (node) => {
  const lvl = node.getAttribute('data-level');
  return lvl ? parseInt(lvl, 10) : 0;
};
const _Editor = class _Editor extends EventEmitter {
  /**
   * Create a new Editor instance
   * @param {EditorOptions} options - Editor configuration options
   */
  constructor(options) {
    super();
    __privateAdd(this, _Editor_instances);
    /**
     * Command service for handling editor commands
     * @type {CommandService}
     */
    __privateAdd(this, _commandService);
    /**
     * Service for managing extensions
     * @type {Object}
     */
    __publicField(this, 'extensionService');
    /**
     * Storage for extension data
     * @type {Object}
     */
    __publicField(this, 'extensionStorage', {});
    /**
     * ProseMirror schema for the editor
     * @type {Object}
     */
    __publicField(this, 'schema');
    /**
     * ProseMirror view instance
     * @type {Object}
     */
    __publicField(this, 'view');
    /**
     * Whether the editor currently has focus
     * @type {boolean}
     */
    __publicField(this, 'isFocused', false);
    /**
     * All the embedded fonts that were imported by the Editor
     * @type {string[]}
     */
    __publicField(this, 'fontsImported', []);
    __publicField(this, 'options', {
      element: null,
      selector: null,
      isHeadless: false,
      mockDocument: null,
      mockWindow: null,
      content: '',
      // XML content
      user: null,
      users: [],
      media: {},
      mediaFiles: {},
      fonts: {},
      documentMode: 'editing',
      mode: 'docx',
      role: 'editor',
      colors: [],
      converter: null,
      fileSource: null,
      initialState: null,
      documentId: null,
      extensions: [],
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      isCommentsEnabled: false,
      isNewFile: false,
      scale: 1,
      annotations: false,
      isInternal: false,
      externalExtensions: [],
      numbering: {},
      isHeaderOrFooter: false,
      lastSelection: null,
      suppressDefaultDocxStyles: false,
      jsonOverride: null,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onTrackedChangesUpdate: () => null,
      onCommentsUpdate: () => null,
      onCommentsLoaded: () => null,
      onCommentClicked: () => null,
      onCommentLocationsUpdate: () => null,
      onDocumentLocked: () => null,
      onFirstRender: () => null,
      onCollaborationReady: () => null,
      onPaginationUpdate: () => null,
      onException: () => null,
      onListDefinitionsChange: () => null,
      onFontsResolved: null,
      // async (file) => url;
      handleImageUpload: null,
      // telemetry
      telemetry: null,
      // Docx xml updated by User
      customUpdatedFiles: {},
      isHeaderFooterChanged: false,
      isCustomXmlChanged: false,
      focusTarget: null,
      permissionResolver: null,
      // header/footer editors may have parent(main) editor set
      parentEditor: null,
    });
    __privateMethod(this, _Editor_instances, initContainerElement_fn).call(this, options);
    __privateMethod(this, _Editor_instances, checkHeadless_fn).call(this, options);
    this.setOptions(options);
    let modes = {
      docx: () => __privateMethod(this, _Editor_instances, init_fn).call(this),
      text: () => __privateMethod(this, _Editor_instances, initRichText_fn).call(this),
      html: () => __privateMethod(this, _Editor_instances, initRichText_fn).call(this),
      default: () => {
        console.log('Not implemented.');
      },
    };
    let initMode = modes[this.options.mode] ?? modes.default;
    const { setHighContrastMode } = useHighContrastMode();
    this.setHighContrastMode = setHighContrastMode;
    initMode();
  }
  /**
   * Getter which indicates if any changes happen in Editor
   * @returns {boolean}
   */
  get docChanged() {
    return (
      this.options.isHeaderFooterChanged ||
      this.options.isCustomXmlChanged ||
      !this.options.initialState.doc.eq(this.state.doc)
    );
  }
  mount(el) {
    __privateMethod(this, _Editor_instances, createView_fn).call(this, el);
    window.setTimeout(() => {
      if (this.isDestroyed) return;
      this.emit('create', { editor: this });
    }, 0);
  }
  unmount() {
    if (this.view) {
      this.view.destroy();
    }
    this.view = null;
  }
  /**
   * Set the toolbar for this editor
   * @param {Object} toolbar - The toolbar instance
   * @returns {void}
   */
  setToolbar(toolbar) {
    this.toolbar = toolbar;
  }
  /**
   * Focus the editor.
   * @returns {void}
   */
  focus() {
    this.view?.focus();
  }
  /**
   * Get the editor state
   * @returns {Object} ProseMirror state
   */
  get state() {
    return this.view?.state;
  }
  /**
   * Get the editor storage.
   * @returns {Object} Editor storage object
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * Get object of registered commands.
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object
   */
  get commands() {
    return __privateGet(this, _commandService)?.commands;
  }
  /**
   * Get extension helpers.
   * @returns {EditorHelpers} Object with helper methods for extensions
   */
  get helpers() {
    return this.extensionService.helpers;
  }
  /**
   * Check if the editor is editable.
   * @returns {boolean}
   */
  get isEditable() {
    return Boolean(this.options.editable && this.view && this.view.editable);
  }
  /**
   * Check if editor is destroyed.
   * @returns {boolean}
   */
  get isDestroyed() {
    return this.view?.isDestroyed ?? true;
  }
  /**
   * Get the editor element
   * @returns {HTMLElement} The editor element
   */
  get element() {
    return this.options.element;
  }
  /**
   * Get possible users of the editor.
   * @returns {Array.<User>} List of users
   */
  get users() {
    return this.options.users;
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {Object} Command chain
   */
  chain() {
    return __privateGet(this, _commandService).chain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {Object} Object with methods to check command availability
   */
  can() {
    return __privateGet(this, _commandService).can();
  }
  /**
   * Set the document mode
   * @param {string} documentMode - The document mode ('editing', 'viewing', 'suggesting')
   * @param {string} caller - Calling context
   */
  setDocumentMode(documentMode, caller) {
    if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
    let cleanedMode = documentMode?.toLowerCase() || 'editing';
    if (!this.extensionService || !this.state) return;
    const pm = this.view?.dom || this.options.element?.querySelector?.('.ProseMirror');
    if (this.options.role === 'viewer') cleanedMode = 'viewing';
    if (this.options.role === 'suggester' && cleanedMode === 'editing') cleanedMode = 'suggesting';
    if (cleanedMode === 'viewing') {
      this.commands.toggleTrackChangesShowOriginal();
      this.setEditable(false, false);
      this.setOptions({ documentMode: 'viewing' });
      if (caller !== 'init')
        toggleHeaderFooterEditMode({
          editor: this,
          focusedSectionEditor: null,
          isEditMode: false,
          documentMode: cleanedMode,
        });
      if (pm) pm.classList.add('view-mode');
    } else if (cleanedMode === 'suggesting') {
      this.commands.disableTrackChangesShowOriginal();
      this.commands.enableTrackChanges();
      this.setOptions({ documentMode: 'suggesting' });
      this.setEditable(true, false);
      if (pm) pm.classList.remove('view-mode');
    } else if (cleanedMode === 'editing') {
      this.commands.disableTrackChangesShowOriginal();
      this.commands.disableTrackChanges();
      this.setEditable(true, false);
      this.setOptions({ documentMode: 'editing' });
      if (caller !== 'init')
        toggleHeaderFooterEditMode({
          editor: this,
          focusedSectionEditor: null,
          isEditMode: false,
          documentMode: cleanedMode,
        });
      if (pm) pm.classList.remove('view-mode');
    }
  }
  /**
   * Export the yjs binary from the current state.
   * @returns {Promise<Uint8Array>} The exported yjs binary
   */
  async generateCollaborationUpdate() {
    return await generateCollaborationData(this);
  }
  /**
   * Initialize data for collaborative editing
   * If we are replacing data and have a valid provider, listen for synced event
   * so that we can initialize the data
   * @returns {void}
   */
  initializeCollaborationData() {
    if (!this.options.isNewFile || !this.options.collaborationProvider) return;
    const { collaborationProvider: provider } = this.options;
    const postSyncInit = () => {
      provider.off('synced', postSyncInit);
      __privateMethod(this, _Editor_instances, insertNewFileData_fn).call(this);
    };
    if (provider.synced) __privateMethod(this, _Editor_instances, insertNewFileData_fn).call(this);
    else provider.on('synced', postSyncInit);
  }
  /**
   * Replace content of editor that was created with loadFromSchema option
   * Used to replace content of other header/footer when one of it was edited
   *
   * @param {object} content - new editor content json (retrieved from editor.getUpdatedJson)
   * @returns {void}
   */
  replaceContent(content) {
    this.setOptions({
      content,
    });
    __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
    this.initDefaultStyles();
    __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
    __privateMethod(this, _Editor_instances, initMedia_fn).call(this);
    const doc = __privateMethod(this, _Editor_instances, generatePmData_fn).call(this);
    const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc);
    tr.setMeta('replaceContent', true);
    this.view.dispatch(tr);
  }
  /**
   * Set editor options and update state.
   * @param {EditorOptions} options - Editor options
   * @returns {void}
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options,
    };
    if ((this.options.isNewFile || !this.options.ydoc) && this.options.isCommentsEnabled) {
      this.options.shouldLoadComments = true;
    }
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Set whether the editor is editable
   * @param {boolean} [editable=true] - Whether the editor is editable
   * @param {boolean} [emitUpdate=true] - Whether to emit an update event
   * @returns {void}
   */
  setEditable(editable = true, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit('update', { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Register PM plugin.
   * @param plugin PM plugin.
   * @param handlePlugins Optional function for handling plugin merge.
   * @returns {void}
   */
  registerPlugin(plugin, handlePlugins) {
    if (!this.state?.plugins) return;
    const plugins =
      typeof handlePlugins === 'function'
        ? handlePlugins(plugin, [...this.state.plugins])
        : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  /**
   * Unregister a PM plugin
   * @param {string|Object} nameOrPluginKey - Plugin name or plugin instance
   * @returns {void}
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) return;
    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name)),
    });
    this.view.updateState(state);
  }
  /**
   * Load the data from DOCX to be used in the schema.
   * Expects a DOCX file.
   * @static
   * @async
   * @param {File|Blob|Buffer} fileSource - The DOCX file to load (File/Blob in browser, Buffer in Node.js)
   * @param {boolean} [isNode=false] - Whether the method is being called in a Node.js environment
   * @returns {Promise<Array>} - A promise that resolves to an array containing:
   *   - [0] xmlFiles - Array of XML files extracted from the DOCX
   *   - [1] mediaFiles - Object containing media files with URLs (browser only)
   *   - [2] mediaFiles - Object containing media files with base64 data
   *   - [3] fonts - Object containing font files from the DOCX
   */
  static async loadXmlData(fileSource, isNode = false) {
    if (!fileSource) return;
    const zipper = new DocxZipper();
    const xmlFiles = await zipper.getDocxData(fileSource, isNode);
    const mediaFiles = zipper.media;
    return [xmlFiles, mediaFiles, zipper.mediaFiles, zipper.fonts];
  }
  /**
   * Get the document version
   * @static
   * @param {Object} doc - Document object
   * @returns {string} Document version
   */
  static getDocumentVersion(doc) {
    return SuperConverter.getStoredSuperdocVersion(doc);
  }
  /**
   * Set the document version
   * @static
   * @param {Object} doc - Document object
   * @param {string} version - New version
   * @returns {string} The set version
   */
  static setDocumentVersion(doc, version2) {
    return SuperConverter.setStoredSuperdocVersion(doc, version2);
  }
  /**
   * Get the document GUID
   * @static
   * @param {Object} doc - Document object
   * @returns {string|null} Document GUID
   */
  static getDocumentGuid(doc) {
    return SuperConverter.extractDocumentGuid(doc);
  }
  // Deprecated
  /**
   * @deprecated use setDocumentVersion instead
   */
  static updateDocumentVersion(doc, version2) {
    console.warn('updateDocumentVersion is deprecated, use setDocumentVersion instead');
    return _Editor.setDocumentVersion(doc, version2);
  }
  /**
   * Creates all node views.
   * @returns {void}
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionService.nodeViews,
    });
  }
  /**
   * Get the maximum content size
   * @returns {Object} Size object with width and height
   */
  getMaxContentSize() {
    if (!this.converter) return {};
    const { pageSize = {}, pageMargins = {} } = this.converter.pageStyles ?? {};
    const { width, height } = pageSize;
    const { top = 0, bottom = 0, left = 0, right = 0 } = pageMargins;
    if (!width || !height) return {};
    const maxHeight = height * 96 - top * 96 - bottom * 96 - 50;
    const maxWidth = width * 96 - left * 96 - right * 96 - 20;
    return {
      width: maxWidth,
      height: maxHeight,
    };
  }
  /**
   * Attach styles and attributes to the editor element
   */
  updateEditorStyles(element, proseMirror, hasPaginationEnabled = true) {
    const { pageSize, pageMargins } = this.converter.pageStyles ?? {};
    if (!proseMirror || !element) {
      return;
    }
    proseMirror.setAttribute('role', 'document');
    proseMirror.setAttribute('aria-multiline', true);
    proseMirror.setAttribute('aria-label', 'Main content area, start typing to enter text.');
    proseMirror.setAttribute('aria-description', '');
    proseMirror.classList.remove('view-mode');
    if (pageSize) {
      element.style.width = pageSize.width + 'in';
      element.style.minWidth = pageSize.width + 'in';
      element.style.minHeight = pageSize.height + 'in';
    }
    if (pageMargins) {
      element.style.paddingLeft = pageMargins.left + 'in';
      element.style.paddingRight = pageMargins.right + 'in';
    }
    element.style.boxSizing = 'border-box';
    element.style.isolation = 'isolate';
    proseMirror.style.outline = 'none';
    proseMirror.style.border = 'none';
    element.style.backgroundColor = '#fff';
    proseMirror.style.backgroundColor = '#fff';
    const { typeface, fontSizePt, fontFamilyCss } = this.converter.getDocumentDefaultStyles() ?? {};
    const resolvedFontFamily = fontFamilyCss || typeface;
    if (resolvedFontFamily) {
      element.style.fontFamily = resolvedFontFamily;
    }
    if (fontSizePt) {
      element.style.fontSize = `${fontSizePt}pt`;
    }
    element.style.transformOrigin = 'top left';
    element.style.touchAction = 'auto';
    element.style.webkitOverflowScrolling = 'touch';
    const defaultLineHeight = 1.2;
    proseMirror.style.lineHeight = defaultLineHeight;
    if (!hasPaginationEnabled) {
      proseMirror.style.paddingTop = '1in';
      proseMirror.style.paddingBottom = '1in';
    } else {
      proseMirror.style.paddingTop = '0';
      proseMirror.style.paddingBottom = '0';
    }
  }
  /**
   * Initialize default styles for the editor container and ProseMirror.
   * Get page size and margins from the converter.
   * Set document default font and font size.
   *
   * @param {HTMLElement} [element=this.element] - The DOM element to apply styles to
   * @returns {void}
   */
  initDefaultStyles(element = this.element, isPaginationEnabled = true) {
    if (this.options.isHeadless || this.options.suppressDefaultDocxStyles) return;
    const proseMirror = element?.querySelector('.ProseMirror');
    this.updateEditorStyles(element, proseMirror, isPaginationEnabled);
    this.initMobileStyles(element);
  }
  /**
   * Initializes responsive styles for mobile devices.
   * Sets up scaling based on viewport width and handles orientation changes.
   *
   * @param {HTMLElement|void} element - The DOM element to apply mobile styles to
   * @returns {void}
   */
  initMobileStyles(element) {
    if (!element) {
      return;
    }
    const initialWidth = element.offsetWidth;
    const updateScale = () => {
      const minPageSideMargin = 10;
      const elementWidth = initialWidth;
      const availableWidth = document.documentElement.clientWidth - minPageSideMargin;
      this.options.scale = Math.min(1, availableWidth / elementWidth);
      const superEditorElement = element.closest('.super-editor');
      const superEditorContainer = element.closest('.super-editor-container');
      if (!superEditorElement || !superEditorContainer) {
        return;
      }
      if (this.options.scale < 1) {
        superEditorElement.style.maxWidth = `${elementWidth * this.options.scale}px`;
        superEditorContainer.style.minWidth = '0px';
        element.style.transform = `scale(${this.options.scale})`;
      } else {
        superEditorElement.style.maxWidth = '';
        superEditorContainer.style.minWidth = '';
        element.style.transform = 'none';
      }
    };
    updateScale();
    const handleResize = () => {
      setTimeout(() => {
        updateScale();
      }, 150);
    };
    if ('orientation' in screen && 'addEventListener' in screen.orientation) {
      screen.orientation.addEventListener('change', handleResize);
    } else if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {
      window.matchMedia('(orientation: portrait)').addEventListener('change', handleResize);
    }
    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {
      window.addEventListener('resize', () => handleResize);
    }
  }
  /**
   * Get document identifier for telemetry (async - may generate hash)
   * @returns {Promise<string>} GUID for modified docs, hash for unmodified
   */
  async getDocumentIdentifier() {
    return (await this.converter?.getDocumentIdentifier()) || null;
  }
  /**
   * Get permanent document GUID (sync - only for modified documents)
   * @returns {string|null} GUID or null if document hasn't been modified
   */
  getDocumentGuid() {
    return this.converter?.documentGuid || null;
  }
  /**
   * Check if document has been modified
   * @returns {boolean}
   */
  isDocumentModified() {
    return this.converter?.documentModified || false;
  }
  /**
   * Get telemetry data (async because of lazy hash generation)
   */
  async getTelemetryData() {
    return {
      documentId: await this.getDocumentIdentifier(),
      isModified: this.isDocumentModified(),
      isPermanentId: !!this.converter?.documentGuid,
      version: this.converter?.getSuperdocVersion(),
    };
  }
  // Deprecated for backward compatibility
  getDocumentId() {
    console.warn('getDocumentId is deprecated, use getDocumentGuid instead');
    return this.getDocumentGuid();
  }
  /**
   * Get attrs of the currently selected node or mark.
   * @param {String} nameOrType
   * @example
   * editor.getAttributes('textStyle').color
   */
  getAttributes(nameOrType) {
    return Attribute.getAttributes(this.state, nameOrType);
  }
  /**
   * Returns if the currently selected node or mark is active.
   * @param {String|Object} nameOrAttributes - The name of the node/mark or an attributes object
   * @param {Object} [attributesOrUndefined] - Optional attributes to check when first parameter is a name
   * @returns {Boolean} Whether the node or mark is active with the specified attributes
   * @example
   * editor.isActive('bold')
   * editor.isActive('textStyle', { color: 'purple' })
   * editor.isActive({ textAlign: 'center' })
   */
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the editor content as JSON
   * @returns {Object} Editor content as JSON
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get document metadata including GUID, modification status, and version
   * @returns {{
   *   documentGuid: string | null,
   *   isModified: boolean,
   *   version: string | null
   * }} Document metadata
   */
  getMetadata() {
    return {
      documentGuid: this.converter?.documentGuid || null,
      isModified: this.isDocumentModified(),
      version: this.converter?.getSuperdocVersion() || null,
    };
  }
  /**
   * Get the editor content as HTML
   * @param {Object} options - Options for the HTML serializer
   * @param {boolean} [options.unflattenLists] - Whether to unflatten lists in the HTML
   * @returns {string} Editor content as HTML
   */
  getHTML({ unflattenLists = false } = {}) {
    const tempDocument = document.implementation.createHTMLDocument();
    const container = tempDocument.createElement('div');
    const fragment = DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content);
    container.appendChild(fragment);
    let html = container.innerHTML;
    if (unflattenLists) {
      html = unflattenListsInHtml(html);
    }
    return html;
  }
  /**
   * Get the editor content as Markdown
   * @returns {Promise<string>} Editor content as Markdown
   */
  async getMarkdown() {
    const [
      { unified },
      { default: rehypeParse },
      { default: rehypeRemark },
      { default: remarkStringify },
      { default: remarkGfm },
    ] = await Promise.all([
      import('unified'),
      import('rehype-parse'),
      import('rehype-remark'),
      import('remark-stringify'),
      import('remark-gfm'),
    ]);
    const html = this.getHTML();
    const file = unified()
      .use(rehypeParse, { fragment: true })
      .use(rehypeRemark)
      .use(remarkGfm)
      .use(remarkStringify, {
        bullet: '-',
        fences: true,
      })
      .processSync(html);
    return String(file);
  }
  /**
   * Get the document version from the converter
   * @returns {string|null} The SuperDoc version stored in the document
   */
  getDocumentVersion() {
    return this.converter?.getSuperdocVersion() || null;
  }
  /**
   * Create a child editor linked to this editor.
   * This is useful for creating header/footer editors that are linked to the main editor.
   * Or paragraph fields that rely on the same underlying document and list defintions
   * @param {EditorOptions} options - Options for the child editor
   * @returns {Editor} A new child editor instance linked to this editor
   */
  createChildEditor(options) {
    return createLinkedChildEditor(this, options);
  }
  /**
   * Get page styles
   * @returns {Object} Page styles
   */
  getPageStyles() {
    return this.converter?.pageStyles || {};
  }
  /**
   * Update page styles
   *
   * @param {Object} param0
   * @param {Object} param0.pageMargins The new page margins
   * @returns {void}
   */
  updatePageStyle({ pageMargins }) {
    if (!this.converter) return;
    let hasMadeUpdate = false;
    if (pageMargins) {
      this.converter.pageStyles.pageMargins = pageMargins;
      this.initDefaultStyles();
      hasMadeUpdate = true;
    }
    if (hasMadeUpdate && !isHeadless(this)) {
      const newTr = this.view.state.tr;
      newTr.setMeta('forceUpdatePagination', true);
      this.view.dispatch(newTr);
    }
  }
  migrateListsToV2() {
    if (this.options.isHeaderOrFooter) return [];
    const replacements = migrateListsToV2IfNecessary(this);
    return replacements;
  }
  getUpdatedJson() {
    return __privateMethod(this, _Editor_instances, prepareDocumentForExport_fn).call(this);
  }
  /**
   * Export the editor document to DOCX.
   * @async
   * @param {Object} options - The export options
   * @param {boolean} [options.isFinalDoc=false] - Whether this is the final document version
   * @param {string} [options.commentsType] - The type of comments to include
   * @param {Array} [options.comments=[]] - Array of comments to include in the document
   * @param {boolean} [options.getUpdatedDocs=false] - When set to true return only updated docx files
   * @returns {Promise<Blob|ArrayBuffer|Object>} The exported DOCX file or updated docx files
   */
  async exportDocx({
    isFinalDoc = false,
    commentsType = 'external',
    exportJsonOnly = false,
    exportXmlOnly = false,
    comments = [],
    getUpdatedDocs = false,
    fieldsHighlightColor = null,
  } = {}) {
    try {
      const json = __privateMethod(this, _Editor_instances, prepareDocumentForExport_fn).call(this, comments);
      const documentXml = await this.converter.exportToDocx(
        json,
        this.schema,
        this.storage.image.media,
        isFinalDoc,
        commentsType,
        comments,
        this,
        exportJsonOnly,
        fieldsHighlightColor,
      );
      __privateMethod(this, _Editor_instances, validateDocumentExport_fn).call(this);
      if (exportXmlOnly || exportJsonOnly) return documentXml;
      const customXml = this.converter.schemaToXml(this.converter.convertedXml['docProps/custom.xml'].elements[0]);
      const styles = this.converter.schemaToXml(this.converter.convertedXml['word/styles.xml'].elements[0]);
      const hasCustomSettings = !!this.converter.convertedXml['word/settings.xml']?.elements?.length;
      const customSettings = hasCustomSettings
        ? this.converter.schemaToXml(this.converter.convertedXml['word/settings.xml']?.elements?.[0])
        : null;
      const rels = this.converter.schemaToXml(this.converter.convertedXml['word/_rels/document.xml.rels'].elements[0]);
      const media = this.converter.addedMedia;
      const updatedHeadersFooters = {};
      Object.entries(this.converter.convertedXml).forEach(([name, json2]) => {
        if (name.includes('header') || name.includes('footer')) {
          const resultXml = this.converter.schemaToXml(json2.elements[0]);
          updatedHeadersFooters[name] = String(resultXml);
        }
      });
      const numberingData = this.converter.convertedXml['word/numbering.xml'];
      const numbering = this.converter.schemaToXml(numberingData.elements[0]);
      const updatedDocs = {
        ...this.options.customUpdatedFiles,
        'word/document.xml': String(documentXml),
        'docProps/custom.xml': String(customXml),
        'word/_rels/document.xml.rels': String(rels),
        'word/numbering.xml': String(numbering),
        // Replace & with &amp; in styles.xml as DOCX viewers can't handle it
        'word/styles.xml': String(styles).replace(/&/gi, '&amp;'),
        ...updatedHeadersFooters,
      };
      if (hasCustomSettings) {
        updatedDocs['word/settings.xml'] = String(customSettings);
      }
      if (comments.length) {
        const commentsXml = this.converter.schemaToXml(this.converter.convertedXml['word/comments.xml'].elements[0]);
        const commentsExtendedXml = this.converter.schemaToXml(
          this.converter.convertedXml['word/commentsExtended.xml'].elements[0],
        );
        const commentsExtensibleXml = this.converter.schemaToXml(
          this.converter.convertedXml['word/commentsExtensible.xml'].elements[0],
        );
        const commentsIdsXml = this.converter.schemaToXml(
          this.converter.convertedXml['word/commentsIds.xml'].elements[0],
        );
        updatedDocs['word/comments.xml'] = String(commentsXml);
        updatedDocs['word/commentsExtended.xml'] = String(commentsExtendedXml);
        updatedDocs['word/commentsExtensible.xml'] = String(commentsExtensibleXml);
        updatedDocs['word/commentsIds.xml'] = String(commentsIdsXml);
      }
      const zipper = new DocxZipper();
      if (getUpdatedDocs) {
        updatedDocs['[Content_Types].xml'] = await zipper.updateContentTypes(
          {
            files: this.options.content,
          },
          media,
          true,
          updatedDocs,
        );
        return updatedDocs;
      }
      const result = await zipper.updateZip({
        docx: this.options.content,
        updatedDocs,
        originalDocxFile: this.options.fileSource,
        media,
        fonts: this.options.fonts,
        isHeadless: this.options.isHeadless,
      });
      this.options.telemetry?.trackUsage('document_export', {
        documentType: 'docx',
        timestamp: /* @__PURE__ */ new Date().toISOString(),
      });
      return result;
    } catch (error) {
      this.emit('exception', { error, editor: this });
      console.error(error);
    }
  }
  /**
   * Destroy the editor and clean up resources
   * @returns {void}
   */
  destroy() {
    this.emit('destroy');
    this.unmount();
    this.destroyHeaderFooterEditors();
    __privateMethod(this, _Editor_instances, endCollaboration_fn).call(this);
    this.removeAllListeners();
  }
  destroyHeaderFooterEditors() {
    try {
      const headerEditors = this.converter?.headerEditors ?? [];
      const footerEditors = this.converter?.footerEditors ?? [];
      if (!headerEditors.length && !footerEditors.length) return;
      const editors = [...headerEditors, ...footerEditors].filter(Boolean);
      for (let editorData of editors) {
        editorData?.editor?.destroy?.();
      }
      if (headerEditors.length) headerEditors.length = 0;
      if (footerEditors.length) footerEditors.length = 0;
    } catch (error) {
      this.emit('exception', { error, editor: this });
      console.error(error);
    }
  }
  /**
   * Check if migrations are needed for the data
   * @static
   * @param {Object} data - Document data
   * @returns {boolean} Whether migrations are needed
   */
  static checkIfMigrationsNeeded() {
    const dataVersion = version || 'initial';
    const migrations = getNecessaryMigrations(dataVersion) || [];
    console.debug('[checkVersionMigrations] Migrations needed:', dataVersion, migrations.length);
    return migrations.length > 0;
  }
  /**
   * Process collaboration migrations
   * @returns {Object | void} Migration results
   */
  processCollaborationMigrations() {
    console.debug('[checkVersionMigrations] Current editor version', '0.31.0');
    if (!this.options.ydoc) return;
    const metaMap = this.options.ydoc.getMap('meta');
    let docVersion = metaMap.get('version');
    if (!docVersion) docVersion = 'initial';
    console.debug('[checkVersionMigrations] Document version', docVersion);
    const migrations = getNecessaryMigrations(docVersion) || [];
    const plugins = this.state.plugins;
    const syncPlugin = plugins.find((p) => p.key.startsWith('y-sync'));
    if (!syncPlugin) return this.options.ydoc;
    let hasRunMigrations = false;
    for (let migration of migrations) {
      console.debug(' Running migration', migration.name);
      const result = migration(this);
      if (!result) throw new Error('Migration failed at ' + migration.name);
      else hasRunMigrations = true;
    }
    if (!hasRunMigrations) return;
    const pluginState = syncPlugin?.getState(this.state);
    return pluginState.doc;
  }
  /**
   * Replace the current file
   * @async
   * @param {Object} newFile - New file data
   * @returns {Promise<void>}
   */
  async replaceFile(newFile) {
    this.setOptions({ annotations: true });
    const [docx, media, mediaFiles, fonts] = await _Editor.loadXmlData(newFile);
    this.setOptions({
      fileSource: newFile,
      content: docx,
      media,
      mediaFiles,
      fonts,
      isNewFile: true,
      shouldLoadComments: true,
      replacedFile: true,
    });
    __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
    __privateMethod(this, _Editor_instances, initMedia_fn).call(this);
    this.initDefaultStyles();
    if (this.options.ydoc && this.options.collaborationProvider) {
      updateYdocDocxData(this);
      this.initializeCollaborationData();
    } else {
      __privateMethod(this, _Editor_instances, insertNewFileData_fn).call(this);
    }
    if (!this.options.ydoc) {
      __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
      __privateMethod(this, _Editor_instances, initComments_fn).call(this);
    }
  }
  /**
   * Get internal docx file content
   * @param {string} name - File name
   * @param {string} type - type of result (json, string)
   * @returns {Object|String} - file content
   */
  getInternalXmlFile(name, type = 'json') {
    if (!this.converter.convertedXml[name]) {
      console.warn('Cannot find file in docx');
      return null;
    }
    if (type === 'json') {
      return this.converter.convertedXml[name].elements[0] || null;
    }
    return this.converter.schemaToXml(this.converter.convertedXml[name].elements[0]);
  }
  /**
   * Update internal docx file content
   * @param {string} name - File name
   * @param {string} updatedContent - new file content
   */
  updateInternalXmlFile(name, updatedContent) {
    if (typeof updatedContent === 'string') {
      this.options.customUpdatedFiles[name] = String(updatedContent);
    } else {
      const internalFileXml = this.converter.schemaToXml(updatedContent);
      this.options.customUpdatedFiles[name] = String(internalFileXml);
    }
    this.options.isCustomXmlChanged = true;
  }
  /**
   * Get all nodes of a specific type
   * @param {string} type - Node type
   * @returns {Array} Array of nodes
   */
  getNodesOfType(type) {
    const { findChildren: findChildren2 } = helpers;
    return findChildren2(this.state.doc, (node) => node.type.name === type);
  }
  /**
   * Replace a node with HTML content
   * @param {Object} targetNode - The node to replace
   * @param {string} html - HTML content to replace with
   * @returns {void}
   */
  replaceNodeWithHTML(targetNode, html) {
    const { tr } = this.state;
    const { dispatch } = this.view;
    if (!targetNode || !html) return;
    const start = targetNode.pos;
    const end = start + targetNode.node.nodeSize;
    const htmlNode = createDocFromHTML(html, this.schema);
    tr.replaceWith(start, end, htmlNode);
    dispatch(tr);
  }
  /**
   * A command to prepare the editor to receive annotations. This will
   * pre-process the document as needed prior to running in the annotator.
   *
   * Currently this is only used for table generation but additional pre-processing can be done here.
   *
   * @param {FieldValue[]} annotationValues
   * @returns {void}
   */
  prepareForAnnotations(annotationValues = []) {
    const { tr } = this.state;
    const newTr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    this.view.dispatch(newTr);
  }
  /**
   * Migrate paragraph fields to lists V2 structure if necessary.
   * @param {FieldValue[]} annotationValues - List of field values to migrate.
   * @returns {Promise<FieldValue[]>} - Returns a promise that resolves to the migrated
   */
  async migrateParagraphFields(annotationValues = []) {
    if (!Array.isArray(annotationValues) || !annotationValues.length) return annotationValues;
    const result = await migrateParagraphFieldsListsV2(annotationValues, this);
    return result;
  }
  /**
   * Annotate the document with the given annotation values.
   *
   * @param {FieldValue[]} annotationValues List of field values to apply.
   * @param {String[]} hiddenIds List of field ids to remove from the document.
   * @returns {void}
   */
  annotate(annotationValues = [], hiddenIds = [], removeEmptyFields = false) {
    const { state, view, schema } = this;
    let tr = state.tr;
    tr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    tr = AnnotatorHelpers.annotateDocument({
      tr,
      schema,
      annotationValues,
      hiddenFieldIds: hiddenIds,
      removeEmptyFields,
      editor: this,
    });
    if (tr.docChanged) view.dispatch(tr.scrollIntoView());
  }
  /**
   * Preview annotations in the editor. It stores a copy of the original state.
   * This can be reverted via closePreview()
   *
   * @param {Object[]} annotationValues
   * @param {string[]} hiddenIds
   * @returns {void}
   */
  previewAnnotations(annotationValues = [], hiddenIds = []) {
    this.originalState = this.view.state;
    this.annotate(annotationValues, hiddenIds);
  }
  /**
   * If there is a preview active, this will revert the editor to the original state.
   *
   * @returns {void}
   */
  closePreview() {
    if (!this.originalState) return;
    this.view.updateState(this.originalState);
  }
};
_commandService = new WeakMap();
_Editor_instances = new WeakSet();
/**
 * Initialize the container element for the editor
 * @param {EditorOptions} options - Editor options
 * @returns {void}
 */
initContainerElement_fn = function (options) {
  if (!options.element && options.selector) {
    const { selector } = options;
    if (selector.startsWith('#') || selector.startsWith('.')) {
      options.element = document.querySelector(selector);
    } else {
      options.element = document.getElementById(selector);
    }
    const textModes = ['text', 'html'];
    if (textModes.includes(options.mode) && options.element) {
      options.element.classList.add('sd-super-editor-html');
    }
  }
  if (options.isHeadless) {
    options.element = null;
    return;
  }
  options.element = options.element || document.createElement('div');
  applyStyleIsolationClass(options.element);
};
/**
 * Initialize the editor with the given options
 * @returns {void}
 */
init_fn = function () {
  __privateMethod(this, _Editor_instances, createExtensionService_fn).call(this);
  __privateMethod(this, _Editor_instances, createCommandService_fn).call(this);
  __privateMethod(this, _Editor_instances, createSchema_fn).call(this);
  __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
  __privateMethod(this, _Editor_instances, initMedia_fn).call(this);
  if (!this.options.isHeadless) {
    __privateMethod(this, _Editor_instances, initFonts_fn).call(this);
  }
  this.on('beforeCreate', this.options.onBeforeCreate);
  this.emit('beforeCreate', { editor: this });
  this.on('contentError', this.options.onContentError);
  this.mount(this.options.element);
  this.on('create', this.options.onCreate);
  this.on('update', this.options.onUpdate);
  this.on('selectionUpdate', this.options.onSelectionUpdate);
  this.on('transaction', this.options.onTransaction);
  this.on('focus', __privateMethod(this, _Editor_instances, onFocus_fn));
  this.on('blur', this.options.onBlur);
  this.on('destroy', this.options.onDestroy);
  this.on('trackedChangesUpdate', this.options.onTrackedChangesUpdate);
  this.on('commentsLoaded', this.options.onCommentsLoaded);
  this.on('commentClick', this.options.onCommentClicked);
  this.on('commentsUpdate', this.options.onCommentsUpdate);
  this.on('locked', this.options.onDocumentLocked);
  this.on('collaborationReady', __privateMethod(this, _Editor_instances, onCollaborationReady_fn));
  this.on('paginationUpdate', this.options.onPaginationUpdate);
  this.on('comment-positions', this.options.onCommentLocationsUpdate);
  this.on('list-definitions-change', this.options.onListDefinitionsChange);
  this.on('fonts-resolved', this.options.onFontsResolved);
  this.on('exception', this.options.onException);
  if (!this.options.isHeadless) {
    this.initializeCollaborationData();
    this.initDefaultStyles();
    __privateMethod(this, _Editor_instances, checkFonts_fn).call(this);
  }
  const shouldMigrateListsOnInit = Boolean(
    this.options.markdown ||
      this.options.html ||
      this.options.loadFromSchema ||
      this.options.jsonOverride ||
      this.options.mode === 'html' ||
      this.options.mode === 'text',
  );
  if (shouldMigrateListsOnInit) {
    this.migrateListsToV2();
  }
  this.setDocumentMode(this.options.documentMode, 'init');
  if (!this.options.ydoc) {
    if (!this.options.isChildEditor) {
      __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
      __privateMethod(this, _Editor_instances, initComments_fn).call(this);
      __privateMethod(this, _Editor_instances, validateDocumentInit_fn).call(this);
    }
  }
  __privateMethod(this, _Editor_instances, initDevTools_fn).call(this);
  __privateMethod(this, _Editor_instances, registerCopyHandler_fn).call(this);
};
/**
 * Initialize the editor in rich text mode
 * @param {EditorOptions} options - Editor options
 * @returns {void}
 */
initRichText_fn = function () {
  if (!this.options.extensions || !this.options.extensions.length) {
    this.options.extensions = getRichTextExtensions();
  }
  __privateMethod(this, _Editor_instances, createExtensionService_fn).call(this);
  __privateMethod(this, _Editor_instances, createCommandService_fn).call(this);
  __privateMethod(this, _Editor_instances, createSchema_fn).call(this);
  this.on('beforeCreate', this.options.onBeforeCreate);
  this.emit('beforeCreate', { editor: this });
  this.on('contentError', this.options.onContentError);
  this.mount(this.options.element);
  this.on('create', this.options.onCreate);
  this.on('update', this.options.onUpdate);
  this.on('selectionUpdate', this.options.onSelectionUpdate);
  this.on('transaction', this.options.onTransaction);
  this.on('focus', __privateMethod(this, _Editor_instances, onFocus_fn));
  this.on('blur', this.options.onBlur);
  this.on('destroy', this.options.onDestroy);
  this.on('commentsLoaded', this.options.onCommentsLoaded);
  this.on('commentClick', this.options.onCommentClicked);
  this.on('locked', this.options.onDocumentLocked);
  this.on('list-definitions-change', this.options.onListDefinitionsChange);
};
/**
 *
 * @param {Object} param0
 * @param {Object} param0.editor
 * @param {Object} param0.event
 * @returns {void}
 */
onFocus_fn = function ({ editor, event }) {
  this.toolbar?.setActiveEditor(editor);
  this.options.onFocus({ editor, event });
};
/**
 * Check if the editor should run in headless mode
 * @param {EditorOptions} options - Editor options
 * @returns {void}
 */
checkHeadless_fn = function (options) {
  if (!options.isHeadless) return;
  if (typeof navigator === 'undefined') {
    global.navigator = { isHeadless: true };
  }
  if (options.mockDocument) {
    global.document = options.mockDocument;
    global.window = options.mockWindow;
  }
};
registerCopyHandler_fn = function () {
  this.view.dom.addEventListener('copy', (event) => {
    const clipboardData = event.clipboardData;
    if (!clipboardData) return;
    event.preventDefault();
    const { from, to } = this.view.state.selection;
    const slice = this.view.state.doc.slice(from, to);
    const fragment = slice.content;
    const div = document.createElement('div');
    const serializer = DOMSerializer.fromSchema(this.view.state.schema);
    div.appendChild(serializer.serializeFragment(fragment));
    const html = transformListsInCopiedContent(div.innerHTML);
    clipboardData.setData('text/html', html);
  });
};
/**
 * Replace the current document with new data. Necessary for initializing a new collaboration file,
 * since we need to insert the data only after the provider has synced.
 */
/**
 * Insert data for a new file
 * @returns {void}
 */
insertNewFileData_fn = function () {
  if (!this.options.isNewFile) return;
  this.options.isNewFile = false;
  const doc = __privateMethod(this, _Editor_instances, generatePmData_fn).call(this);
  const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc).setMeta('addToHistory', false);
  this.view.dispatch(tr);
  setTimeout(() => {
    __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
    __privateMethod(this, _Editor_instances, initComments_fn).call(this);
  }, 50);
};
/**
 * Creates extension service.
 * @returns {void}
 */
createExtensionService_fn = function () {
  const allowedExtensions = ['extension', 'node', 'mark'];
  const coreExtensions = [Editable, Commands, EditorFocus, Keymap];
  const externalExtensions = this.options.externalExtensions || [];
  const allExtensions = [...coreExtensions, ...this.options.extensions].filter((e) =>
    allowedExtensions.includes(e?.type),
  );
  this.extensionService = ExtensionService.create(allExtensions, externalExtensions, this);
};
/**
 * Creates a command service.
 * @returns {void}
 */
createCommandService_fn = function () {
  __privateSet(
    this,
    _commandService,
    CommandService.create({
      editor: this,
    }),
  );
};
/**
 * Creates a SuperConverter.
 */
/**
 * Create the document converter as this.converter.
 * @returns {void}
 */
createConverter_fn = function () {
  if (this.options.converter) {
    this.converter = this.options.converter;
  } else {
    this.converter = new SuperConverter({
      docx: this.options.content,
      media: this.options.mediaFiles,
      fonts: this.options.fonts,
      debug: true,
      telemetry: this.options.telemetry,
      fileSource: this.options.fileSource,
      documentId: this.options.documentId,
    });
  }
};
/**
 * Initialize media.
 * @returns {void}
 */
initMedia_fn = function () {
  if (this.options.isChildEditor) return;
  if (!this.options.ydoc) return (this.storage.image.media = this.options.mediaFiles);
  const mediaMap = this.options.ydoc.getMap('media');
  if (this.options.isNewFile) {
    Object.entries(this.options.mediaFiles).forEach(([key2, value]) => {
      mediaMap.set(key2, value);
    });
    this.storage.image.media = this.options.mediaFiles;
  } else {
    this.storage.image.media = Object.fromEntries(mediaMap.entries());
  }
};
/**
 * Initialize fonts
 * @returns {void}
 */
initFonts_fn = function () {
  const results = this.converter.getFontFaceImportString();
  if (results?.styleString?.length) {
    const style = document.createElement('style');
    style.textContent = results.styleString;
    document.head.appendChild(style);
    this.fontsImported = results.fontsImported;
  }
};
checkFonts_fn = async function () {
  if (!this.options.onFontsResolved || typeof this.options.onFontsResolved !== 'function') {
    return;
  }
  if (this.options.isHeadless) {
    return;
  }
  try {
    const fontsUsedInDocument = this.converter.getDocumentFonts();
    const unsupportedFonts = __privateMethod(this, _Editor_instances, determineUnsupportedFonts_fn).call(
      this,
      fontsUsedInDocument,
    );
    this.emit('fonts-resolved', {
      documentFonts: fontsUsedInDocument,
      unsupportedFonts,
    });
  } catch {
    console.warn('[SuperDoc] Could not determine document fonts and unsupported fonts');
  }
};
/**
 * Determines which fonts used in the document are not supported
 * by attempting to render them on a canvas.
 * Fonts are considered unsupported if they cannot be rendered
 * and are not already imported in the document via @font-face.
 *
 * @param {string[]} fonts - Array of font family names used in the document.
 * @returns {string[]} Array of unsupported font family names.
 */
determineUnsupportedFonts_fn = function (fonts) {
  const unsupportedFonts = fonts.filter((font) => {
    const canRender = canRenderFont(font);
    const isFontImported = this.fontsImported.includes(font);
    return !canRender && !isFontImported;
  });
  return unsupportedFonts;
};
/**
 * Creates document PM schema.
 * @returns {void}
 */
createSchema_fn = function () {
  this.schema = this.extensionService.schema;
};
/**
 * Generate ProseMirror data from file
 * @returns {Object} ProseMirror data
 */
generatePmData_fn = function () {
  let doc;
  try {
    const { mode, fragment, content, loadFromSchema } = this.options;
    if (mode === 'docx') {
      if (loadFromSchema) {
        doc = this.schema.nodeFromJSON(content);
        doc = __privateMethod(this, _Editor_instances, prepareDocumentForImport_fn).call(this, doc);
      } else {
        doc = createDocument(this.converter, this.schema, this);
        doc = __privateMethod(this, _Editor_instances, prepareDocumentForImport_fn).call(this, doc);
        if (this.options.markdown) {
          doc = createDocFromMarkdown(this.options.markdown, this.schema, { isImport: true });
        } else if (this.options.html) doc = createDocFromHTML(this.options.html, this.schema, { isImport: true });
        else if (this.options.jsonOverride) doc = this.schema.nodeFromJSON(this.options.jsonOverride);
        if (fragment) doc = yXmlFragmentToProseMirrorRootNode(fragment, this.schema);
      }
    } else if (mode === 'text' || mode === 'html') {
      if (loadFromSchema) doc = this.schema.nodeFromJSON(content);
      else if (content) doc = createDocFromHTML(content, this.schema);
      else doc = this.schema.topNodeType.createAndFill();
    }
  } catch (err) {
    console.error(err);
    this.emit('contentError', { editor: this, error: err });
  }
  return doc;
};
/**
 * Create the PM editor view
 * @returns {void}
 */
createView_fn = function (element) {
  let doc = __privateMethod(this, _Editor_instances, generatePmData_fn).call(this);
  const state = { schema: this.schema };
  if (!this.options.ydoc) state.doc = doc;
  this.options.initialState = EditorState.create(state);
  this.view = new EditorView(element, {
    ...this.options.editorProps,
    dispatchTransaction: __privateMethod(this, _Editor_instances, dispatchTransaction_fn).bind(this),
    state: this.options.initialState,
    handleClick: __privateMethod(this, _Editor_instances, handleNodeSelection_fn).bind(this),
    handleDoubleClick: async (view, pos, event) => {
      if (this.options.documentMode !== 'editing') return;
      if (!isHeadless(this)) {
        const isHeader = hasSomeParentWithClass(event.target, 'pagination-section-header');
        const isFooter = hasSomeParentWithClass(event.target, 'pagination-section-footer');
        if (isHeader || isFooter) {
          const eventClone = new event.constructor(event.type);
          event.target.dispatchEvent(eventClone);
          if (this.options.isHeaderOrFooter && this.options.editable) setWordSelection(view, pos);
          return;
        }
      }
      event.stopPropagation();
      if (!this.options.editable && !isHeadless(this)) {
        this.setEditable(true, false);
        toggleHeaderFooterEditMode({
          editor: this,
          focusedSectionEditor: null,
          isEditMode: false,
          documentMode: this.options.documentMode,
        });
        const pm = this.view?.dom || this.options.element?.querySelector?.('.ProseMirror');
        if (pm) {
          pm.classList.remove('header-footer-edit');
          pm.setAttribute('aria-readonly', false);
        }
      }
      setWordSelection(view, pos);
    },
  });
  const newState = this.state.reconfigure({
    plugins: [...this.extensionService.plugins],
  });
  this.view.updateState(newState);
  this.createNodeViews();
  this.options.telemetry?.sendReport();
};
/**
 * Handler called when collaboration is ready.
 * Initializes pagination and comments if not a new file.
 *
 * @param {Object} params - Collaboration parameters
 * @param {Editor} params.editor - The editor instance
 * @param {Object} params.ydoc - The Yjs document
 * @returns {void}
 */
onCollaborationReady_fn = function ({ editor, ydoc }) {
  if (this.options.collaborationIsReady) return;
  console.debug(' [super-editor] Collaboration ready');
  __privateMethod(this, _Editor_instances, validateDocumentInit_fn).call(this);
  if (this.options.ydoc) {
    this.migrateListsToV2();
  }
  this.options.onCollaborationReady({ editor, ydoc });
  this.options.collaborationIsReady = true;
  this.options.initialState = this.state;
  const { tr } = this.state;
  tr.setMeta('collaborationReady', true);
  this.view.dispatch(tr);
  if (!this.options.isNewFile) {
    __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
    __privateMethod(this, _Editor_instances, initComments_fn).call(this);
    updateYdocDocxData(this);
  }
};
/**
 * Initialize comments plugin
 * @returns {void}
 */
initComments_fn = function () {
  if (!this.options.isCommentsEnabled) return;
  if (this.options.isHeadless) return;
  if (!this.options.shouldLoadComments) return;
  const replacedFile = this.options.replacedFile;
  this.emit('commentsLoaded', { editor: this, replacedFile, comments: this.converter.comments || [] });
  setTimeout(() => {
    this.options.replacedFile = false;
    const { state, dispatch } = this.view;
    const tr = state.tr.setMeta(CommentsPluginKey, { type: 'force' });
    dispatch(tr);
  }, 50);
};
initPagination_fn = async function () {
  if (this.options.isHeadless || !this.extensionService || this.options.isHeaderOrFooter) {
    return;
  }
  const pagination = this.options.extensions.find((e) => e.name === 'pagination');
  if (pagination && this.options.pagination) {
    const sectionData = await initPaginationData(this);
    this.storage.pagination.sectionData = sectionData;
    const { state, dispatch } = this.view;
    const tr = state.tr.setMeta(PaginationPluginKey, { isReadyToInit: true });
    dispatch(tr);
  }
};
/**
 * Dispatch a transaction to update the editor state
 * @param {Object} transaction - ProseMirror transaction
 */
dispatchTransaction_fn = function (transaction) {
  if (this.isDestroyed) return;
  const start = Date.now();
  let state;
  try {
    const trackChangesState = TrackChangesBasePluginKey.getState(this.view.state);
    const isTrackChangesActive = trackChangesState?.isTrackChangesActive ?? false;
    const tr = isTrackChangesActive
      ? trackedTransaction({
          tr: transaction,
          state: this.state,
          user: this.options.user,
        })
      : transaction;
    const { state: newState } = this.view.state.applyTransaction(tr);
    state = newState;
  } catch (error) {
    state = this.state.apply(transaction);
    console.log(error);
  }
  const selectionHasChanged = !this.state.selection.eq(state.selection);
  this.view.updateState(state);
  const end = Date.now();
  this.emit('transaction', {
    editor: this,
    transaction,
    duration: end - start,
  });
  if (selectionHasChanged) {
    this.emit('selectionUpdate', {
      editor: this,
      transaction,
    });
  }
  const focus = transaction.getMeta('focus');
  if (focus) {
    this.emit('focus', {
      editor: this,
      event: focus.event,
      transaction,
    });
  }
  const blur = transaction.getMeta('blur');
  if (blur) {
    this.emit('blur', {
      editor: this,
      event: blur.event,
      transaction,
    });
  }
  if (!transaction.docChanged) {
    return;
  }
  if (transaction.docChanged && this.converter) {
    if (!this.converter.documentGuid) {
      this.converter.promoteToGuid();
      console.debug('Document modified - assigned GUID:', this.converter.documentGuid);
    }
    this.converter.documentModified = true;
  }
  this.emit('update', {
    editor: this,
    transaction,
  });
};
/**
 * Handles image node selection for header/footer editor
 */
handleNodeSelection_fn = function (view, pos) {
  this.setOptions({
    lastSelection: null,
  });
  if (this.options.isHeaderOrFooter) {
    return setImageNodeSelection(view, pos);
  }
};
/**
 * Perform any post conversion pre prosemirror import processing.
 * Comments are processed here.
 * @param {Object} doc The prosemirror document
 * @returns {Object} The updated prosemirror document
 */
prepareDocumentForImport_fn = function (doc) {
  const newState = EditorState.create({
    schema: this.schema,
    doc,
  });
  const { tr, doc: newDoc } = newState;
  prepareCommentsForImport(newDoc, tr, this.schema, this.converter);
  const updatedState = newState.apply(tr);
  return updatedState.doc;
};
/**
 * Prepare the document for export. Any necessary pre-export processing to the state
 * can happen here.
 * @returns {Object} The updated document in JSON
 */
prepareDocumentForExport_fn = function (comments = []) {
  const newState = EditorState.create({
    schema: this.schema,
    doc: this.state.doc,
    plugins: this.state.plugins,
  });
  const { tr, doc } = newState;
  prepareCommentsForExport(doc, tr, this.schema, comments);
  const updatedState = newState.apply(tr);
  return updatedState.doc.toJSON();
};
/**
 * Destroy collaboration provider and ydoc
 * @returns {void}
 */
endCollaboration_fn = function () {
  if (!this.options.ydoc) return;
  try {
    console.debug(' [super-editor] Ending collaboration');
    if (this.options.collaborationProvider) this.options.collaborationProvider.disconnect();
    if (this.options.ydoc) this.options.ydoc.destroy();
  } catch (error) {
    this.emit('exception', { error, editor: this });
    console.error(error);
  }
};
/**
 * Run the SuperValidator's active document validation to check and fix potential known issues.
 * @returns {void}
 */
validateDocumentInit_fn = function () {
  if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
  const validator = new SuperValidator({ editor: this, dryRun: false, debug: false });
  validator.validateActiveDocument();
};
/**
 * Run the SuperValidator's on document upon export to check and fix potential known issues.
 * @returns {void}
 */
validateDocumentExport_fn = function () {
  if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
  const validator = new SuperValidator({ editor: this, dryRun: false, debug: false });
  validator.validateDocumentExport();
};
initDevTools_fn = function () {
  if (this.options.isHeaderOrFooter) return;
  if (process.env.NODE_ENV === 'development' || this.options.isDebug) {
    window.superdocdev = {
      converter: this.converter,
      editor: this,
    };
  }
};
let Editor = _Editor;
const Color = Extension.create({
  name: 'color',
  addOptions() {
    return {
      types: ['textStyle'],
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseDOM: (el) => el.style.color?.replace(/['"]+/g, ''),
            renderDOM: (attrs) => {
              if (!attrs.color) return {};
              return { style: `color: ${attrs.color}` };
            },
          },
        },
      },
    ];
  },
  addCommands() {
    return {
      /**
       * Set text color
       * @category Command
       * @param {ColorValue} color - Color value to apply
       * @example
       * // Set to red using hex
       * editor.commands.setColor('#ff0000')
       *
       * @example
       * // Set using rgb
       * editor.commands.setColor('rgb(255, 0, 0)')
       *
       * @example
       * // Set using named color
       * editor.commands.setColor('blue')
       * @note Preserves other text styling attributes
       */
      setColor:
        (color) =>
        ({ chain }) => {
          return chain().setMark('textStyle', { color }).run();
        },
      /**
       * Remove text color
       * @category Command
       * @example
       * editor.commands.unsetColor()
       * @note Removes color while preserving other text styles
       */
      unsetColor:
        () =>
        ({ chain }) => {
          return chain().setMark('textStyle', { color: null }).removeEmptyTextStyle().run();
        },
    };
  },
});
const FontFamily = Extension.create({
  name: 'fontFamily',
  addOptions() {
    return {
      types: ['textStyle'],
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseDOM: (el) => el.style.fontFamily?.replace(/['"]+/g, ''),
            renderDOM: (attrs) => {
              if (!attrs.fontFamily) return {};
              return { style: `font-family: ${attrs.fontFamily}` };
            },
          },
        },
      },
    ];
  },
  addCommands() {
    return {
      /**
       * Set font family
       * @category Command
       * @param {FontFamilyValue} fontFamily - Font family to apply
       * @example
       * // Set to Arial
       * editor.commands.setFontFamily('Arial')
       *
       * @example
       * // Set to serif font
       * editor.commands.setFontFamily('Georgia, serif')
       * @note Preserves other text styling attributes
       */
      setFontFamily:
        (fontFamily) =>
        ({ chain }) => {
          return chain().setMark('textStyle', { fontFamily }).run();
        },
      /**
       * Remove font family
       * @category Command
       * @example
       * editor.commands.unsetFontFamily()
       * @note Reverts to default document font
       */
      unsetFontFamily:
        () =>
        ({ chain }) => {
          return chain().setMark('textStyle', { fontFamily: null }).removeEmptyTextStyle().run();
        },
    };
  },
});
const FontSize = Extension.create({
  name: 'fontSize',
  addOptions() {
    return {
      types: ['textStyle', 'tableCell'],
      defaults: {
        value: 12,
        unit: 'pt',
        min: 8,
        max: 96,
      },
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseDOM: (el) => el.style.fontSize,
            renderDOM: (attrs) => {
              if (!attrs.fontSize) return {};
              let [value, unit] = parseSizeUnit(attrs.fontSize);
              if (Number.isNaN(value)) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `font-size: ${value}${unit}` };
            },
          },
        },
      },
    ];
  },
  addCommands() {
    return {
      /**
       * Set font size
       * @category Command
       * @param {FontSizeValue} fontSize - Size to apply (with optional unit)
       * @example
       * editor.commands.setFontSize('14pt')
       * editor.commands.setFontSize('18px')
       * editor.commands.setFontSize(16)
       * @note Automatically clamps to min/max values
       */
      setFontSize:
        (fontSize) =>
        ({ chain }) => {
          let value, unit;
          if (typeof fontSize === 'number') {
            value = fontSize;
            unit = null;
          } else {
            [value, unit] = parseSizeUnit(fontSize);
          }
          if (Number.isNaN(value)) {
            return false;
          }
          let { min, max, unit: defaultUnit } = this.options.defaults;
          value = minMax(Number(value), min, max);
          unit = unit ? unit : defaultUnit;
          return chain()
            .setMark('textStyle', { fontSize: `${value}${unit}` })
            .run();
        },
      /**
       * Remove font size
       * @category Command
       * @example
       * editor.commands.unsetFontSize()
       * @note Reverts to default document size
       */
      unsetFontSize:
        () =>
        ({ chain }) => {
          return chain().setMark('textStyle', { fontSize: null }).removeEmptyTextStyle().run();
        },
    };
  },
});
const TextAlign = Extension.create({
  name: 'textAlign',
  addOptions() {
    return {
      types: ['heading', 'paragraph'],
      alignments: ['left', 'center', 'right', 'justify'],
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {string} [textAlign='left'] - Text alignment value (left, center, right, justify)
           */
          textAlign: {
            default: this.options.defaultAlignment,
            parseDOM: (el) => {
              const alignment = el.style.textAlign || this.options.defaultAlignment;
              const containsAlignment = this.options.alignments.includes(alignment);
              return containsAlignment ? alignment : this.options.defaultAlignment;
            },
            renderDOM: (attrs) => {
              if (attrs.textAlign === this.options.defaultAlignment) return {};
              const textAlign = attrs.textAlign === 'both' ? 'justify' : attrs.textAlign;
              if (!textAlign) return {};
              return { style: `text-align: ${textAlign}` };
            },
          },
        },
      },
    ];
  },
  addCommands() {
    return {
      /**
       * Set text alignment
       * @category Command
       * @param {string} alignment - Alignment value (left, center, right, justify)
       * @example
       * editor.commands.setTextAlign('center')
       * editor.commands.setTextAlign('justify')
       * @note Applies to all configured node types (heading, paragraph by default)
       */
      setTextAlign:
        (alignment) =>
        ({ commands: commands2 }) => {
          const containsAlignment = this.options.alignments.includes(alignment);
          if (!containsAlignment) return false;
          return this.options.types
            .map((type) => commands2.updateAttributes(type, { textAlign: alignment }))
            .every((result) => result);
        },
      /**
       * Remove text alignment (reset to default)
       * @category Command
       * @example
       * editor.commands.unsetTextAlign()
       * @note Resets alignment to the default value
       */
      unsetTextAlign:
        () =>
        ({ commands: commands2 }) => {
          return this.options.types
            .map((type) => commands2.resetAttributes(type, 'textAlign'))
            .every((result) => result);
        },
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-l': () => this.editor.commands.setTextAlign('left'),
      'Mod-Shift-e': () => this.editor.commands.setTextAlign('center'),
      'Mod-Shift-r': () => this.editor.commands.setTextAlign('right'),
      'Mod-Shift-j': () => this.editor.commands.setTextAlign('justify'),
    };
  },
});
const TextIndent = Extension.create({
  name: 'textIndent',
  addOptions() {
    return {
      types: ['heading', 'paragraph'],
      defaults: {
        unit: 'in',
        increment: 0.125,
      },
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {string} [textIndent] - Text indentation value with unit (e.g., '0.5in')
           */
          textIndent: {
            default: null,
            parseDOM: (el) => el.style.textIndent,
            renderDOM: (attrs) => {
              if (!attrs.textIndent) return {};
              let [value, unit] = parseSizeUnit(attrs.textIndent);
              if (Number.isNaN(value) || !value) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `margin-left: ${value}${unit}` };
            },
          },
        },
      },
    ];
  },
  addCommands() {
    return {
      /**
       * Set text indentation
       * @category Command
       * @param {string} indent - Indentation value with unit (e.g., '0.5in', '2cm')
       * @returns {Function} Command function
       * @example
       * // Set to 0.5 inches
       * setTextIndent('0.5in')
       *
       * // Set to 2 centimeters
       * setTextIndent('2cm')
       * @note Accepts any valid CSS unit (in, cm, px, em, etc.)
       */
      setTextIndent:
        (indent) =>
        ({ commands: commands2 }) => {
          if (!indent) return false;
          return this.options.types
            .map((type) => commands2.updateAttributes(type, { textIndent: indent }))
            .every((result) => result);
        },
      /**
       * Remove text indentation
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetTextIndent()
       * @note Removes all indentation from the selected nodes
       */
      unsetTextIndent:
        () =>
        ({ commands: commands2 }) => {
          return this.options.types
            .map((type) => commands2.resetAttributes(type, 'textIndent'))
            .every((result) => result);
        },
      /**
       * Increase text indentation
       * @category Command
       * @returns {Function} Command function
       * @example
       * increaseTextIndent()
       * @note Increments by the default value (0.125in by default)
       * @note Creates initial indent if none exists
       */
      increaseTextIndent:
        () =>
        ({ commands: commands2 }) => {
          return this.options.types
            .map((type) => {
              let { textIndent } = this.editor.getAttributes(type);
              if (!textIndent) {
                let { increment, unit: unit2 } = this.options.defaults;
                return commands2.updateAttributes(type, {
                  textIndent: `${increment}${unit2}`,
                });
              }
              let [value, unit] = parseSizeUnit(textIndent);
              value = Number(value) + this.options.defaults.increment;
              unit = unit ? unit : this.options.defaults.unit;
              if (Number.isNaN(value)) return false;
              return commands2.updateAttributes(type, {
                textIndent: `${value}${unit}`,
              });
            })
            .every((result) => result);
        },
      /**
       * Decrease text indentation
       * @category Command
       * @returns {Function} Command function
       * @example
       * decreaseTextIndent()
       * @note Decrements by the default value (0.125in by default)
       * @note Removes indentation completely if it reaches 0 or below
       */
      decreaseTextIndent:
        () =>
        ({ commands: commands2 }) => {
          return this.options.types
            .map((type) => {
              let { textIndent } = this.editor.getAttributes(type);
              if (!textIndent) return false;
              let [value, unit] = parseSizeUnit(textIndent);
              value = Number(value) - this.options.defaults.increment;
              unit = unit ? unit : this.options.defaults.unit;
              if (Number.isNaN(value)) return false;
              if (value <= 0) {
                return commands2.unsetTextIndent();
              }
              return commands2.updateAttributes(type, {
                textIndent: `${value}${unit}`,
              });
            })
            .every((result) => result);
        },
    };
  },
});
const LineHeight = Extension.create({
  name: 'lineHeight',
  addOptions() {
    return {
      types: ['heading', 'paragraph'],
      defaults: {
        unit: '',
      },
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseDOM: (el) => el.style.lineHeight,
            renderDOM: (attrs) => {
              if (!attrs.lineHeight) return {};
              const lineHeightStyle = getLineHeightValueString(
                attrs.lineHeight,
                this.options.defaults.unit,
                attrs.spacing?.lineRule,
              );
              return {
                style: `${lineHeightStyle}`,
              };
            },
          },
        },
      },
    ];
  },
  addCommands() {
    return {
      /**
       * Set line height for blocks
       * @category Command
       * @param {LineHeightValue} lineHeight - Line height to apply
       * @example
       * editor.commands.setLineHeight(1.5)
       * editor.commands.setLineHeight('24px')
       * editor.commands.setLineHeight(2)
       * @note Applies to paragraphs and headings
       */
      setLineHeight:
        (lineHeight) =>
        ({ commands: commands2 }) => {
          if (!lineHeight) return false;
          return this.options.types
            .map((type) => commands2.updateAttributes(type, { lineHeight }))
            .every((result) => result);
        },
      /**
       * Remove line height
       * @category Command
       * @example
       * editor.commands.unsetLineHeight()
       * @note Reverts to default line spacing
       */
      unsetLineHeight:
        () =>
        ({ commands: commands2 }) => {
          return this.options.types
            .map((type) => commands2.resetAttributes(type, 'lineHeight'))
            .every((result) => result);
        },
    };
  },
});
const FormatCommands = Extension.create({
  name: 'formatCommands',
  addOptions() {
    return {};
  },
  addStorage() {
    return {
      /**
       * @private
       * @type {StoredStyle[]|null}
       */
      storedStyle: null,
    };
  },
  addCommands() {
    return {
      toggleMarkCascade,
      /**
       * Clear all formatting (nodes and marks)
       * @category Command
       * @example
       * editor.commands.clearFormat()
       * @note Removes all marks and resets nodes to default paragraph
       */
      clearFormat:
        () =>
        ({ chain }) => {
          return chain().clearNodes().unsetAllMarks().run();
        },
      /**
       * Clear only mark formatting
       * @category Command
       * @example
       * editor.commands.clearMarksFormat()
       * @note Removes bold, italic, underline, colors, etc. but preserves block structure
       */
      clearMarksFormat:
        () =>
        ({ chain }) => {
          return chain().unsetAllMarks().run();
        },
      /**
       * Clear only node formatting
       * @category Command
       * @example
       * editor.commands.clearNodesFormat()
       * @note Converts headings, lists, etc. to paragraphs but preserves text marks
       */
      clearNodesFormat:
        () =>
        ({ chain }) => {
          return chain().clearNodes().run();
        },
      /**
       * Copy format from selection or apply copied format
       * @category Command
       * @example
       * editor.commands.copyFormat()
       * @note Works like format painter - first click copies, second click applies
       */
      copyFormat:
        () =>
        ({ chain }) => {
          if (!this.storage.storedStyle) {
            const marks = getMarksFromSelection(this.editor.state);
            this.storage.storedStyle = marks;
            return true;
          }
          if (!this.storage.storedStyle.length) {
            this.storage.storedStyle = null;
            return chain().clearFormat().run();
          }
          const storedMarks = this.storage.storedStyle;
          const processedMarks = [];
          storedMarks.forEach((mark) => {
            const { type, attrs } = mark;
            const { name } = type;
            if (name === 'textStyle') {
              Object.keys(attrs).forEach((key2) => {
                if (!attrs[key2]) return;
                const attributes = {};
                attributes[key2] = attrs[key2];
                processedMarks.push({ name: key2, attrs: attributes });
              });
            } else {
              processedMarks.push({ name, attrs });
            }
          });
          const marksToCommands = {
            bold: ['setBold', 'unsetBold'],
            italic: ['setItalic', 'unsetItalic'],
            underline: ['setUnderline', 'unsetUnderline'],
            color: ['setColor', 'setColor', null],
            fontSize: ['setFontSize', 'unsetFontSize'],
            fontFamily: ['setFontFamily', 'unsetFontFamily'],
          };
          let result = chain();
          Object.keys(marksToCommands).forEach((key2) => {
            const [setCommand, unsetCommand, defaultParam] = marksToCommands[key2];
            const markToApply = processedMarks.find((mark) => mark.name === key2);
            const hasEmptyAttrs = markToApply?.attrs && markToApply?.attrs[key2];
            let cmd = {};
            if (!markToApply && !hasEmptyAttrs) cmd = { command: unsetCommand, argument: defaultParam };
            else cmd = { command: setCommand, argument: markToApply.attrs[key2] || defaultParam };
            result = result[cmd.command](cmd.argument);
          });
          this.storage.storedStyle = null;
          return result;
        },
    };
  },
  addShortcuts() {
    return {
      'Mod-Alt-c': () => this.editor.commands.clearFormat(),
    };
  },
});
const DropCursor = Extension.create({
  name: 'dropCursor',
  addOptions() {
    return {
      color: 'currentColor',
      width: 2,
      class: void 0,
    };
  },
  addPmPlugins() {
    return [dropCursor(this.options)];
  },
});
const Gapcursor = Extension.create({
  name: 'gapCursor',
  addOptions() {
    return {};
  },
  addPmPlugins() {
    return [gapCursor()];
  },
  /**
   * Extend node schema to allow gap cursor positioning
   * @returns {Object} Schema extension with allowGapCursor property
   */
  extendNodeSchema(extension) {
    return {
      /**
       * Whether to allow gap cursor before/after this node
       * Set to false on nodes where gap cursor shouldn't appear
       * @type {boolean|null}
       */
      allowGapCursor:
        callOrGet(
          getExtensionConfigField(extension, 'allowGapCursor', {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
          }),
        ) ?? null,
    };
  },
});
const CollaborationCursor = Extension.create({
  name: 'collaborationCursor',
  priority: 999,
  addOptions() {
    return {
      provider: null,
      user: {
        name: null,
        color: null,
      },
    };
  },
  addStorage() {
    return {
      users: [],
    };
  },
  addPmPlugins() {
    const { collaborationProvider: provider = null } = this.editor.options;
    if (!provider) return [];
    return [yCursorPlugin(provider.awareness, { cursorBuilder: customCursors })];
  },
});
const customCursors = (user) => {
  const cursor = document.createElement('span');
  cursor.classList.add('ProseMirror-yjs-cursor');
  cursor.setAttribute('style', `border-color: ${user.color}`);
  const userDiv = document.createElement('div');
  userDiv.setAttribute('style', `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name || user.email), null);
  cursor.insertBefore(userDiv, null);
  return cursor;
};
const AiMarkName = 'aiMark';
const AiAnimationMarkName = 'aiAnimationMark';
const AiLoaderNodeName = 'aiLoaderNode';
const AiMark = Mark.create({
  name: AiMarkName,
  group: 'ai',
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: { class: 'sd-ai-highlight' },
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: AiMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
});
const AiAnimationMark = Mark.create({
  name: AiAnimationMarkName,
  group: 'ai',
  inclusive: false,
  spanning: false,
  excludes: AiAnimationMarkName,
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false,
      },
      class: {
        default: null,
        rendered: true,
      },
      dataMarkId: {
        default: null,
        rendered: true,
      },
    };
  },
  parseDOM() {
    return [{ tag: AiAnimationMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiAnimationMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
});
const dotsLoader =
  "data:image/svg+xml,%3csvg%20fill='hsla(278,%2077.40%25,%2020.80%25,%200.65)'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='4'%20cy='12'%20r='0'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_lo66'%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_z0Or'%20begin='spinner_lo66.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='4'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_JsnR'%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_Aguh'%20begin='spinner_JsnR.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='12'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_hSjk'%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_UHR2'%20begin='spinner_hSjk.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='20'%20cy='12'%20r='3'%3e%3canimate%20id='spinner_4v5M'%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_OLMs'%20begin='spinner_4v5M.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3c/circle%3e%3c/svg%3e";
const AiLoaderNode = Node$1.create({
  name: AiLoaderNodeName,
  group: 'inline',
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-ai-loader',
        contentEditable: 'false',
        'aria-label': 'AI loader node',
      },
    };
  },
  parseDOM() {
    return [{ tag: 'span.sd-ai-loader' }];
  },
  renderDOM({ htmlAttributes }) {
    const span = document.createElement('span');
    Object.entries(Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)).forEach(([k2, v]) =>
      span.setAttribute(k2, v),
    );
    const img = document.createElement('img');
    img.src = dotsLoader;
    img.alt = 'loading...';
    img.width = 100;
    img.height = 50;
    span.appendChild(img);
    return span;
  },
});
const AiPluginKey = new PluginKey('ai');
const AiPlugin = Extension.create({
  name: 'ai',
  addCommands() {
    return {
      insertAiMark:
        () =>
        ({ tr, dispatch }) => {
          const { selection } = tr;
          const { $from, $to } = selection;
          if ($from.pos === $to.pos) return false;
          tr.addMark(
            $from.pos,
            $to.pos,
            this.editor.schema.marks[AiMarkName].create({
              id: 'ai-highlight',
            }),
          );
          if (dispatch) dispatch(tr);
          return true;
        },
      /**
       * Remove selection before ai pulse styles
       */
      removeSelectionAfterAiPulse:
        () =>
        ({ tr, dispatch, state }) => {
          const { selection } = tr;
          const { $to } = selection;
          tr.setSelection(state.selection.constructor.create(tr.doc, $to.pos, $to.pos));
          if (dispatch) dispatch(tr);
          return true;
        },
      /**
       * Update the AI highlights with custom styling
       * @remarks This is to avoid manipulating the DOM directly - use Prosemirror state. Avoids re-rendering the entire document
       * @param {String} className - The CSS class to add to the AI highlights
       * @returns {Boolean} - True if the highlight style was updated
       */
      updateAiHighlightStyle:
        (className) =>
        ({ tr, dispatch }) => {
          tr.setMeta(AiPluginKey, { type: 'updateStyle', className });
          if (dispatch) dispatch(tr);
          return true;
        },
      /**
       * Clear any custom styling from AI highlights
       * @returns {Boolean} - True if the highlight style was cleared
       */
      clearAiHighlightStyle:
        () =>
        ({ tr, dispatch }) => {
          tr.setMeta(AiPluginKey, { type: 'updateStyle', className: null });
          if (dispatch) dispatch(tr);
          return true;
        },
      /**
       * Remove all AI marks from the document
       * @param {String} markName - The name of the mark to remove - defaults to AiMarkName
       * Can also be used to remove the ai animation mark after streams are complete
       * @returns {Boolean} - True if the mark was removed, false otherwise
       */
      removeAiMark:
        (markName = AiMarkName) =>
        ({ tr, dispatch, state }) => {
          const { doc } = state;
          let markFound = false;
          doc.descendants((node, pos) => {
            const { marks = [] } = node;
            const aiMark = marks.find((mark) => mark.type.name === markName);
            if (aiMark) {
              markFound = true;
              tr.removeMark(pos, pos + node.nodeSize, state.schema.marks[markName]);
            }
          });
          if (markFound) {
            if (dispatch) dispatch(tr);
            return true;
          }
          return false;
        },
      /**
       * Remove all AI nodes of a specific type from the document
       * @param {String} nodeName - The name of the node to remove
       * @returns {Boolean} - True if any nodes were removed, false otherwise
       */
      removeAiNode:
        (nodeName = AiLoaderNodeName) =>
        ({ tr, dispatch, state }) => {
          const { doc } = state;
          const positions = [];
          doc.descendants((node, pos) => {
            if (node.type.name === nodeName) {
              positions.push(pos);
            }
          });
          if (positions.length === 0) {
            return false;
          }
          positions.sort((a, b) => b - a);
          positions.forEach((pos) => {
            const node = doc.nodeAt(pos);
            if (node) {
              tr.delete(pos, pos + node.nodeSize);
            }
          });
          if (dispatch) dispatch(tr);
          return true;
        },
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const aiPlugin = new Plugin({
      key: AiPluginKey,
      state: {
        init() {
          return {
            decorations: DecorationSet.empty,
            highlightColor: '#6366f1',
            // Indigo color, matches AiLayer
            customClass: null,
            // Pulse animation class spot (later)
          };
        },
        apply(tr, oldState, _, newEditorState) {
          const meta = tr.getMeta(AiPluginKey);
          let customClass = oldState.customClass;
          if (meta && meta.type === 'updateStyle') {
            customClass = meta.className;
          }
          if (tr.docChanged && customClass === 'sd-ai-highlight-pulse') {
            let hasTextChanges = false;
            tr.steps.forEach((step) => {
              if (step.slice && step.slice.content.size > 0) {
                hasTextChanges = true;
              }
            });
            if (hasTextChanges) {
              customClass = null;
            }
          }
          if (!tr.docChanged && !meta) return oldState;
          const { decorations } =
            processAiHighlights(editor, newEditorState.doc, oldState.highlightColor, customClass) || {};
          const decorationSet = DecorationSet.create(newEditorState.doc, decorations);
          return {
            ...oldState,
            decorations: decorationSet,
            customClass,
          };
        },
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        },
      },
    });
    return [aiPlugin];
  },
});
const processAiHighlights = (editor, doc, highlightColor, customClass = null) => {
  const decorations = [];
  doc.descendants((node, pos) => {
    const { marks = [] } = node;
    const aiMark = marks.find((mark) => mark.type.name === AiMarkName);
    if (aiMark) {
      const attrs = {
        style: `background-color: ${highlightColor}33; border-radius: 4px; transition: background-color 250ms ease;`,
        // 33 is 20% opacity in hex
        class: 'sd-ai-highlight-element',
      };
      if (customClass) {
        attrs.class += ` ${customClass}`;
      }
      const deco = Decoration.inline(pos, pos + node.nodeSize, attrs);
      decorations.push(deco);
    }
  });
  return { decorations };
};
function getCursorPositionRelativeToContainer(view, eventLocation) {
  const { state, dom } = view;
  const { selection } = state;
  const containerRect = dom.getBoundingClientRect();
  let x, y;
  if (typeof eventLocation.clientX === 'number' && typeof eventLocation.clientY === 'number') {
    x = eventLocation.clientX - containerRect.left;
    y = eventLocation.clientY - containerRect.top;
  } else {
    const cursorCoords = view.coordsAtPos(selection.from);
    x = cursorCoords.left - containerRect.left;
    y = cursorCoords.top - containerRect.top;
  }
  return { left: x, top: y };
}
const SlashMenuPluginKey = new PluginKey('slashMenu');
const SlashMenu = Extension.create({
  name: 'slashMenu',
  addOptions() {
    return {};
  },
  addPmPlugins() {
    if (this.editor.options?.disableContextMenu) {
      return [];
    }
    const editor = this.editor;
    let slashCooldown = false;
    let slashCooldownTimeout = null;
    const slashMenuPlugin = new Plugin({
      key: SlashMenuPluginKey,
      state: {
        init() {
          return {
            open: false,
            selected: null,
            anchorPos: null,
            menuPosition: null,
          };
        },
        apply(tr, value) {
          const meta = tr.getMeta(SlashMenuPluginKey);
          if (!meta) return value;
          switch (meta.type) {
            case 'open': {
              const pos = getCursorPositionRelativeToContainer(editor.view, meta);
              const menuPosition = {
                left: `${pos.left + 100}px`,
                top: `${pos.top + 28}px`,
              };
              const newState = {
                ...value,
                open: true,
                anchorPos: meta.pos,
                menuPosition,
              };
              editor.emit('slashMenu:open', { menuPosition });
              return newState;
            }
            case 'select': {
              return { ...value, selected: meta.id };
            }
            case 'close': {
              editor.emit('slashMenu:close');
              return { ...value, open: false, anchorPos: null };
            }
            default:
              return value;
          }
        },
      },
      view(editorView) {
        const updatePosition2 = () => {
          const state = SlashMenuPluginKey.getState(editorView.state);
          if (state.open) {
            editorView.dispatch(
              editorView.state.tr.setMeta(SlashMenuPluginKey, {
                type: 'updatePosition',
              }),
            );
          }
        };
        window.addEventListener('scroll', updatePosition2, true);
        window.addEventListener('resize', updatePosition2);
        return {
          destroy() {
            window.removeEventListener('scroll', updatePosition2, true);
            window.removeEventListener('resize', updatePosition2);
            if (slashCooldownTimeout) {
              clearTimeout(slashCooldownTimeout);
              slashCooldownTimeout = null;
            }
          },
        };
      },
      props: {
        handleKeyDown(view, event) {
          const pluginState = this.getState(view.state);
          if (event.key === '/' && slashCooldown) {
            return false;
          }
          if (event.key === '/' && !pluginState.open) {
            const { $cursor } = view.state.selection;
            if (!$cursor) return false;
            const isParagraph = $cursor.parent.type.name === 'paragraph';
            if (!isParagraph) return false;
            const textBefore = $cursor.parent.textContent.slice(0, $cursor.parentOffset);
            const isEmptyOrAfterSpace = !textBefore || textBefore.endsWith(' ');
            if (!isEmptyOrAfterSpace) return false;
            event.preventDefault();
            slashCooldown = true;
            if (slashCooldownTimeout) clearTimeout(slashCooldownTimeout);
            slashCooldownTimeout = setTimeout(() => {
              slashCooldown = false;
              slashCooldownTimeout = null;
            }, 5e3);
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: 'open',
                pos: $cursor.pos,
              }),
            );
            return true;
          }
          if (pluginState.open && (event.key === 'Escape' || event.key === 'ArrowLeft')) {
            const { anchorPos } = pluginState;
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: 'close',
              }),
            );
            if (anchorPos !== null) {
              const tr = view.state.tr.setSelection(
                view.state.selection.constructor.near(view.state.doc.resolve(anchorPos)),
              );
              view.dispatch(tr);
              view.focus();
            }
            return true;
          }
          return false;
        },
      },
    });
    return this.editor.options.isHeadless ? [] : [slashMenuPlugin];
  },
});
class StructuredContentViewBase {
  constructor(props) {
    __publicField(this, 'node');
    __publicField(this, 'view');
    __publicField(this, 'getPos');
    __publicField(this, 'decorations');
    __publicField(this, 'innerDecorations');
    __publicField(this, 'editor');
    __publicField(this, 'extension');
    __publicField(this, 'htmlAttributes');
    __publicField(this, 'root');
    __publicField(this, 'isDragging', false);
    this.node = props.node;
    this.view = props.editor.view;
    this.getPos = props.getPos;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.editor = props.editor;
    this.extension = props.extension;
    this.htmlAttributes = props.htmlAttributes;
    this.mount(props);
  }
  mount() {
    return;
  }
  get dom() {
    return this.root;
  }
  get contentDOM() {
    return null;
  }
  update(node, decorations, innerDecorations) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.node = node;
    this.decorations = decorations;
    this.innerDecorations = innerDecorations;
    this.updateHTMLAttributes();
    return true;
  }
  stopEvent(event) {
    if (!this.dom) return false;
    const target = event.target;
    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target);
    if (!isInElement) return false;
    const isDragEvent = event.type.startsWith('drag');
    const isDropEvent = event.type === 'drop';
    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent && !isDragEvent) return true;
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === 'copy';
    const isPasteEvent = event.type === 'paste';
    const isCutEvent = event.type === 'cut';
    const isClickEvent = event.type === 'mousedown';
    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest('[data-drag-handle]');
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener(
          'dragend',
          () => {
            this.isDragging = false;
          },
          { once: true },
        );
        document.addEventListener(
          'drop',
          () => {
            this.isDragging = false;
          },
          { once: true },
        );
        document.addEventListener(
          'mouseup',
          () => {
            this.isDragging = false;
          },
          { once: true },
        );
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || (isClickEvent && isSelectable)) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) return true;
    if (this.node.isLeaf || this.node.isAtom) return true;
    if (mutation.type === 'selection') return false;
    if (this.contentDOM === mutation.target && mutation.type === 'attributes') return true;
    if (this.contentDOM.contains(mutation.target)) return false;
    return true;
  }
  destroy() {
    this.dom.remove();
    this.contentDOM?.remove();
  }
  updateAttributes(attrs) {
    const pos = this.getPos();
    if (typeof pos !== 'number') {
      return;
    }
    return this.view.dispatch(
      this.view.state.tr.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attrs,
      }),
    );
  }
  updateHTMLAttributes() {
    const { extensionService } = this.editor;
    const { attributes } = extensionService;
    const extensionAttrs = attributes.filter((i) => i.type === this.node.type.name);
    this.htmlAttributes = Attribute.getAttributesToRender(this.node, extensionAttrs);
  }
  createDragHandle() {
    const dragHandle = document.createElement('span');
    dragHandle.classList.add('sd-structured-content-draggable');
    dragHandle.draggable = true;
    dragHandle.contentEditable = 'false';
    dragHandle.dataset.dragHandle = '';
    const textElement = document.createElement('span');
    textElement.textContent = this.node.attrs.alias || 'Structured content';
    dragHandle.append(textElement);
    return dragHandle;
  }
  onDragStart(event) {
    const { view } = this.editor;
    const target = event.target;
    const dragHandle =
      target.nodeType === 3
        ? target.parentElement?.closest('[data-drag-handle]')
        : target.closest('[data-drag-handle]');
    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {
      return;
    }
    let x = 0;
    let y = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = event.offsetX ?? event.nativeEvent?.offsetX;
      const offsetY = event.offsetY ?? event.nativeEvent?.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y = handleBox.y - domBox.y + offsetY;
    }
    event.dataTransfer?.setDragImage(this.dom, x, y);
    const pos = this.getPos();
    if (typeof pos !== 'number') {
      return;
    }
    const selection = NodeSelection.create(view.state.doc, pos);
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
}
class StructuredContentInlineView extends StructuredContentViewBase {
  constructor(props) {
    super(props);
  }
  mount() {
    this.buildView();
  }
  get contentDOM() {
    const contentElement = this.dom?.querySelector(`.${structuredContentInnerClass$1}`);
    return contentElement || null;
  }
  createElement() {
    const element = document.createElement('span');
    element.classList.add(structuredContentClass$1);
    element.setAttribute('data-structured-content', '');
    const contentElement = document.createElement('span');
    contentElement.classList.add(structuredContentInnerClass$1);
    element.append(contentElement);
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(element, { ...domAttrs });
    return { element, contentElement };
  }
  buildView() {
    const { element } = this.createElement();
    const dragHandle = this.createDragHandle();
    element.prepend(dragHandle);
    element.addEventListener('dragstart', (e) => this.onDragStart(e));
    this.root = element;
  }
  updateView() {
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(this.dom, { ...domAttrs });
  }
  update(node, decorations, innerDecorations) {
    const result = super.update(node, decorations, innerDecorations);
    if (!result) return false;
    this.updateView();
    return true;
  }
}
const structuredContentClass$1 = 'sd-structured-content';
const structuredContentInnerClass$1 = 'sd-structured-content__content';
const StructuredContent = Node$1.create({
  name: 'structuredContent',
  group: 'inline structuredContent',
  inline: true,
  content: 'inline*',
  isolating: true,
  atom: false,
  // false - has editable content.
  draggable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: structuredContentClass$1,
        'aria-label': 'Structured content node',
      },
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-id'),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return { 'data-id': attrs.id };
        },
      },
      tag: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-tag'),
        renderDOM: (attrs) => {
          if (!attrs.tag) return {};
          return { 'data-tag': attrs.tag };
        },
      },
      alias: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-alias'),
        renderDOM: (attrs) => {
          if (!attrs.alias) return {};
          return { 'data-alias': attrs.alias };
        },
      },
      sdtPr: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-structured-content]' }];
  },
  renderDOM({ htmlAttributes }) {
    return [
      'span',
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
        'data-structured-content': '',
      }),
      0,
    ];
  },
  addNodeView() {
    return (props) => {
      return new StructuredContentInlineView({ ...props });
    };
  },
});
class StructuredContentBlockView extends StructuredContentViewBase {
  constructor(props) {
    super(props);
  }
  mount() {
    this.buildView();
  }
  get contentDOM() {
    const contentElement = this.dom?.querySelector(`.${structuredContentInnerClass}`);
    return contentElement || null;
  }
  createElement() {
    const element = document.createElement('div');
    element.classList.add(structuredContentClass);
    element.setAttribute('data-structured-content-block', '');
    const contentElement = document.createElement('div');
    contentElement.classList.add(structuredContentInnerClass);
    element.append(contentElement);
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(element, { ...domAttrs });
    return { element, contentElement };
  }
  buildView() {
    const { element } = this.createElement();
    const dragHandle = this.createDragHandle();
    element.prepend(dragHandle);
    element.addEventListener('dragstart', (e) => this.onDragStart(e));
    this.root = element;
  }
  updateView() {
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(this.dom, { ...domAttrs });
  }
  update(node, decorations, innerDecorations) {
    const result = super.update(node, decorations, innerDecorations);
    if (!result) return false;
    this.updateView();
    return true;
  }
}
const structuredContentClass = 'sd-structured-content-block';
const structuredContentInnerClass = 'sd-structured-content-block__content';
const StructuredContentBlock = Node$1.create({
  name: 'structuredContentBlock',
  group: 'block structuredContent',
  content: 'block*',
  isolating: true,
  atom: false,
  // false - has editable content.
  draggable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: structuredContentClass,
        'aria-label': 'Structured content block node',
      },
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-id'),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return { 'data-id': attrs.id };
        },
      },
      tag: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-tag'),
        renderDOM: (attrs) => {
          if (!attrs.tag) return {};
          return { 'data-tag': attrs.tag };
        },
      },
      alias: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-alias'),
        renderDOM: (attrs) => {
          if (!attrs.alias) return {};
          return { 'data-alias': attrs.alias };
        },
      },
      sdtPr: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'div[data-structured-content-block]' }];
  },
  renderDOM({ htmlAttributes }) {
    return [
      'div',
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
        'data-structured-content-block': '',
      }),
      0,
    ];
  },
  addNodeView() {
    return (props) => {
      return new StructuredContentBlockView({ ...props });
    };
  },
});
function getStructuredContentTagsById(idOrIds, state) {
  const result = findChildren$4(state.doc, (node) => {
    const isStructuredContent = ['structuredContent', 'structuredContentBlock'].includes(node.type.name);
    if (Array.isArray(idOrIds)) {
      return isStructuredContent && idOrIds.includes(node.attrs.id);
    } else {
      return isStructuredContent && node.attrs.id === idOrIds;
    }
  });
  return result;
}
function createTagObject(tagData) {
  if (!tagData || typeof tagData !== 'object') {
    return null;
  }
  return JSON.stringify(tagData);
}
function parseTagObject(tag) {
  if (typeof tag !== 'string' || !tag.startsWith('{')) {
    return null;
  }
  try {
    const parsed = JSON.parse(tag);
    return parsed && typeof parsed === 'object' ? parsed : null;
  } catch {
    return null;
  }
}
function hasGroup(tag) {
  const parsed = parseTagObject(tag);
  return parsed !== null && typeof parsed.group === 'string';
}
function getGroup(tag) {
  const parsed = parseTagObject(tag);
  return parsed && typeof parsed.group === 'string' ? parsed.group : null;
}
function getStructuredContentByGroup(groupOrGroups, state) {
  const searchGroups = Array.isArray(groupOrGroups) ? groupOrGroups : [groupOrGroups];
  const result = findChildren$4(state.doc, (node) => {
    const isStructuredContent = ['structuredContent', 'structuredContentBlock'].includes(node.type.name);
    if (!isStructuredContent) {
      return false;
    }
    const nodeGroup = getGroup(node.attrs.tag);
    if (!nodeGroup) {
      return false;
    }
    return searchGroups.includes(nodeGroup);
  });
  return result;
}
function getStructuredContentTags(state) {
  const result = findChildren$4(state.doc, (node) => {
    return node.type.name === 'structuredContent' || node.type.name === 'structuredContentBlock';
  });
  return result;
}
function getStructuredContentInlineTags(state) {
  const result = findChildren$4(state.doc, (node) => node.type.name === 'structuredContent');
  return result;
}
function getStructuredContentBlockTags(state) {
  const result = findChildren$4(state.doc, (node) => node.type.name === 'structuredContentBlock');
  return result;
}
function getStructuredContentTablesById(id, state) {
  if (!id || !state) return [];
  const blocks = getStructuredContentTagsById(id, state).filter(
    ({ node }) => node.type.name === 'structuredContentBlock',
  );
  if (!blocks.length) return [];
  const { pos: blockPos, node: blockNode } = blocks[0];
  const tablesInBlock = [];
  blockNode.descendants((child, relPos) => {
    if (child.type.name === 'table') {
      const absPos = blockPos + 1 + relPos;
      tablesInBlock.push({ node: child, pos: absPos });
    }
  });
  return tablesInBlock;
}
const structuredContentHelpers = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      createTagObject,
      getGroup,
      getStructuredContentBlockTags,
      getStructuredContentByGroup,
      getStructuredContentInlineTags,
      getStructuredContentTablesById,
      getStructuredContentTags,
      getStructuredContentTagsById,
      hasGroup,
      parseTagObject,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
const STRUCTURED_CONTENT_NAMES = ['structuredContent', 'structuredContentBlock'];
const StructuredContentCommands = Extension.create({
  name: 'structuredContentCommands',
  addCommands() {
    return {
      /**
       * Inserts a structured content inline at selection.
       * @category Command
       * @param {StructuredContentInlineInsert} options
       * @example
       * // With group for linking multiple fields
       * editor.commands.insertStructuredContentInline({
       *  attrs: {
       *   group: 'customer-info',
       *   alias: 'Customer Name',
       *  },
       *  text: 'John Doe',
       * });
       *
       * // No group
       * editor.commands.insertStructuredContentInline({
       *  attrs: {
       *   id: '123',
       *   alias: 'Customer Name',
       *  },
       *  text: 'John Doe',
       *  // or
       *  json: { type: 'text', text: 'John Doe' },
       * });
       */
      insertStructuredContentInline:
        (options = {}) =>
        ({ editor, dispatch, state, tr }) => {
          const { schema } = editor;
          let { from, to } = state.selection;
          if (dispatch) {
            const selectionText = state.doc.textBetween(from, to);
            let content = null;
            if (selectionText) {
              content = schema.text(selectionText);
            }
            if (options.text) {
              content = schema.text(options.text);
            }
            if (options.json) {
              content = schema.nodeFromJSON(options.json);
            }
            if (!content) {
              content = schema.text(' ');
            }
            let tag = options.attrs?.tag || 'inline_text_sdt';
            if (options.attrs?.group) {
              tag = createTagObject({ group: options.attrs.group });
            }
            const attrs = {
              id: options.attrs?.id || generateRandomSigned32BitIntStrId(),
              tag,
              alias: options.attrs?.alias || 'Structured content',
              ...options.attrs,
            };
            delete attrs.group;
            const node = schema.nodes.structuredContent.create(attrs, content, null);
            const parent = findParentNode((node2) => node2.type.name === 'structuredContent')(state.selection);
            if (parent) {
              const insertPos = parent.pos + parent.node.nodeSize;
              from = to = insertPos;
            }
            tr.replaceWith(from, to, node);
          }
          return true;
        },
      /**
       * Inserts a structured content block at selection.
       * @category Command
       * @param {StructuredContentBlockInsert} options
       * @example
       * // With group for linking multiple fields
       * editor.commands.insertStructuredContentBlock({
       *  attrs: {
       *    group: 'terms-section',
       *    alias: 'Terms & Conditions',
       *  },
       *  html: '<p>Legal content...</p>',
       * });
       *
       * // No group
       * editor.commands.insertStructuredContentBlock({
       *  attrs: {
       *    id: '456',
       *    alias: 'Terms & Conditions',
       *  },
       *  json: { type: 'paragraph', content: [{ type: 'text', text: 'Legal content...' }] }
       * });
       */
      insertStructuredContentBlock:
        (options = {}) =>
        ({ editor, dispatch, state, tr }) => {
          const { schema } = editor;
          let { from, to } = state.selection;
          if (dispatch) {
            const selectionContent = state.selection.content();
            let content = null;
            if (selectionContent.size) {
              content = selectionContent.content;
            }
            if (options.html) {
              const html = htmlHandler(options.html, editor);
              const doc = DOMParser$1.fromSchema(schema).parse(html);
              content = doc.content;
            }
            if (options.json) {
              content = schema.nodeFromJSON(options.json);
            }
            if (!content) {
              content = schema.nodeFromJSON({ type: 'paragraph', content: [] });
            }
            let tag = options.attrs?.tag || 'block_table_sdt';
            if (options.attrs?.group) {
              tag = createTagObject({ group: options.attrs.group });
            }
            const attrs = {
              id: options.attrs?.id || generateRandomSigned32BitIntStrId(),
              tag,
              alias: options.attrs?.alias || 'Structured content',
              ...options.attrs,
            };
            delete attrs.group;
            const node = schema.nodes.structuredContentBlock.create(attrs, content, null);
            const parent = findParentNode((node2) => node2.type.name === 'structuredContentBlock')(state.selection);
            if (parent) {
              const insertPos = parent.pos + parent.node.nodeSize;
              from = to = insertPos;
            }
            tr.replaceRangeWith(from, to, node);
          }
          return true;
        },
      /**
       * Updates a single structured content field by its unique ID.
       * IDs are unique identifiers, so this will update at most one field.
       * If the updated node does not match the schema, it will not be updated.
       * @category Command
       * @param {string} id - Unique identifier of the field
       * @param {StructuredContentUpdate} options
       * @example
       * editor.commands.updateStructuredContentById('123', { text: 'Jane Doe' });
       * editor.commands.updateStructuredContentById('123', {
       *  json: { type: 'text', text: 'Jane Doe' },
       * });
       * editor.commands.updateStructuredContentById('456', {
       *  html: '<p>Updated legal content...</p>'
       * });
       */
      updateStructuredContentById:
        (id, options = {}) =>
        ({ editor, dispatch, state, tr }) => {
          const structuredContentTags = getStructuredContentTagsById(id, state);
          if (!structuredContentTags.length) {
            return true;
          }
          const { schema } = editor;
          if (dispatch) {
            const structuredContent = structuredContentTags[0];
            const { pos, node } = structuredContent;
            const posFrom = pos;
            const posTo = pos + node.nodeSize;
            let content = null;
            if (options.text) {
              content = schema.text(options.text);
            }
            if (options.html) {
              const html = htmlHandler(options.html, editor);
              const doc = DOMParser$1.fromSchema(schema).parse(html);
              content = doc.content;
            }
            if (options.json) {
              content = schema.nodeFromJSON(options.json);
            }
            if (!content) {
              content = node.content;
            }
            const updatedNode = node.type.create({ ...node.attrs, ...options.attrs }, content, node.marks);
            tr.replaceWith(posFrom, posTo, updatedNode);
          }
          return true;
        },
      /**
       * Removes a structured content.
       * @category Command
       * @param {Array<{ node: Node, pos: number }>} structuredContentTags
       * @example
       * const fields = editor.helpers.structuredContentCommands.getStructuredContentTagsById(['123'], editor.state);
       * editor.commands.deleteStructuredContent(fields);
       */
      deleteStructuredContent:
        (structuredContentTags) =>
        ({ dispatch, tr }) => {
          if (!structuredContentTags.length) {
            return true;
          }
          if (dispatch) {
            structuredContentTags.forEach((structuredContent) => {
              const { pos, node } = structuredContent;
              const posFrom = tr.mapping.map(pos);
              const posTo = tr.mapping.map(pos + node.nodeSize);
              const currentNode = tr.doc.nodeAt(posFrom);
              if (currentNode && node.eq(currentNode)) {
                tr.delete(posFrom, posTo);
              }
            });
          }
          return true;
        },
      /**
       * Removes a structured content by ID.
       * @category Command
       * @param {string | string[]} idOrIds
       * @example
       * editor.commands.deleteStructuredContentById('123');
       * editor.commands.deleteStructuredContentById(['123', '456']);
       */
      deleteStructuredContentById:
        (idOrIds) =>
        ({ dispatch, state, tr }) => {
          const structuredContentTags = getStructuredContentTagsById(idOrIds, state);
          if (!structuredContentTags.length) {
            return true;
          }
          if (dispatch) {
            structuredContentTags.forEach((structuredContent) => {
              const { pos, node } = structuredContent;
              const posFrom = tr.mapping.map(pos);
              const posTo = tr.mapping.map(pos + node.nodeSize);
              const currentNode = tr.doc.nodeAt(posFrom);
              if (currentNode && node.eq(currentNode)) {
                tr.delete(posFrom, posTo);
              }
            });
          }
          return true;
        },
      /**
       * Removes a structured content at cursor, preserving its content.
       * @category Command
       * @example
       * editor.commands.deleteStructuredContentAtSelection();
       */
      deleteStructuredContentAtSelection:
        () =>
        ({ dispatch, state, tr }) => {
          const predicate = (node) => STRUCTURED_CONTENT_NAMES.includes(node.type.name);
          const structuredContent = findParentNode(predicate)(state.selection);
          if (!structuredContent) {
            return true;
          }
          if (dispatch) {
            const { node, pos } = structuredContent;
            const posFrom = pos;
            const posTo = posFrom + node.nodeSize;
            const content = node.content;
            tr.replaceWith(posFrom, posTo, content);
          }
          return true;
        },
      /**
       * Updates all structured content fields that share the same group identifier.
       * Groups allow linking multiple fields together for batch operations.
       * @category Command
       * @param {string} group - Group identifier shared by multiple fields
       * @param {StructuredContentUpdate} options
       * @example
       * // Update all fields in the customer-info group
       * editor.commands.updateStructuredContentByGroup('customer-info', { text: 'Jane Doe' });
       *
       * // Update block content in a group
       * editor.commands.updateStructuredContentByGroup('terms-section', {
       *  html: '<p>Updated terms...</p>'
       * });
       */
      updateStructuredContentByGroup:
        (group, options = {}) =>
        ({ editor, dispatch, state, tr }) => {
          const structuredContentTags = getStructuredContentByGroup(group, state);
          if (!structuredContentTags.length) {
            return true;
          }
          const { schema } = editor;
          if (dispatch) {
            structuredContentTags.forEach((structuredContent) => {
              const { pos, node } = structuredContent;
              const posFrom = tr.mapping.map(pos);
              const posTo = tr.mapping.map(pos + node.nodeSize);
              let content = null;
              if (options.text) {
                content = schema.text(options.text);
              }
              if (options.html) {
                const html = htmlHandler(options.html, editor);
                const doc = DOMParser$1.fromSchema(schema).parse(html);
                content = doc.content;
              }
              if (options.json) {
                content = schema.nodeFromJSON(options.json);
              }
              if (!content) {
                content = node.content;
              }
              const updatedNode = node.type.create({ ...node.attrs, ...options.attrs }, content, node.marks);
              const currentNode = tr.doc.nodeAt(posFrom);
              if (currentNode && node.eq(currentNode)) {
                tr.replaceWith(posFrom, posTo, updatedNode);
              }
            });
          }
          return true;
        },
      /**
       * Removes all structured content fields that share the same group identifier.
       * @category Command
       * @param {string | string[]} groupOrGroups - Single group or array of groups
       * @example
       * // Delete all fields in a group
       * editor.commands.deleteStructuredContentByGroup('customer-info');
       *
       * // Delete multiple groups
       * editor.commands.deleteStructuredContentByGroup(['header', 'footer']);
       */
      deleteStructuredContentByGroup:
        (groupOrGroups) =>
        ({ dispatch, state, tr }) => {
          const structuredContentTags = getStructuredContentByGroup(groupOrGroups, state);
          if (!structuredContentTags.length) {
            return true;
          }
          if (dispatch) {
            structuredContentTags.forEach((structuredContent) => {
              const { pos, node } = structuredContent;
              const posFrom = tr.mapping.map(pos);
              const posTo = tr.mapping.map(pos + node.nodeSize);
              const currentNode = tr.doc.nodeAt(posFrom);
              if (currentNode && node.eq(currentNode)) {
                tr.delete(posFrom, posTo);
              }
            });
          }
          return true;
        },
      /**
       * Append multiple rows to the end of a table inside a structured content block.
       * Each inner array represents the cell values for one new row.
       * @category Command
       * @param {StructuredContentTableAppendRowsOptions} options - Append configuration
       * @example
       * editor.commands.appendRowsToStructuredContentTable({
       *   id: 'block-123',
       *   tableIndex: 0,
       *   rows: [['A', 'B'], ['C', 'D']],
       *   copyRowStyle: true,
       * });
       */
      appendRowsToStructuredContentTable:
        ({ id, tableIndex = 0, rows = [], copyRowStyle = false }) =>
        ({ state, commands: commands2, dispatch }) => {
          const normalized = normalizeRowsInput(rows);
          if (!normalized.length) return true;
          const tables = getStructuredContentTablesById(id, state);
          if (!tables.length || tableIndex < 0 || tableIndex >= tables.length) return true;
          const { node: tableNode, pos: tablePos } = tables[tableIndex];
          if (dispatch) {
            return commands2.appendRowsWithContent({ tablePos, tableNode, valueRows: normalized, copyRowStyle });
          }
          return commands2.appendRowsWithContent({
            tablePos,
            tableNode,
            valueRows: normalized,
            copyRowStyle,
            dispatch: false,
          });
        },
    };
  },
  addHelpers() {
    return {
      ...structuredContentHelpers,
    };
  },
});
const normalizeRowsInput = (rowsOrValues) => {
  if (!Array.isArray(rowsOrValues) || !rowsOrValues.length) {
    return [];
  }
  if (Array.isArray(rowsOrValues[0])) {
    return rowsOrValues;
  }
  return [rowsOrValues];
};
class DocumentSectionView {
  constructor(node, getPos, decorations, editor) {
    __privateAdd(this, _DocumentSectionView_instances);
    this.node = node;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this.getPos = getPos;
    __privateMethod(this, _DocumentSectionView_instances, init_fn2).call(this);
  }
}
_DocumentSectionView_instances = new WeakSet();
init_fn2 = function () {
  const { attrs } = this.node;
  const { id, title, description } = attrs;
  this.dom = document.createElement('div');
  this.dom.className = 'sd-document-section-block';
  this.dom.setAttribute('data-id', id);
  this.dom.setAttribute('data-title', title);
  this.dom.setAttribute('data-description', description);
  this.dom.setAttribute('aria-label', 'Document section');
  __privateMethod(this, _DocumentSectionView_instances, addToolTip_fn).call(this);
  this.contentDOM = document.createElement('div');
  this.contentDOM.className = 'sd-document-section-block-content';
  this.contentDOM.setAttribute('contenteditable', 'true');
  this.dom.appendChild(this.contentDOM);
};
addToolTip_fn = function () {
  const { title } = this.node.attrs;
  this.infoDiv = document.createElement('div');
  this.infoDiv.className = 'sd-document-section-block-info';
  const textSpan = document.createElement('span');
  textSpan.textContent = title || 'Document section';
  this.infoDiv.appendChild(textSpan);
  this.infoDiv.setAttribute('contenteditable', 'false');
  this.dom.appendChild(this.infoDiv);
};
const getAllSections = (editor) => {
  if (!editor) return [];
  const type = editor.schema.nodes.documentSection;
  if (!type) return [];
  const sections = [];
  const { state } = editor;
  state.doc.descendants((node, pos) => {
    if (node.type.name === type.name) {
      sections.push({ node, pos });
    }
  });
  return sections;
};
const exportSectionsToHTML = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node }) => {
    const { attrs } = node;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    const html = getHTMLFromNode(node, editor);
    result.push({
      id,
      title,
      description,
      html,
    });
  });
  return result;
};
const getHTMLFromNode = (node, editor) => {
  const tempDocument = document.implementation.createHTMLDocument();
  const container = tempDocument.createElement('div');
  const fragment = DOMSerializer.fromSchema(editor.schema).serializeFragment(node.content);
  container.appendChild(fragment);
  let html = container.innerHTML;
  return html;
};
const exportSectionsToJSON = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node }) => {
    const { attrs } = node;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    result.push({
      id,
      title,
      description,
      content: node.toJSON(),
    });
  });
  return result;
};
const getLinkedSectionEditor = (id, options, editor) => {
  const sections = getAllSections(editor);
  const section = sections.find((s2) => s2.node.attrs.id === id);
  if (!section) return null;
  const child = editor.createChildEditor({
    ...options,
    onUpdate: ({ editor: childEditor, transaction }) => {
      const isFromtLinkedParent = transaction.getMeta('fromLinkedParent');
      if (isFromtLinkedParent) return;
      const updatedContent = childEditor.state.doc.content;
      const sectionNode = getAllSections(editor)?.find((s2) => s2.node.attrs.id === id);
      if (!sectionNode) return;
      const { pos, node } = sectionNode;
      const newNode = node.type.create(node.attrs, updatedContent, node.marks);
      const tr = editor.state.tr.replaceWith(pos, pos + node.nodeSize, newNode);
      tr.setMeta('fromLinkedChild', true);
      editor.view.dispatch(tr);
    },
  });
  editor.on('update', ({ transaction }) => {
    const isFromLinkedChild = transaction.getMeta('fromLinkedChild');
    if (isFromLinkedChild) return;
    const sectionNode = getAllSections(editor)?.find((s2) => s2.node.attrs.id === id);
    if (!sectionNode) return;
    const sectionContent = sectionNode.node.content;
    const json = {
      type: 'doc',
      content: sectionContent.content.map((node) => node.toJSON()),
    };
    const childTr = child.state.tr;
    childTr.setMeta('fromLinkedParent', true);
    childTr.replaceWith(0, child.state.doc.content.size, child.schema.nodeFromJSON(json));
    child.view.dispatch(childTr);
  });
  return child;
};
const SectionHelpers = {
  getAllSections,
  exportSectionsToHTML,
  exportSectionsToJSON,
  getLinkedSectionEditor,
};
const DocumentSection = Node$1.create({
  name: 'documentSection',
  group: 'block',
  content: 'block*',
  atom: true,
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-document-section-block',
        'aria-label': 'Structured content block',
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: 'div.sd-document-section-block',
        priority: 60,
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['div', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      id: {},
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      title: {},
      description: {},
      sectionType: {},
      isLocked: { default: false },
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      return new DocumentSectionView(node, getPos, decorations, editor);
    };
  },
  addCommands() {
    return {
      /**
       * Create a lockable content section
       * @category Command
       * @param {SectionCreate} [options={}] - Section configuration
       * @example
       * editor.commands.createDocumentSection({
       *   id: 1,
       *   title: 'Terms & Conditions',
       *   isLocked: true,
       *   html: '<p>Legal content...</p>'
       * })
       */
      createDocumentSection:
        (options = {}) =>
        ({ tr, state, dispatch, editor }) => {
          const { selection } = state;
          let { from, to } = selection;
          let content = selection.content().content;
          const { html: optionsHTML, json: optionsJSON } = options;
          if (optionsHTML) {
            const html = htmlHandler(optionsHTML, this.editor);
            const doc = DOMParser$1.fromSchema(this.editor.schema).parse(html);
            content = doc.content;
          }
          if (optionsJSON) {
            content = this.editor.schema.nodeFromJSON(optionsJSON);
          }
          if (!content?.content?.length) {
            content = this.editor.schema.nodeFromJSON({ type: 'paragraph', content: [] });
          }
          if (!options.id) {
            const allSections = SectionHelpers.getAllSections(editor);
            options.id = allSections.length + 1;
          }
          if (!options.title) {
            options.title = 'Document section';
          }
          const node = this.type.createAndFill(options, content);
          if (!node) return false;
          const isAlreadyInSdtBlock = findParentNode((node2) => node2.type.name === 'documentSection')(selection);
          if (isAlreadyInSdtBlock && isAlreadyInSdtBlock.node) {
            const insertPos2 = isAlreadyInSdtBlock.pos + isAlreadyInSdtBlock.node.nodeSize;
            from = insertPos2;
            to = insertPos2;
          }
          tr.replaceRangeWith(from, to, node);
          const nodeEnd = from + node.nodeSize;
          let shouldInsertParagraph = true;
          let insertPos = nodeEnd;
          if (nodeEnd >= tr.doc.content.size) {
            insertPos = tr.doc.content.size;
            if (insertPos > 0) {
              const $endPos = tr.doc.resolve(insertPos);
              if ($endPos.nodeBefore && $endPos.nodeBefore.type.name === 'paragraph') {
                shouldInsertParagraph = false;
              }
            }
          }
          if (shouldInsertParagraph) {
            const emptyParagraph = tr.doc.type.schema.nodes.paragraph.create();
            tr.insert(insertPos, emptyParagraph);
          }
          if (dispatch) {
            tr.setMeta('documentSection', { action: 'create' });
            dispatch(tr);
            setTimeout(() => {
              try {
                const currentState = editor.state;
                const docSize = currentState.doc.content.size;
                let targetPos = from + node.nodeSize;
                if (shouldInsertParagraph) {
                  targetPos += 1;
                }
                targetPos = Math.min(targetPos, docSize);
                if (targetPos < docSize && targetPos > 0) {
                  const newSelection = Selection.near(currentState.doc.resolve(targetPos));
                  const newTr = currentState.tr.setSelection(newSelection);
                  editor.view.dispatch(newTr);
                }
              } catch (e) {
                console.warn('Could not set delayed selection:', e);
              }
            }, 0);
          }
          return true;
        },
      /**
       * Remove section wrapper at cursor, preserving its content
       * @category Command
       * @example
       * editor.commands.removeSectionAtSelection()
       * @note Content stays in document, only section wrapper is removed
       */
      removeSectionAtSelection:
        () =>
        ({ tr, dispatch }) => {
          const sdtNode = findParentNode((node2) => node2.type.name === 'documentSection')(tr.selection);
          if (!sdtNode) return false;
          const { node, pos } = sdtNode;
          const nodeStart = pos;
          const nodeEnd = nodeStart + node.nodeSize;
          const contentToPreserve = node.content;
          tr.delete(nodeStart, nodeEnd);
          if (contentToPreserve.size > 0) {
            tr.insert(nodeStart, contentToPreserve);
          }
          const newPos = Math.min(nodeStart, tr.doc.content.size);
          tr.setSelection(Selection.near(tr.doc.resolve(newPos)));
          if (dispatch) {
            tr.setMeta('documentSection', { action: 'delete' });
            dispatch(tr);
          }
          return true;
        },
      /**
       * Delete section and all its content
       * @category Command
       * @param {number} id - Section to delete
       * @example
       * editor.commands.removeSectionById(123)
       */
      removeSectionById:
        (id) =>
        ({ tr, dispatch }) => {
          const sections = SectionHelpers.getAllSections(this.editor);
          const sectionToRemove = sections.find(({ node: node2 }) => node2.attrs.id === id);
          if (!sectionToRemove) return false;
          const { pos, node } = sectionToRemove;
          const nodeStart = pos;
          const nodeEnd = nodeStart + node.nodeSize;
          tr.delete(nodeStart, nodeEnd);
          if (dispatch) {
            tr.setMeta('documentSection', { action: 'delete', id });
            dispatch(tr);
          }
          return true;
        },
      /**
       * Lock section against edits
       * @category Command
       * @param {number} id - Section to lock
       * @example
       * editor.commands.lockSectionById(123)
       */
      lockSectionById:
        (id) =>
        ({ tr, dispatch }) => {
          const sections = SectionHelpers.getAllSections(this.editor);
          const sectionToLock = sections.find(({ node }) => node.attrs.id === id);
          if (!sectionToLock) return false;
          tr.setNodeMarkup(sectionToLock.pos, null, { ...sectionToLock.node.attrs, isLocked: true });
          if (dispatch) {
            tr.setMeta('documentSection', { action: 'lock', id });
            dispatch(tr);
          }
          return true;
        },
      /**
       * Modify section attributes or content
       * @category Command
       * @param {SectionUpdate} options - Changes to apply
       * @example
       * editor.commands.updateSectionById({ id: 123, attrs: { isLocked: false } })
       * editor.commands.updateSectionById({ id: 123, html: '<p>New content</p>' })
       * editor.commands.updateSectionById({
       *   id: 123,
       *   html: '<p>Updated</p>',
       *   attrs: { title: 'New Title' }
       * })
       */
      updateSectionById:
        ({ id, html, json, attrs }) =>
        ({ tr, dispatch, editor }) => {
          const sections = SectionHelpers.getAllSections(editor || this.editor);
          const sectionToUpdate = sections.find(({ node: node2 }) => node2.attrs.id === id);
          if (!sectionToUpdate) return false;
          const { pos, node } = sectionToUpdate;
          let newContent = null;
          if (html) {
            const htmlDoc = htmlHandler(html, editor || this.editor);
            const doc = DOMParser$1.fromSchema((editor || this.editor).schema).parse(htmlDoc);
            newContent = doc.content;
          }
          if (json) {
            newContent = (editor || this.editor).schema.nodeFromJSON(json);
          }
          if (!newContent) {
            newContent = node.content;
          }
          const updatedNode = node.type.create({ ...node.attrs, ...attrs }, newContent, node.marks);
          tr.replaceWith(pos, pos + node.nodeSize, updatedNode);
          if (dispatch) {
            tr.setMeta('documentSection', { action: 'update', id, attrs });
            dispatch(tr);
          }
          return true;
        },
    };
  },
  addHelpers() {
    return {
      ...SectionHelpers,
    };
  },
});
const DocumentPartObject = Node$1.create({
  name: 'documentPartObject',
  group: 'block',
  content: 'block*',
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-document-part-object-block',
        'aria-label': 'Structured document part block',
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: 'div.sd-document-part-object-block',
        priority: 60,
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['div', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      id: {},
      docPartGallery: {},
      docPartUnique: {
        default: true,
      },
    };
  },
});
const Document = Node$1.create({
  name: 'doc',
  topNode: true,
  content: 'block+',
  parseDOM() {
    return [{ tag: 'doc' }];
  },
  renderDOM() {
    return ['doc', 0];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false,
        'aria-label': 'Document node',
      },
    };
  },
  addCommands() {
    return {
      /**
       * Get document statistics
       * @category Command
       * @example
       * // Get word and character count
       * const stats = editor.commands.getDocumentStats()
       * console.log(`${stats.words} words, ${stats.characters} characters`)
       * @note Returns word count, character count, and paragraph count
       */
      getDocumentStats:
        () =>
        ({ editor }) => {
          const text = editor.getText();
          const words = text.split(/\s+/).filter((word) => word.length > 0).length;
          const characters = text.length;
          const paragraphs = editor.state.doc.content.childCount;
          return {
            words,
            characters,
            paragraphs,
          };
        },
      /**
       * Clear entire document
       * @category Command
       * @example
       * editor.commands.clearDocument()
       * @note Replaces all content with an empty paragraph
       */
      clearDocument:
        () =>
        ({ commands: commands2 }) => {
          return commands2.setContent('<p></p>');
        },
    };
  },
});
const Text = Node$1.create({
  name: 'text',
  group: 'inline',
  inline: true,
  addOptions() {
    return {};
  },
});
const splitRun = () => (props) => {
  const { state, view, tr } = props;
  const { $from, empty } = state.selection;
  if (!empty) return false;
  if ($from.parent.type.name !== 'run') return false;
  const handled = splitBlock$1(state, (transaction) => {
    view.dispatch(transaction);
  });
  if (handled) {
    tr.setMeta('preventDispatch', true);
  }
  return handled;
};
const Run = OxmlNode.create({
  name: 'run',
  oXmlName: 'w:r',
  group: 'inline',
  inline: true,
  content: 'inline*',
  selectable: false,
  childToAttributes: ['runProperties'],
  addOptions() {
    return {
      htmlAttributes: {
        'data-run': '1',
      },
    };
  },
  addAttributes() {
    return {
      runProperties: {
        default: null,
        rendered: false,
        keepOnSplit: true,
      },
      rsidR: {
        default: null,
        rendered: false,
        keepOnSplit: true,
      },
      rsidRPr: {
        default: null,
        rendered: false,
        keepOnSplit: true,
      },
      rsidDel: {
        default: null,
        rendered: false,
        keepOnSplit: true,
      },
    };
  },
  addCommands() {
    return {
      splitRun,
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-run]' }];
  },
  renderDOM({ htmlAttributes }) {
    const base = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    return ['span', base, 0];
  },
});
const inputRegex$1 = /^\s*([-+*])\s$/;
const BulletList = Node$1.create({
  name: 'bulletList',
  group: 'block list',
  selectable: false,
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addOptions() {
    return {
      itemTypeName: 'listItem',
      htmlAttributes: {
        'aria-label': 'Bullet list node',
      },
      keepMarks: true,
      keepAttributes: false,
    };
  },
  parseDOM() {
    return [{ tag: 'ul' }];
  },
  renderDOM({ htmlAttributes }) {
    const attributes = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    return ['ul', attributes, 0];
  },
  addAttributes() {
    return {
      'list-style-type': {
        default: 'bullet',
        rendered: false,
      },
      listId: {
        rendered: false,
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      attributes: {
        rendered: false,
        keepOnSplit: true,
      },
    };
  },
  addCommands() {
    return {
      /**
       * Toggle a bullet list at the current selection
       * @category Command
       * @example
       * // Toggle bullet list on selected text
       * editor.commands.toggleBulletList()
       * @note Converts selected paragraphs to list items or removes list formatting
       */
      toggleBulletList: () => (params) => {
        return toggleList(this.type)(params);
      },
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-8': () => {
        return this.editor.commands.toggleBulletList();
      },
    };
  },
  addInputRules() {
    return [
      new InputRule({
        match: inputRegex$1,
        handler: ({ state, range }) => {
          const $pos = state.selection.$from;
          const listItemType = state.schema.nodes.listItem;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            if ($pos.node(depth).type === listItemType) {
              return null;
            }
          }
          const { tr } = state;
          tr.delete(range.from, range.to);
          ListHelpers.createNewList({
            listType: this.type,
            tr,
            editor: this.editor,
          });
        },
      }),
    ];
  },
});
const inputRegex = /^(\d+)\.\s$/;
const OrderedList = Node$1.create({
  name: 'orderedList',
  group: 'block list',
  selectable: false,
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addOptions() {
    return {
      itemTypeName: 'listItem',
      htmlAttributes: {
        'aria-label': 'Ordered list node',
      },
      keepMarks: true,
      keepAttributes: false,
      listStyleTypes: ['decimal', 'lowerAlpha', 'lowerRoman'],
    };
  },
  addAttributes() {
    return {
      order: {
        default: 1,
        parseDOM: (element) => {
          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1;
        },
        renderDOM: (attrs) => {
          return {
            start: attrs.order,
          };
        },
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      syncId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-sync-id'),
        renderDOM: (attrs) => {
          if (!attrs.syncId) return {};
          return {
            'data-sync-id': attrs.syncId,
          };
        },
        // rendered: false,
      },
      listId: {
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute('data-list-id'),
        renderDOM: (attrs) => {
          if (!attrs.listId) return {};
          return {
            'data-list-id': attrs.listId,
          };
        },
      },
      'list-style-type': {
        default: 'decimal',
        rendered: false,
      },
      attributes: {
        rendered: false,
        keepOnSplit: true,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'ol' }];
  },
  renderDOM({ htmlAttributes }) {
    const { start, ...restAttributes } = htmlAttributes;
    return start === 1
      ? ['ol', Attribute.mergeAttributes(this.options.htmlAttributes, restAttributes), 0]
      : ['ol', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Toggle ordered list formatting
       * @category Command
       * @example
       * editor.commands.toggleOrderedList()
       * @note Converts selection to ordered list or back to paragraphs
       */
      toggleOrderedList: () => (params) => {
        return toggleList(this.type)(params);
      },
      /**
       * Restart list node numbering
       * @category Command
       * @param {Array} followingNodes - Nodes to restart
       * @param {number} pos - Starting position
       * @example
       * editor.commands.restartListNodes(nodes, position)
       * @note Resets list numbering for specified nodes
       */
      restartListNodes:
        (followingNodes, pos) =>
        ({ tr }) => {
          let currentNodePos = pos;
          const nodes = followingNodes.map((node) => {
            const resultNode = {
              node,
              pos: currentNodePos,
            };
            currentNodePos += node.nodeSize;
            return resultNode;
          });
          nodes.forEach((item) => {
            const { pos: pos2 } = item;
            const newPos = tr.mapping.map(pos2);
            tr.setNodeMarkup(newPos, void 0, {});
          });
          return true;
        },
      /**
       * Update ordered list style type based on nesting level
       * @category Command
       * @example
       * editor.commands.updateOrderedListStyleType()
       * @note Cycles through decimal -> lowerAlpha -> lowerRoman based on depth
       */
      updateOrderedListStyleType:
        () =>
        ({ dispatch, tr }) => {
          let list = findParentNode((node) => node.type.name === this.name)(tr.selection);
          if (!list) {
            return true;
          }
          if (dispatch) {
            let listLevel = (list.depth - 1) / 2;
            let listStyleTypes = this.options.listStyleTypes;
            let listStyle = listStyleTypes[listLevel % listStyleTypes.length];
            let currentListStyle = list.node.attrs['list-style-type'];
            let nodeAtPos = tr.doc.nodeAt(list.pos);
            if (currentListStyle !== listStyle && nodeAtPos.eq(list.node)) {
              tr.setNodeMarkup(list.pos, void 0, {
                ...list.node.attrs,
                ...{
                  'list-style-type': listStyle,
                },
              });
            }
          }
          return true;
        },
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-7': () => {
        return this.editor.commands.toggleOrderedList();
      },
    };
  },
  addInputRules() {
    return [
      new InputRule({
        match: inputRegex,
        handler: ({ state, range }) => {
          const $pos = state.selection.$from;
          const listItemType = state.schema.nodes.listItem;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            if ($pos.node(depth).type === listItemType) {
              return null;
            }
          }
          const { tr } = state;
          tr.delete(range.from, range.to);
          ListHelpers.createNewList({
            listType: this.type,
            tr,
            editor: this.editor,
          });
        },
      }),
    ];
  },
});
const generateOrderedListIndex = ({ listLevel, lvlText, listNumberingType, customFormat }) => {
  const handler2 = listIndexMap[listNumberingType];
  return handler2 ? handler2(listLevel, lvlText, customFormat) : null;
};
const handleDecimal = (path, lvlText) => generateNumbering(path, lvlText, String);
const handleRoman = (path, lvlText) => generateNumbering(path, lvlText, intToRoman);
const handleLowerRoman = (path, lvlText) => handleRoman(path, lvlText).toLowerCase();
const handleLowerAlpha = (path, lvlText) => handleAlpha(path, lvlText).toLowerCase();
const handleAlpha = (path, lvlText) => generateNumbering(path, lvlText, (p) => intToAlpha(p));
const handleOrdinal = (path, lvlText) => generateNumbering(path, lvlText, ordinalFormatter);
const handleCustom = (path, lvlText, customFormat) => generateFromCustom(path, lvlText, customFormat);
const handleJapaneseCounting = (path, lvlText) => generateNumbering(path, lvlText, intToJapaneseCounting);
const listIndexMap = {
  decimal: handleDecimal,
  lowerRoman: handleLowerRoman,
  upperRoman: handleRoman,
  lowerLetter: handleLowerAlpha,
  upperLetter: handleAlpha,
  ordinal: handleOrdinal,
  custom: handleCustom,
  japaneseCounting: handleJapaneseCounting,
};
const createNumbering = (values, lvlText) => {
  return values.reduce((acc, value, index) => {
    return value > 9 ? acc.replace(/^0/, '').replace(`%${index + 1}`, value) : acc.replace(`%${index + 1}`, value);
  }, lvlText);
};
const generateNumbering = (path, lvlText, formatter) => {
  const formattedValues = path.map(formatter);
  return createNumbering(formattedValues, lvlText);
};
const ordinalFormatter = (level) => {
  const suffixes = ['th', 'st', 'nd', 'rd'];
  const value = level % 100;
  const suffix = suffixes[(value - 20) % 10] || suffixes[value] || suffixes[0];
  const p = level + suffix;
  return p;
};
const generateFromCustom = (path, lvlText, customFormat) => {
  if (customFormat !== '001, 002, 003, ...') return generateNumbering(path, lvlText, String);
  const match = customFormat.match(/(\d+)/);
  if (!match) throw new Error('Invalid format string: no numeric pattern found');
  const sample = match[1];
  const digitCount = sample.length;
  const index = path.pop();
  return String(index).padStart(digitCount, '0');
};
const intToRoman = (num) => {
  const romanNumeralMap = [
    { value: 1e3, numeral: 'M' },
    { value: 900, numeral: 'CM' },
    { value: 500, numeral: 'D' },
    { value: 400, numeral: 'CD' },
    { value: 100, numeral: 'C' },
    { value: 90, numeral: 'XC' },
    { value: 50, numeral: 'L' },
    { value: 40, numeral: 'XL' },
    { value: 10, numeral: 'X' },
    { value: 9, numeral: 'IX' },
    { value: 5, numeral: 'V' },
    { value: 4, numeral: 'IV' },
    { value: 1, numeral: 'I' },
  ];
  let result = '';
  for (const { value, numeral } of romanNumeralMap) {
    while (num >= value) {
      result += numeral;
      num -= value;
    }
  }
  return result;
};
const intToAlpha = (num) => {
  let result = '';
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  while (num > 0) {
    let index = (num - 1) % 26;
    result = alphabet[index] + result;
    num = Math.floor((num - 1) / 26);
  }
  return result;
};
const intToJapaneseCounting = (num) => {
  const digits = ['', '', '', '', '', '', '', '', '', ''];
  const units = ['', '', '', ''];
  if (num === 0) return '';
  if (num < 10) return digits[num];
  let result = '';
  let tempNum = num;
  let unitIndex = 0;
  while (tempNum > 0) {
    const digit = tempNum % 10;
    if (digit !== 0) {
      const digitStr = digit === 1 && unitIndex > 0 ? '' : digits[digit];
      result = digitStr + (unitIndex > 0 ? units[unitIndex] : '') + result;
    } else if (result && tempNum > 0) {
      if (!result.startsWith('') && tempNum % 100 !== 0) {
        result = '' + result;
      }
    }
    tempNum = Math.floor(tempNum / 10);
    unitIndex++;
    if (unitIndex > 3) break;
  }
  if (num >= 10 && num < 20) {
    result = result.replace(/^/, '');
  }
  return result;
};
const isKeyboardInvocation = (event) => {
  return (
    event.type === 'contextmenu' &&
    typeof event.detail === 'number' &&
    event.detail === 0 &&
    (event.button === 0 || event.button === void 0) &&
    event.clientX === 0 &&
    event.clientY === 0
  );
};
const prefersNativeMenu = (event) => {
  if (!event) return false;
  if (event.ctrlKey || event.metaKey) {
    return true;
  }
  return isKeyboardInvocation(event);
};
const shouldAllowNativeContextMenu = (event) => {
  return prefersNativeMenu(event);
};
const DEFAULT_SELECTION_STATE = Object.freeze({
  focused: false,
  preservedSelection: null,
  showVisualSelection: false,
  skipFocusReset: false,
});
const normalizeSelectionState = (state = {}) => ({
  ...DEFAULT_SELECTION_STATE,
  ...state,
});
const CustomSelectionPluginKey = new PluginKey('CustomSelection');
const handleClickOutside = (event, editor) => {
  const editorElem = editor?.options?.element;
  if (!editorElem) return;
  const isInsideEditor = editorElem?.contains(event.target);
  if (!isInsideEditor) {
    editor.setOptions({
      focusTarget: event.target,
    });
  } else {
    editor.setOptions({
      focusTarget: null,
    });
  }
};
function getFocusMeta(tr) {
  return tr.getMeta(CustomSelectionPluginKey);
}
function setFocusMeta(tr, value) {
  return tr.setMeta(CustomSelectionPluginKey, value);
}
function getFocusState(state) {
  return CustomSelectionPluginKey.getState(state);
}
const isToolbarInput = (target) => {
  return !!target?.closest('.button-text-input') || target?.classList?.contains('button-text-input');
};
const isToolbarButton = (target) => {
  return !!target?.closest('.toolbar-button') || target?.classList?.contains('toolbar-button');
};
const CustomSelection = Extension.create({
  name: 'customSelection',
  addPmPlugins() {
    const editor = this.editor;
    const customSelectionPlugin = new Plugin({
      key: CustomSelectionPluginKey,
      state: {
        init: () => ({ ...DEFAULT_SELECTION_STATE }),
        apply: (tr, value) => {
          const meta = getFocusMeta(tr);
          if (meta !== void 0) {
            return { ...value, ...meta };
          }
          return value;
        },
      },
      view: () => {
        const clickHandler = (event) => handleClickOutside(event, editor);
        document?.addEventListener('mousedown', clickHandler);
        return {
          destroy: () => {
            document?.removeEventListener('mousedown', clickHandler);
          },
        };
      },
      props: {
        handleDOMEvents: {
          contextmenu: (view, event) => {
            if (shouldAllowNativeContextMenu(event)) {
              return false;
            }
            event.preventDefault();
            const { selection } = view.state;
            if (!selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true,
                  skipFocusReset: true,
                }),
              );
            }
            setTimeout(() => {
              view.focus();
            }, 0);
            return false;
          },
          mousedown: (view, event) => {
            if (event.button === 2) {
              if (shouldAllowNativeContextMenu(event)) {
                return false;
              }
              event.preventDefault();
              const { selection: selection2 } = view.state;
              if (!selection2.empty) {
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection2,
                    showVisualSelection: true,
                    skipFocusReset: true,
                  }),
                );
                this.editor.setOptions({
                  lastSelection: selection2,
                  preservedSelection: selection2,
                });
              }
              return false;
            }
            const { selection } = view.state;
            const target = event.target;
            const isElement = target instanceof Element;
            const isToolbarBtn = isElement && isToolbarButton(target);
            const isToolbarInp = isElement && isToolbarInput(target);
            this.editor.setOptions({
              focusTarget: target,
            });
            if (isToolbarInp && !selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true,
                  skipFocusReset: false,
                }),
              );
              this.editor.setOptions({
                lastSelection: selection,
                preservedSelection: selection,
              });
              return false;
            }
            if (isToolbarBtn && !isToolbarInp) {
              if (!selection.empty) {
                this.editor.setOptions({
                  lastSelection: selection,
                });
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection,
                    showVisualSelection: true,
                    skipFocusReset: false,
                  }),
                );
              }
              return false;
            }
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false,
                  skipFocusReset: false,
                }),
              );
              if (!selection.empty && !this.editor.options.element?.contains(target)) {
                this.editor.setOptions({
                  lastSelection: selection,
                });
                const clearSelectionTr = view.state.tr.setSelection(TextSelection.create(view.state.doc, 0));
                view.dispatch(clearSelectionTr);
              }
            }
          },
          focus: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement = target instanceof Element;
            const isToolbarBtn = isElement && isToolbarButton(target);
            const isToolbarInp = isElement && isToolbarInput(target);
            const focusState = getFocusState(view.state);
            if (focusState?.skipFocusReset) {
              view.dispatch(
                setFocusMeta(view.state.tr, normalizeSelectionState({ ...focusState, skipFocusReset: false })),
              );
              return false;
            }
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false,
                  skipFocusReset: false,
                }),
              );
            }
          },
          blur: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement = target instanceof Element;
            const isToolbarBtn = isElement && isToolbarButton(target);
            const isToolbarInp = isElement && isToolbarInput(target);
            const state = getFocusState(view.state);
            if (state?.skipFocusReset) {
              return false;
            }
            if (isToolbarBtn || isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: state.preservedSelection || view.state.selection,
                  showVisualSelection: true,
                  skipFocusReset: false,
                }),
              );
            } else {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false,
                  skipFocusReset: false,
                }),
              );
            }
          },
        },
        decorations: (state) => {
          const { selection, doc } = state;
          const focusState = getFocusState(state);
          const shouldShowSelection =
            focusState.showVisualSelection &&
            (focusState.preservedSelection || (!selection.empty && focusState.focused));
          if (!shouldShowSelection) {
            return null;
          }
          const targetSelection = focusState.preservedSelection || selection;
          if (targetSelection.empty) {
            return null;
          }
          return DecorationSet.create(doc, [
            Decoration.inline(targetSelection.from, targetSelection.to, {
              class: 'sd-custom-selection',
            }),
          ]);
        },
      },
    });
    return [customSelectionPlugin];
  },
  addCommands() {
    return {
      /**
       * Restore the preserved selection
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Restore selection after toolbar interaction
       * editor.commands.restorePreservedSelection()
       * @note Used internally to maintain selection when interacting with toolbar
       */
      restorePreservedSelection:
        () =>
        ({ tr, state }) => {
          const focusState = getFocusState(state);
          if (focusState.preservedSelection) {
            return tr.setSelection(focusState.preservedSelection);
          }
          const lastSelection = this.editor.options.lastSelection;
          if (lastSelection) {
            return tr.setSelection(lastSelection);
          }
          return tr;
        },
    };
  },
});
const getLinkedStyle = (styleId, styles = []) => {
  const linkedStyle = styles.find((style) => style.id === styleId);
  const basedOn = linkedStyle?.definition?.attrs?.basedOn;
  const basedOnStyle = styles.find((style) => style.id === basedOn);
  return { linkedStyle, basedOnStyle };
};
const getSpacingStyle = (spacing) => {
  const { lineSpaceBefore, lineSpaceAfter, line, lineRule } = spacing;
  const lineHeightResult = getLineHeightValueString(line, '', lineRule, true);
  const lineHeightStyles = typeof lineHeightResult === 'object' && lineHeightResult !== null ? lineHeightResult : {};
  return {
    'margin-top': lineSpaceBefore + 'px',
    'margin-bottom': lineSpaceAfter + 'px',
    ...lineHeightStyles,
  };
};
const getSpacingStyleString = (spacing) => {
  const { lineSpaceBefore, lineSpaceAfter, line } = spacing;
  return `
    ${lineSpaceBefore ? `margin-top: ${lineSpaceBefore}px;` : ''}
    ${lineSpaceAfter ? `margin-bottom: ${lineSpaceAfter}px;` : ''}
    ${line ? getLineHeightValueString(line, '') : ''}
  `.trim();
};
const getMarksStyle = (attrs) => {
  let styles = '';
  for (const attr of attrs) {
    switch (attr.type) {
      case 'bold':
        styles += `font-weight: bold; `;
        break;
      case 'italic':
        styles += `font-style: italic; `;
        break;
      case 'underline':
        styles += `text-decoration: underline; `;
        break;
      case 'highlight':
        styles += `background-color: ${attr.attrs.color}; `;
        break;
      case 'textStyle':
        const { fontFamily, fontSize } = attr.attrs;
        styles += `${fontFamily ? `font-family: ${fontFamily};` : ''} ${fontSize ? `font-size: ${fontSize};` : ''}`;
        break;
    }
  }
  return styles.trim();
};
const generateLinkedStyleString = (linkedStyle, basedOnStyle, node, parent, includeSpacing = true) => {
  if (!linkedStyle?.definition?.styles) return '';
  const markValue = {};
  const linkedDefinitionStyles = { ...linkedStyle.definition.styles };
  const basedOnDefinitionStyles = { ...basedOnStyle?.definition?.styles };
  const resultStyles = { ...linkedDefinitionStyles };
  const inheritKeys = [
    'font-size',
    'font-family',
    'text-transform',
    'bold',
    'italic',
    'underline',
    'strike',
    'color',
    'highlight',
  ];
  inheritKeys.forEach((k2) => {
    if (!linkedDefinitionStyles[k2] && basedOnDefinitionStyles[k2]) {
      resultStyles[k2] = basedOnDefinitionStyles[k2];
    }
  });
  Object.entries(resultStyles).forEach(([k2, value]) => {
    const key2 = kebabCase(k2);
    const flattenedMarks = [];
    node?.marks?.forEach((n) => {
      if (n.type.name === 'textStyle') {
        Object.entries(n.attrs).forEach(([styleKey, value2]) => {
          const parsedKey = kebabCase(styleKey);
          if (!value2) return;
          flattenedMarks.push({ key: parsedKey, value: value2 });
        });
        return;
      }
      flattenedMarks.push({ key: n.type.name, value: n.attrs[key2] });
    });
    const underlineNone = node?.marks?.some((m) => m.type?.name === 'underline' && m.attrs?.underlineType === 'none');
    if (underlineNone) {
      markValue['text-decoration'] = 'none';
    }
    const mark = flattenedMarks.find((n) => n.key === key2);
    const hasParentIndent = Object.keys(parent?.attrs?.indent || {});
    const hasParentSpacing = Object.keys(parent?.attrs?.spacing || {});
    const listTypes = ['orderedList', 'listItem'];
    if (!mark) {
      if (key2 === 'spacing' && includeSpacing && !hasParentSpacing) {
        const space = getSpacingStyle(value);
        Object.entries(space).forEach(([k3, v]) => {
          markValue[k3] = v;
        });
      } else if (key2 === 'indent' && includeSpacing && !hasParentIndent) {
        const { leftIndent, rightIndent, firstLine } = value;
        if (leftIndent) markValue['margin-left'] = leftIndent + 'px';
        if (rightIndent) markValue['margin-right'] = rightIndent + 'px';
        if (firstLine) markValue['text-indent'] = firstLine + 'px';
      } else if (key2 === 'bold' && node) {
        const boldValue = typeof value === 'object' && value !== null ? value.value : value;
        const hasInlineBoldOff = node.marks?.some((m) => m.type?.name === 'bold' && m.attrs?.value === '0');
        const hasInlineBoldOn = node.marks?.some((m) => m.type?.name === 'bold' && m.attrs?.value !== '0');
        if (
          !listTypes.includes(node.type.name) &&
          !hasInlineBoldOff &&
          !hasInlineBoldOn &&
          boldValue !== '0' &&
          boldValue !== false
        ) {
          markValue['font-weight'] = 'bold';
        }
      } else if (key2 === 'italic' && node) {
        const italicValue = typeof value === 'object' && value !== null ? value.value : value;
        const hasInlineItalicOff = node.marks?.some((m) => m.type?.name === 'italic' && m.attrs?.value === '0');
        const hasInlineItalicOn = node.marks?.some((m) => m.type?.name === 'italic' && m.attrs?.value !== '0');
        if (
          !listTypes.includes(node.type.name) &&
          !hasInlineItalicOff &&
          !hasInlineItalicOn &&
          italicValue !== '0' &&
          italicValue !== false
        ) {
          markValue['font-style'] = 'italic';
        }
      } else if (key2 === 'strike' && node) {
        const strikeValue = typeof value === 'object' && value !== null ? value.value : value;
        const hasInlineStrikeOff = node.marks?.some((m) => m.type?.name === 'strike' && m.attrs?.value === '0');
        const hasInlineStrikeOn = node.marks?.some(
          (m) => m.type?.name === 'strike' && (m.attrs?.value === void 0 || m.attrs?.value !== '0'),
        );
        if (
          !listTypes.includes(node.type.name) &&
          !hasInlineStrikeOff &&
          !hasInlineStrikeOn &&
          strikeValue !== '0' &&
          strikeValue !== false
        ) {
          markValue['text-decoration'] = 'line-through';
        }
      } else if (key2 === 'text-transform' && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key2] = value;
        }
      } else if (key2 === 'font-size' && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key2] = value;
        }
      } else if (key2 === 'font-family' && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key2] = value;
        }
      } else if (key2 === 'color' && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key2] = value;
        }
      } else if (key2 === 'highlight' && node) {
        const hasInlineHighlight = node.marks?.some((m) => m.type?.name === 'highlight');
        if (!listTypes.includes(node.type.name) && !hasInlineHighlight) {
          const color = typeof value === 'string' ? value : value?.color;
          if (color) markValue['background-color'] = color;
        }
      } else if (key2 === 'underline' && node) {
        const styleValRaw = value?.value ?? value ?? '';
        const styleVal = styleValRaw.toString().toLowerCase();
        const hasInlineUnderlineOff = node.marks?.some(
          (m) => m.type?.name === 'underline' && m.attrs?.underlineType === 'none',
        );
        const hasInlineUnderlineOn = node.marks?.some(
          (m) => m.type?.name === 'underline' && m.attrs?.underlineType && m.attrs.underlineType !== 'none',
        );
        if (!listTypes.includes(node.type.name) && !hasInlineUnderlineOff && !hasInlineUnderlineOn) {
          if (styleVal && styleVal !== 'none' && styleVal !== '0') {
            const colorVal = value && typeof value === 'object' ? value.color || value.underlineColor || null : null;
            const css = getUnderlineCssString({ type: styleVal, color: colorVal });
            css.split(';').forEach((decl) => {
              const d2 = decl.trim();
              if (!d2) return;
              const idx = d2.indexOf(':');
              if (idx === -1) return;
              const k3 = d2.slice(0, idx).trim();
              const v = d2.slice(idx + 1).trim();
              markValue[k3] = v;
            });
          }
        }
      } else if (typeof value === 'string') {
        markValue[key2] = value;
      }
    }
  });
  const final = Object.entries(markValue)
    .map(([key2, value]) => `${key2}: ${value}`)
    .join(';');
  return final;
};
const applyLinkedStyleToTransaction = (tr, editor, style) => {
  if (!style) return false;
  let selection = tr.selection;
  const state = editor.state;
  const focusState = CustomSelectionPluginKey.getState(state);
  if (selection.empty && focusState?.preservedSelection) {
    selection = focusState.preservedSelection;
    tr.setSelection(selection);
  } else if (selection.empty && editor.options.lastSelection) {
    selection = editor.options.lastSelection;
    tr.setSelection(selection);
  }
  const { from, to } = selection;
  const getCleanParagraphAttrs = (node) => {
    const cleanAttrs = {};
    const preservedAttrs = ['id', 'class'];
    preservedAttrs.forEach((attr) => {
      if (node.attrs[attr] !== void 0) {
        cleanAttrs[attr] = node.attrs[attr];
      }
    });
    cleanAttrs.styleId = style.id;
    return cleanAttrs;
  };
  const clearFormattingMarks = (startPos, endPos) => {
    tr.doc.nodesBetween(startPos, endPos, (node, pos) => {
      if (node.isText && node.marks.length > 0) {
        const marksToRemove = [
          'textStyle',
          'bold',
          'italic',
          'underline',
          'strike',
          'subscript',
          'superscript',
          'highlight',
        ];
        node.marks.forEach((mark) => {
          if (marksToRemove.includes(mark.type.name)) {
            tr.removeMark(pos, pos + node.nodeSize, mark);
          }
        });
      }
      return true;
    });
  };
  if (from === to) {
    let pos = from;
    let paragraphNode = tr.doc.nodeAt(from);
    if (paragraphNode?.type.name !== 'paragraph') {
      const parentNode = findParentNode((node) => node.type.name === 'paragraph')(selection);
      if (!parentNode) return false;
      pos = parentNode.pos;
      paragraphNode = parentNode.node;
    }
    clearFormattingMarks(pos + 1, pos + paragraphNode.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getCleanParagraphAttrs(paragraphNode));
    return true;
  }
  const paragraphPositions = [];
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (node.type.name === 'paragraph') {
      paragraphPositions.push({ node, pos });
    }
    return true;
  });
  paragraphPositions.forEach(({ node, pos }) => {
    clearFormattingMarks(pos + 1, pos + node.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getCleanParagraphAttrs(node));
  });
  return true;
};
const LinkedStylesPluginKey = new PluginKey('linkedStyles');
const createLinkedStylesPlugin = (editor) => {
  return new Plugin({
    key: LinkedStylesPluginKey,
    state: {
      /**
       * Initialize plugin state with styles and decorations
       * @returns {Object} Initial state with styles and decorations
       * @private
       */
      init() {
        if (!editor.converter || editor.options.mode !== 'docx') return {};
        const styles = editor.converter?.linkedStyles || [];
        return {
          styles,
          decorations: generateDecorations(editor.state, styles),
        };
      },
      /**
       * Update decorations when document changes
       * @param {Object} tr - The transaction
       * @param {Object} prev - Previous plugin state
       * @param {Object} oldEditorState - Old editor state
       * @param {Object} newEditorState - New editor state
       * @returns {Object} Updated state with styles and decorations
       * @private
       */
      apply(tr, prev, oldEditorState, newEditorState) {
        if (!editor.converter || editor.options.mode !== 'docx') return { ...prev };
        let decorations = prev.decorations || DecorationSet.empty;
        if (tr.docChanged) {
          let mightAffectStyles = false;
          const styleRelatedMarks = /* @__PURE__ */ new Set(['textStyle', 'bold', 'italic', 'underline', 'strike']);
          tr.steps.forEach((step) => {
            if (step.slice) {
              step.slice.content.descendants((node) => {
                if (node.attrs?.styleId) {
                  mightAffectStyles = true;
                  return false;
                }
                if (node.marks.length > 0) {
                  const hasStyleMarks = node.marks.some((mark) => styleRelatedMarks.has(mark.type.name));
                  if (hasStyleMarks) {
                    mightAffectStyles = true;
                    return false;
                  }
                }
              });
            }
            if (step.jsonID === 'addMark' || step.jsonID === 'removeMark') {
              if (step.mark && styleRelatedMarks.has(step.mark.type.name)) {
                mightAffectStyles = true;
              }
            }
          });
          if (mightAffectStyles) {
            const styles = LinkedStylesPluginKey.getState(editor.state).styles;
            decorations = generateDecorations(newEditorState, styles);
          } else {
            decorations = decorations.map(tr.mapping, tr.doc);
          }
        }
        return { ...prev, decorations };
      },
    },
    props: {
      /**
       * Provide decorations to the editor view
       * @param {Object} state - Current editor state
       * @returns {Object} The decoration set
       * @private
       */
      decorations(state) {
        return LinkedStylesPluginKey.getState(state)?.decorations;
      },
    },
  });
};
const generateDecorations = (state, styles) => {
  const decorations = [];
  const doc = state?.doc;
  const getParagraphStyleId = (pos) => {
    const $pos = state.doc.resolve(pos);
    for (let d2 = $pos.depth; d2 >= 0; d2--) {
      const n = $pos.node(d2);
      if (n?.type?.name === 'paragraph') return n.attrs?.styleId || null;
    }
    return null;
  };
  doc.descendants((node, pos) => {
    const { name } = node.type;
    if (name !== 'text') return;
    const paragraphStyleId = getParagraphStyleId(pos);
    let runStyleId = null;
    let inlineTextStyleId = null;
    for (const mark of node.marks) {
      if (mark.type.name === 'run') {
        const rp = mark.attrs?.runProperties;
        if (rp && typeof rp === 'object' && !Array.isArray(rp) && rp.styleId) runStyleId = rp.styleId;
        else if (Array.isArray(rp)) {
          const ent = rp.find((e) => e?.xmlName === 'w:rStyle');
          const sid = ent?.attributes?.['w:val'];
          if (sid) runStyleId = sid;
        }
      } else if (mark.type.name === 'textStyle' && mark.attrs?.styleId) {
        inlineTextStyleId = mark.attrs.styleId;
      }
    }
    const buildStyleMap = (sid) => {
      if (!sid) return {};
      const { linkedStyle, basedOnStyle: basedOnStyle2 } = getLinkedStyle(sid, styles);
      if (!linkedStyle) return {};
      const base = { ...(basedOnStyle2?.definition?.styles || {}) };
      return { ...base, ...(linkedStyle.definition?.styles || {}) };
    };
    const pMap = buildStyleMap(paragraphStyleId);
    let tMap;
    if (paragraphStyleId?.startsWith('TOC')) {
      tMap = {};
    } else {
      tMap = buildStyleMap(inlineTextStyleId);
    }
    const rMap = buildStyleMap(runStyleId);
    const finalStyles = { ...pMap, ...tMap, ...rMap };
    if (Object.keys(finalStyles).length === 0) return;
    const mergedLinkedStyle = { definition: { styles: finalStyles, attrs: {} } };
    const basedOnStyle = null;
    const $pos = state.doc.resolve(pos);
    const parent = $pos.parent;
    const styleString = generateLinkedStyleString(mergedLinkedStyle, basedOnStyle, node, parent);
    if (!styleString) return;
    const decoration = Decoration.inline(pos, pos + node.nodeSize, { style: styleString });
    decorations.push(decoration);
  });
  return DecorationSet.create(doc, decorations);
};
const LinkedStyles = Extension.create({
  name: 'linkedStyles',
  priority: 1,
  // We need this plugin to run before the list plugins
  addOptions() {
    return {};
  },
  addPmPlugins() {
    return [createLinkedStylesPlugin(this.editor)];
  },
  addCommands() {
    return {
      /**
       * Apply a linked style to the selected paragraphs
       * @category Command
       * @param {LinkedStyle} style - The style object to apply
       * @example
       * const style = editor.helpers.linkedStyles.getStyleById('Heading1');
       * editor.commands.setLinkedStyle(style);
       * @note Clears existing formatting when applying a style
       * @note Works with custom selection preservation
       */
      setLinkedStyle: (style) => (params) => {
        const { tr } = params;
        return applyLinkedStyleToTransaction(tr, this.editor, style);
      },
      /**
       * Toggle a linked style on the current selection
       * @category Command
       * @param {LinkedStyle} style - The linked style to apply (with id property)
       * @param {string|null} [nodeType=null] - Node type to restrict toggle to (e.g., 'paragraph')
       * @example
       * const style = editor.helpers.linkedStyles.getStyleById('Heading1');
       * editor.commands.toggleLinkedStyle(style)
       * editor.commands.toggleLinkedStyle(style, 'paragraph')
       * @note If selection is empty, returns false
       * @note Removes style if already applied, applies it if not
       */
      toggleLinkedStyle:
        (style, nodeType = null) =>
        (params) => {
          const { tr } = params;
          if (tr.selection.empty) {
            return false;
          }
          let node = tr.doc.nodeAt(tr.selection.$from.pos);
          if (node && nodeType && node.type.name !== nodeType) {
            node = findParentNodeClosestToPos(tr.selection.$from, (n) => {
              return nodeType ? n.type.name === nodeType : true;
            })?.node;
          }
          if (!node) {
            return false;
          }
          const currentStyleId = node.attrs.styleId;
          if (currentStyleId === style.id) {
            return applyLinkedStyleToTransaction(tr, this.editor, { id: null });
          }
          return applyLinkedStyleToTransaction(tr, this.editor, style);
        },
      /**
       * Apply a linked style by its ID
       * @category Command
       * @param {string} styleId - The style ID to apply (e.g., 'Heading1')
       * @example
       * editor.commands.setStyleById('Heading1')
       * editor.commands.setStyleById('Normal')
       * @note Looks up the style from loaded Word styles
       */
      setStyleById: (styleId) => (params) => {
        const { state, tr } = params;
        const pluginState = LinkedStylesPluginKey.getState(state);
        if (!pluginState) return false;
        const style = pluginState.styles?.find((s2) => s2.id === styleId);
        if (!style) return false;
        return applyLinkedStyleToTransaction(tr, this.editor, style);
      },
    };
  },
  addHelpers() {
    return {
      /**
       * Get all available linked styles
       * @category Helper
       * @returns {Array} Array of linked style objects
       * @example
       * const styles = editor.helpers.linkedStyles.getStyles();
       * // Returns all styles from the Word document
       */
      getStyles: () => {
        const styles = LinkedStylesPluginKey.getState(this.editor.state)?.styles || [];
        return styles;
      },
      /**
       * Get a specific style by ID
       * @category Helper
       * @param {string} styleId - The style ID to find
       * @returns {Object} The style object or undefined
       * @example
       * const headingStyle = editor.helpers.linkedStyles.getStyleById('Heading1');
       */
      getStyleById: (styleId) => {
        const styles = this.editor.helpers[this.name].getStyles();
        return styles.find((s2) => s2.id === styleId);
      },
      /**
       * Get the CSS string for a style
       * @category Helper
       * @param {string} styleId - The style ID
       * @returns {string} CSS style string
       * @example
       * const css = editor.helpers.linkedStyles.getLinkedStyleString('Heading1');
       * // Returns: "font-size: 16pt; font-weight: bold; color: #2E74B5"
       * @private
       */
      getLinkedStyleString: (styleId) => {
        const styles = this.editor.helpers.linkedStyles.getStyles();
        const style = styles.find((s2) => s2.id === styleId);
        if (!style) return '';
        return generateLinkedStyleString(style);
      },
    };
  },
});
function getUnderlineCssString({ type = 'single', color = null, thickness = null, approximate = true } = {}) {
  const parts = [];
  const add = (k2, v) => {
    if (!v) return;
    parts.push(`${k2}: ${v}`);
  };
  const lower = String(type || 'single').toLowerCase();
  if (lower === 'none' || lower === '0') {
    add('text-decoration', 'none');
    return parts.join('; ');
  }
  add('text-decoration-line', 'underline');
  const HEAVY = thickness || '0.2em';
  const THICK = thickness || '0.15em';
  switch (lower) {
    case 'single':
      break;
    case 'double':
      add('text-decoration-style', 'double');
      break;
    case 'thick':
      add('text-decoration-thickness', THICK);
      break;
    case 'dotted':
      add('text-decoration-style', 'dotted');
      break;
    case 'dash':
    case 'dashed':
      add('text-decoration-style', 'dashed');
      break;
    case 'dotdash':
    case 'dotdotdash':
    case 'dashlong':
    case 'dashlongheavy':
      if (approximate) {
        add('text-decoration-style', 'dashed');
        if (lower.includes('heavy')) add('text-decoration-thickness', HEAVY);
      }
      break;
    case 'dottedheavy':
      add('text-decoration-style', 'dotted');
      add('text-decoration-thickness', HEAVY);
      break;
    case 'dashedheavy':
      add('text-decoration-style', 'dashed');
      add('text-decoration-thickness', HEAVY);
      break;
    case 'wavy':
      add('text-decoration-style', 'wavy');
      break;
    case 'wavyheavy':
      add('text-decoration-style', 'wavy');
      add('text-decoration-thickness', HEAVY);
      break;
    case 'wavydouble':
      if (approximate) {
        add('text-decoration-style', 'wavy');
        add('text-decoration-thickness', HEAVY);
      }
      break;
  }
  if (color) add('text-decoration-color', color);
  return parts.join('; ');
}
function collectTextStyleMarks(listItem, markType) {
  const textStyleMarks = [];
  const seenMarks = /* @__PURE__ */ new Set();
  const attrs = {};
  if (!markType) {
    return {
      marks: textStyleMarks,
      attrs,
    };
  }
  const collectMarks = (node) => {
    if (!node) return;
    const candidateMarks = Array.isArray(node.marks) ? node.marks : [];
    if (candidateMarks.length && typeof markType.isInSet === 'function' && markType.isInSet(candidateMarks)) {
      candidateMarks.forEach((mark) => {
        if (mark.type === markType && !seenMarks.has(mark)) {
          seenMarks.add(mark);
          textStyleMarks.push(mark);
        }
      });
    }
    if (!node.isText && node.childCount) {
      node.forEach((child) => collectMarks(child));
    }
  };
  listItem.forEach((childNode) => {
    if (childNode.type?.name !== 'paragraph') return;
    if (childNode.attrs?.lineHeight !== void 0) {
      attrs.lineHeight = childNode.attrs.lineHeight;
    }
    collectMarks(childNode);
  });
  return {
    marks: textStyleMarks,
    attrs,
  };
}
function parseSizeFromRunProperties(listRunProperties) {
  const val = listRunProperties?.['w:val'] || listRunProperties?.['w:sz'];
  if (val == null) return null;
  const numeric = Number(val);
  if (Number.isNaN(numeric) || numeric <= 0) return null;
  const sizeInPoints = numeric / 2;
  return `${sizeInPoints}pt`;
}
function parseFontFamilyFromRunProperties(listRunProperties) {
  const ascii = listRunProperties?.['w:ascii'];
  const hAnsi = listRunProperties?.['w:hAnsi'];
  const eastAsia = listRunProperties?.['w:eastAsia'];
  return ascii || hAnsi || eastAsia || null;
}
const computedStylesCache = /* @__PURE__ */ new WeakMap();
function clearComputedStyleCache(domNode) {
  if (domNode) {
    computedStylesCache.delete(domNode);
  }
}
function readNodeViewStyles(view) {
  const fallback = { fontSize: null, fontFamily: null, lineHeight: null };
  if (!view?.dom) return fallback;
  const inline = {
    fontSize: view.dom.style?.fontSize || null,
    fontFamily: view.dom.style?.fontFamily || null,
    lineHeight: view.dom.style?.lineHeight || null,
  };
  if (inline.fontSize && inline.fontFamily && inline.lineHeight) return inline;
  if (computedStylesCache.has(view.dom)) {
    const cached = computedStylesCache.get(view.dom);
    return {
      fontSize: inline.fontSize || cached.fontSize,
      fontFamily: inline.fontFamily || cached.fontFamily,
      lineHeight: inline.lineHeight || cached.lineHeight,
    };
  }
  const globalWindow = typeof window !== 'undefined' ? window : void 0;
  if (globalWindow?.getComputedStyle) {
    const computed2 = globalWindow.getComputedStyle(view.dom);
    const computedStyles = {
      fontSize: computed2.fontSize,
      fontFamily: computed2.fontFamily,
      lineHeight: computed2.lineHeight,
    };
    computedStylesCache.set(view.dom, computedStyles);
    return {
      fontSize: inline.fontSize || computedStyles.fontSize,
      fontFamily: inline.fontFamily || computedStyles.fontFamily,
      lineHeight: inline.lineHeight || computedStyles.lineHeight,
    };
  }
  return inline;
}
function getAdjacentListItemNodeView({ nodeView, pos, direction, activeNodeViews }) {
  if (!activeNodeViews) return null;
  let candidate = null;
  activeNodeViews.forEach((view) => {
    if (view === nodeView) return;
    let viewPos;
    try {
      if (typeof view.getResolvedPos === 'function') {
        viewPos = view.getResolvedPos();
      } else if (typeof view.getPos === 'function') {
        viewPos = view.getPos();
      }
    } catch {
      return;
    }
    if (typeof viewPos !== 'number') return;
    if (viewPos < pos) {
      if (!candidate || viewPos > candidate.pos) candidate = { view, pos: viewPos };
    }
  });
  return candidate?.view ?? null;
}
function findSiblingListItem({ editor, pos, direction }) {
  if (typeof pos !== 'number' || !editor?.view) return null;
  const { state } = editor.view;
  const $pos = state.doc.resolve(pos);
  const parentDepth = $pos.depth - 1;
  if (parentDepth < 0) return null;
  const parent = $pos.node(parentDepth);
  if (!parent) return null;
  const indexInsideParent = $pos.index(parentDepth);
  const siblingIndex = indexInsideParent + direction;
  if (siblingIndex < 0 || siblingIndex >= parent.childCount) return null;
  const sibling = parent.child(siblingIndex);
  return sibling?.type?.name === 'listItem' ? sibling : null;
}
function deriveFontStylesFromNode({ node, textStyleType, defaultFont, defaultSize, listRunProperties }) {
  const { marks: allMarks, attrs } = collectTextStyleMarks(node, textStyleType);
  const styleMarks = textStyleType ? allMarks.filter((m) => m.type === textStyleType) : [];
  const sizeMark = styleMarks.find((m) => m.attrs?.fontSize);
  const familyMark = styleMarks.find((m) => m.attrs?.fontFamily);
  let fontSize = defaultSize;
  if (sizeMark) {
    const [value, unit = 'pt'] = parseSizeUnit(sizeMark.attrs.fontSize);
    if (!Number.isNaN(value)) {
      fontSize = `${value}${unit}`;
    }
  }
  let hasSize = Boolean(sizeMark);
  if (!hasSize && listRunProperties) {
    const sizeFromList = parseSizeFromRunProperties(listRunProperties);
    if (sizeFromList) {
      fontSize = sizeFromList;
      hasSize = true;
    }
  }
  let fontFamily = familyMark?.attrs?.fontFamily ?? defaultFont;
  let hasFamily = Boolean(familyMark);
  if (!hasFamily && listRunProperties) {
    const fontFromList = parseFontFamilyFromRunProperties(listRunProperties);
    if (fontFromList) {
      fontFamily = fontFromList;
      hasFamily = true;
    }
  }
  let lineHeight = attrs.lineHeight;
  const firstChild = node.firstChild;
  const hasOnlyOnePar = node.childCount === 1 && firstChild?.type?.name === 'paragraph';
  if (hasOnlyOnePar) {
    const par = firstChild;
    const parFirstChild = par?.firstChild;
    if (par?.childCount === 1 && parFirstChild?.type?.name === 'fieldAnnotation') {
      const aFontSize = parFirstChild.attrs?.fontSize;
      const aFontFamily = parFirstChild.attrs?.fontFamily;
      if (!sizeMark && aFontSize) fontSize = aFontSize;
      if (!familyMark && aFontFamily) fontFamily = aFontFamily;
    }
  }
  return {
    fontSize,
    fontFamily,
    lineHeight,
    hasSize,
    hasFamily,
  };
}
function getStylesFromLinkedStyles({ node, pos, editor }) {
  const { state } = editor.view;
  const linkedStyles = LinkedStylesPluginKey.getState(state)?.decorations;
  const decorationsInPlace = linkedStyles?.find(pos, pos + node.nodeSize);
  const predicates = [
    (style2) => style2.includes('font-size') && style2.includes('font-family'),
    (style2) => style2.includes('font-size'),
    (style2) => style2.includes('font-family'),
  ];
  let styleDeco;
  for (const predicateFn of predicates) {
    styleDeco = decorationsInPlace?.find((dec) => {
      const style2 = dec.type?.attrs?.style || '';
      return style2 && predicateFn(style2);
    });
    if (styleDeco) break;
  }
  const style = styleDeco?.type?.attrs?.style;
  const stylesArray = style?.split(';') || [];
  const fontSizeFromStyles = stylesArray
    .find((s2) => s2.includes('font-size'))
    ?.split(':')[1]
    ?.trim();
  const fontFamilyFromStyles = stylesArray
    .find((s2) => s2.includes('font-family'))
    ?.split(':')[1]
    ?.trim();
  return {
    font: fontFamilyFromStyles,
    size: fontSizeFromStyles,
  };
}
function resolveListItemTypography({ node, pos, editor, nodeView, activeNodeViews }) {
  const defaults = getStylesFromLinkedStyles({ node, pos, editor });
  const textStyleType = getMarkType('textStyle', editor.schema);
  const currentStyles = deriveFontStylesFromNode({
    node,
    textStyleType,
    defaultFont: defaults.font,
    defaultSize: defaults.size,
    listRunProperties: node.attrs?.listRunProperties,
  });
  if ((!currentStyles.hasSize || !currentStyles.hasFamily || !currentStyles.lineHeight) && editor?.view) {
    const previousListItem = findSiblingListItem({ editor, pos, direction: -1 });
    if (previousListItem) {
      const previousStyles = deriveFontStylesFromNode({
        node: previousListItem,
        textStyleType,
        defaultFont: defaults.font,
        defaultSize: defaults.size,
        listRunProperties: previousListItem.attrs?.listRunProperties,
      });
      if (!currentStyles.hasSize && previousStyles.fontSize) currentStyles.fontSize = previousStyles.fontSize;
      if (!currentStyles.hasFamily && previousStyles.fontFamily) currentStyles.fontFamily = previousStyles.fontFamily;
      if (!currentStyles.lineHeight && previousStyles.lineHeight) currentStyles.lineHeight = previousStyles.lineHeight;
    }
  }
  if ((!currentStyles.fontSize || !currentStyles.fontFamily || !currentStyles.lineHeight) && nodeView) {
    const previousView = getAdjacentListItemNodeView({
      nodeView,
      pos,
      direction: -1,
      activeNodeViews,
    });
    if (previousView) {
      const {
        fontSize: prevSize,
        fontFamily: prevFamily,
        lineHeight: prevLineHeight,
      } = readNodeViewStyles(previousView);
      if (!currentStyles.fontSize && prevSize) currentStyles.fontSize = prevSize;
      if (!currentStyles.fontFamily && prevFamily) currentStyles.fontFamily = prevFamily;
      if (!currentStyles.lineHeight && prevLineHeight) currentStyles.lineHeight = prevLineHeight;
    }
  }
  return {
    fontSize: currentStyles.fontSize,
    fontFamily: currentStyles.fontFamily,
    lineHeight: currentStyles.lineHeight,
  };
}
const MARKER_PADDING = 6;
const MARKER_OFFSET_RIGHT = 4;
const MIN_MARKER_WIDTH = 20;
const POINT_TO_PIXEL_CONVERSION_FACTOR = 1.33;
const DEFAULT_FONT_FAMILY = 'Arial, sans-serif';
const DEFAULT_FONT_SIZE = '10pt';
const activeListItemNodeViews = /* @__PURE__ */ new Set();
class ListItemNodeView {
  constructor(node, getPos, decorations, editor) {
    __privateAdd(this, _ListItemNodeView_instances);
    __publicField(this, 'handleNumberingClick', () => {});
    this.node = node;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this._rawGetPos = getPos;
    this._pendingIndentRefresh = null;
    this.getPos = () => this.getResolvedPos();
    __privateMethod(this, _ListItemNodeView_instances, init_fn3).call(this);
    activeListItemNodeViews.add(this);
  }
  getResolvedPos() {
    if (typeof this._rawGetPos !== 'function') return null;
    try {
      const resolved = this._rawGetPos();
      return typeof resolved === 'number' ? resolved : null;
    } catch {
      return null;
    }
  }
  invalidateResolvedPos() {}
  refreshIndentStyling({ immediate = false } = {}) {
    const raf = typeof globalThis !== 'undefined' ? globalThis.requestAnimationFrame : void 0;
    const shouldSchedule = !immediate && typeof raf === 'function';
    if (!shouldSchedule) {
      this._pendingIndentRefresh = null;
      __privateMethod(this, _ListItemNodeView_instances, applyIndentStyling_fn).call(this);
      return;
    }
    if (this._pendingIndentRefresh != null) return;
    this._pendingIndentRefresh = raf(() => {
      this._pendingIndentRefresh = null;
      __privateMethod(this, _ListItemNodeView_instances, applyIndentStyling_fn).call(this);
    });
  }
  update(node, decorations) {
    const prevNode = this.node;
    this.node = node;
    this.decorations = decorations;
    this.invalidateResolvedPos();
    const stylingAttrsChanged =
      !prevNode ||
      prevNode.attrs.styleId !== node.attrs.styleId ||
      prevNode.attrs.numId !== node.attrs.numId ||
      prevNode.attrs.level !== node.attrs.level;
    if (stylingAttrsChanged) {
      clearComputedStyleCache(this.dom);
    }
    const { fontSize, fontFamily, lineHeight } = resolveListItemTypography({
      node,
      pos: this.getResolvedPos(),
      editor: this.editor,
      nodeView: this,
      activeNodeViews: activeListItemNodeViews,
    });
    this.dom.style.fontSize = fontSize;
    this.dom.style.fontFamily = fontFamily || 'inherit';
    this.dom.style.lineHeight = lineHeight || '';
    const attrsChanged = stylingAttrsChanged || prevNode?.attrs.indent !== node.attrs.indent;
    if (attrsChanged) {
      this.refreshIndentStyling();
    }
  }
  destroy() {
    activeListItemNodeViews.delete(this);
    this.numberingDOM.removeEventListener('click', this.handleNumberingClick);
    clearComputedStyleCache(this.dom);
    const caf = typeof globalThis !== 'undefined' ? globalThis.cancelAnimationFrame : void 0;
    if (this._pendingIndentRefresh != null && typeof caf === 'function') {
      caf(this._pendingIndentRefresh);
    }
    this._pendingIndentRefresh = null;
  }
}
_ListItemNodeView_instances = new WeakSet();
init_fn3 = function () {
  const { attrs } = this.node;
  const { listLevel, listNumberingType, lvlText, numId, level, customFormat } = attrs;
  let orderMarker = '';
  if (listLevel) {
    if (listNumberingType !== 'bullet') {
      orderMarker = generateOrderedListIndex({
        listLevel,
        lvlText,
        listNumberingType,
        customFormat,
      });
    } else {
      orderMarker = docxNumberingHelpers.normalizeLvlTextChar(lvlText);
    }
  }
  const pos = this.getResolvedPos();
  const { fontSize, fontFamily, lineHeight } = resolveListItemTypography({
    node: this.node,
    pos,
    editor: this.editor,
    nodeView: this,
    activeNodeViews: activeListItemNodeViews,
  });
  this.dom = document.createElement('li');
  this.dom.className = 'sd-editor-list-item-node-view';
  this.dom.style.fontSize = fontSize;
  this.dom.style.fontFamily = fontFamily ? fontFamily : 'inherit';
  this.dom.style.lineHeight = lineHeight || '';
  this.dom.setAttribute('data-marker-type', orderMarker);
  this.dom.setAttribute('data-num-id', numId);
  this.dom.setAttribute('data-list-level', JSON.stringify(listLevel));
  this.dom.setAttribute('data-list-numbering-type', listNumberingType);
  this.dom.setAttribute('data-level', level);
  this.numberingDOM = document.createElement('span');
  this.numberingDOM.className = 'sd-editor-list-item-numbering';
  this.numberingDOM.textContent = orderMarker;
  this.numberingDOM.setAttribute('contenteditable', 'false');
  this.numberingDOM.addEventListener('click', this.handleNumberingClick);
  this.contentDOM = document.createElement('div');
  this.contentDOM.className = 'sd-editor-list-item-content-dom';
  this.dom.appendChild(this.numberingDOM);
  this.dom.appendChild(this.contentDOM);
  this.refreshIndentStyling({ immediate: true });
};
applyIndentStyling_fn = function () {
  const { attrs } = this.node;
  const { styleId, numId, level, indent: inlineIndent } = attrs;
  const defs = getListItemStyleDefinitions({ styleId, node: this.node, numId, level, editor: this.editor });
  const visibleIndent = getVisibleIndent(defs.stylePpr, defs.numDefPpr, inlineIndent);
  const lvlJc = defs.numLvlJs?.attributes?.['w:val'] || 'left';
  const contentLeft = visibleIndent.left || 0;
  const hanging = visibleIndent.hanging || 0;
  const handlers = {
    right: () => {
      const calculatedWidth = calculateMarkerWidth(this.dom, this.numberingDOM, this.editor);
      const minMarkerWidth = Math.max(calculatedWidth, MIN_MARKER_WIDTH);
      const effectiveHanging = Math.max(hanging, minMarkerWidth);
      const markerLeft = contentLeft - effectiveHanging - MARKER_OFFSET_RIGHT;
      this.contentDOM.style.marginLeft = `${contentLeft}px`;
      this.numberingDOM.style.left = `${markerLeft}px`;
      this.numberingDOM.style.width = `${effectiveHanging}px`;
      this.numberingDOM.style.textAlign = 'right';
    },
    left: () => {
      const calculatedWidth = calculateMarkerWidth(this.dom, this.numberingDOM, this.editor);
      const minMarkerWidth = Math.max(calculatedWidth, MIN_MARKER_WIDTH);
      let markerLeft = contentLeft - hanging;
      if (markerLeft === contentLeft) {
        markerLeft -= minMarkerWidth;
      } else if (minMarkerWidth > hanging) {
        const diff = minMarkerWidth - hanging;
        markerLeft -= diff;
      }
      this.contentDOM.style.marginLeft = `${contentLeft}px`;
      this.numberingDOM.style.left = `${markerLeft}px`;
      this.numberingDOM.style.width = '';
      this.numberingDOM.style.textAlign = '';
    },
  };
  const handleStyles = handlers[lvlJc] ?? handlers.left;
  handleStyles();
};
function refreshAllListItemNodeViews() {
  activeListItemNodeViews.forEach((nodeView) => {
    try {
      nodeView.refreshIndentStyling({ immediate: true });
    } catch (error) {
      console.error('Error refreshing list item node view:', error);
      activeListItemNodeViews.delete(nodeView);
    }
  });
}
const getVisibleIndent = (stylePpr, numDefPpr, inlineIndent) => {
  const styleIndentTag = stylePpr?.elements?.find((el) => el.name === 'w:ind') || {};
  const styleIndent = parseIndentElement(styleIndentTag);
  const numDefIndentTag = numDefPpr?.elements?.find((el) => el.name === 'w:ind') || {};
  const numDefIndent = parseIndentElement(numDefIndentTag);
  const indent = combineIndents(styleIndent, numDefIndent);
  const result = combineIndents(indent, inlineIndent);
  return result;
};
function calculateMarkerWidth(dom, numberingDOM, editor, { withPadding = true } = {}) {
  const markerText = numberingDOM.textContent || '';
  const fontSize = dom.style.fontSize || DEFAULT_FONT_SIZE;
  const fontValue = dom.style.fontFamily;
  const fontFamily = fontValue && fontValue !== 'inherit' ? fontValue : DEFAULT_FONT_FAMILY;
  if (!markerText.trim()) return 0;
  try {
    if (editor?.options?.isHeadless) return 0;
    if (typeof globalThis.CanvasRenderingContext2D === 'undefined') return 0;
    const canvas = document.createElement('canvas');
    if (typeof canvas.getContext !== 'function') return 0;
    const context = canvas.getContext('2d');
    if (!context) return 0;
    const fontSizePx = fontSize.includes('pt')
      ? Number.parseFloat(fontSize) * POINT_TO_PIXEL_CONVERSION_FACTOR
      : Number.parseFloat(fontSize);
    context.font = `${fontSizePx}px ${fontFamily}`;
    const textWidth = context.measureText(markerText).width;
    const resultWidth = withPadding ? Math.ceil(textWidth + MARKER_PADDING) : Math.ceil(textWidth);
    return resultWidth;
  } catch {
    return 0;
  }
}
const orderedListSyncPluginKey = new PluginKey('orderedListSync');
function orderedListSync(editor) {
  let hasInitialized = false;
  const docx = editor.converter.convertedXml;
  return new Plugin({
    key: orderedListSyncPluginKey,
    appendTransaction(transactions, oldState, newState) {
      if (transactions.every((tr2) => tr2.getMeta('y-sync$'))) return null;
      const updateNodeViews = transactions.some((tr2) => tr2.getMeta('updatedListItemNodeViews'));
      if (updateNodeViews || !hasInitialized) {
        refreshAllListItemNodeViews();
      }
      const isFromPlugin = transactions.some((tr2) => tr2.getMeta('orderedListSync'));
      const docChanged = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
      if (isFromPlugin || !docChanged) {
        return null;
      }
      hasInitialized = true;
      const tr = newState.tr;
      tr.setMeta('orderedListSync', true);
      const listMap = /* @__PURE__ */ new Map();
      const listInitialized = /* @__PURE__ */ new Map();
      const shouldProcess = transactions.some((tr2) => {
        if (tr2.getMeta('updateListSync')) return true;
        return tr2.steps.some((step) => {
          const stepJSON = step.toJSON();
          if (step.slice?.content) {
            let hasListItem = false;
            step.slice.content.descendants((node) => {
              if (node.type.name === 'listItem') {
                hasListItem = true;
                return false;
              }
            });
            if (hasListItem) return true;
          }
          if (stepJSON && stepJSON.slice) {
            const jsonStr = JSON.stringify(stepJSON);
            if (jsonStr.includes('"listItem"')) return true;
          }
          return false;
        });
      });
      if (!shouldProcess) return null;
      newState.doc.descendants((node, pos) => {
        if (node.type.name !== 'listItem') return;
        const { level: attrLvl, numId: attrNumId, styleId } = node.attrs;
        const level = parseInt(attrLvl);
        const numId = parseInt(attrNumId);
        let {
          lvlText,
          customFormat,
          listNumberingType,
          start: numberingDefStart,
        } = ListHelpers.getListDefinitionDetails({ numId, level, editor });
        const start = parseInt(numberingDefStart) || 1;
        if (!listMap.has(numId)) {
          const generatedLevels = {};
          const initialPath = docxNumberingHelpers.generateListPath(level, numId, styleId, generatedLevels, docx);
          listMap.set(numId, initialPath || []);
          listInitialized.set(numId, false);
        }
        let currentListLevels = [...listMap.get(numId)];
        if (!listInitialized.get(numId)) {
          listInitialized.set(numId, true);
          if (typeof start === 'number') {
            while (currentListLevels.length <= level) {
              currentListLevels.push(0);
            }
            currentListLevels[level] = start;
            for (let i = level + 1; i < currentListLevels.length; i++) {
              currentListLevels[i] = 0;
            }
          }
        } else {
          while (currentListLevels.length <= level) {
            currentListLevels.push(0);
          }
          currentListLevels[level] = (currentListLevels[level] || 0) + 1;
          for (let i = level + 1; i < currentListLevels.length; i++) {
            currentListLevels[i] = 0;
          }
        }
        if (currentListLevels.length === 0) {
          currentListLevels = [1];
        }
        listMap.set(numId, currentListLevels);
        const updatedAttrs = {
          ...node.attrs,
          listLevel: [...currentListLevels],
          level,
          lvlText,
          listNumberingType,
          customFormat,
        };
        const keysChanged = Object.keys(updatedAttrs).some((key2) => node.attrs[key2] !== updatedAttrs[key2]);
        if (keysChanged) {
          tr.setNodeMarkup(pos, void 0, updatedAttrs);
        }
      });
      return tr;
    },
  });
}
const ListItem = Node$1.create({
  name: 'listItem',
  content: 'paragraph* block*',
  defining: true,
  priority: 101,
  // to run listItem commands first
  addOptions() {
    return {
      htmlAttributes: {
        'aria-label': 'List item node',
      },
      bulletListTypeName: 'bulletList',
      orderedListTypeName: 'orderedList',
    };
  },
  parseDOM() {
    return [{ tag: 'li' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['li', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addPmPlugins() {
    return this.editor?.converter?.convertedXml ? [orderedListSync(this.editor)] : [];
  },
  /**
   * Important: The listItem node uses a custom node view.
   * Skip node view in headless mode for performance.
   * @returns {import('@core/NodeView.js').NodeView|null}
   */
  addNodeView() {
    if (shouldSkipNodeView(this.editor)) return null;
    return ({ node, editor, getPos, decorations }) => {
      return new ListItemNodeView(node, getPos, decorations, editor);
    };
  },
  addAttributes() {
    return {
      // Virtual attribute.
      markerType: {
        default: null,
        renderDOM: (attrs) => {
          let { listLevel, listNumberingType, lvlText } = attrs;
          let hasListLevel = !!listLevel?.length;
          if (!hasListLevel || !lvlText) {
            return {};
          }
          let orderMarker = generateOrderedListIndex({
            listLevel,
            lvlText,
            listNumberingType,
          });
          if (!orderMarker) return {};
          return {
            'data-marker-type': orderMarker,
          };
        },
      },
      lvlText: {
        default: null,
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute('data-lvl-text'),
        renderDOM: (attrs) => {
          if (!attrs.lvlText) return {};
          return {
            'data-lvl-text': attrs.lvlText,
          };
        },
      },
      listNumberingType: {
        default: null,
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute('data-num-fmt'),
        renderDOM: (attrs) => {
          if (!attrs.listNumberingType) return {};
          return {
            'data-num-fmt': attrs.listNumberingType,
          };
        },
      },
      listLevel: {
        default: null,
        parseDOM: (elem) => {
          let listLevel = elem.getAttribute('data-list-level');
          try {
            listLevel = JSON.parse(listLevel);
          } catch {}
          return listLevel;
        },
        renderDOM: (attrs) => {
          if (!attrs.listLevel) return {};
          return {
            'data-list-level': JSON.stringify(attrs.listLevel),
          };
        },
      },
      // JC = justification. Expect left, right, center
      lvlJc: {
        keepOnSplit: true,
        default: null,
        rendered: false,
      },
      // This will contain indentation and space info.
      // ie: w:left (left indent), w:hanging (hanging indent)
      listParagraphProperties: {
        keepOnSplit: true,
        default: null,
        rendered: false,
      },
      // This will contain run properties for the list item
      listRunProperties: {
        keepOnSplit: true,
        default: null,
        rendered: false,
      },
      numId: {
        keepOnSplit: true,
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-num-id'),
        renderDOM: (attrs) => {
          if (!attrs.numId) return {};
          return {
            'data-num-id': attrs.numId,
          };
        },
      },
      numPrType: {
        rendered: false,
        default: 'inline',
        keepOnSplit: true,
      },
      level: {
        parseDOM: (elem) => {
          return elem.getAttribute('data-level');
        },
        renderDOM: (attrs) => {
          if (attrs.level === void 0 || attrs.level === null) return {};
          return {
            'data-level': attrs.level,
          };
        },
      },
      attributes: {
        keepOnSplit: true,
        rendered: false,
      },
      spacing: {
        keepOnSplit: true,
        default: null,
        rendered: false,
      },
      indent: {
        parseDOM: (elem) => JSON.parse(elem.getAttribute('data-indent')),
        keepOnSplit: true,
        default: null,
        rendered: false,
      },
      markerStyle: {
        default: null,
        rendered: false,
        keepOnSplit: true,
      },
      styleId: {
        rendered: false,
        keepOnSplit: true,
      },
      customFormat: {
        default: null,
        rendered: false,
        keepOnSplit: true,
      },
      importedFontFamily: {
        parseDOM: (elem) => elem.getAttribute('data-font-family'),
        renderDOM: (attrs) => {
          if (!attrs.importedFontFamily) return {};
          return {
            'data-font-family': attrs.importedFontFamily,
          };
        },
      },
      importedFontSize: {
        parseDOM: (elem) => elem.getAttribute('data-font-size'),
        renderDOM: (attrs) => {
          if (!attrs.importedFontSize) return {};
          return {
            'data-font-size': attrs.importedFontSize,
          };
        },
      },
    };
  },
  addShortcuts() {
    return {
      Enter: () => {
        return this.editor.commands.splitListItem();
      },
      'Shift-Enter': () => {
        return this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.createParagraphNear(),
          () => commands2.splitBlock(),
        ]);
      },
      Tab: () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.increaseListIndent()]);
      },
      'Shift-Tab': () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.decreaseListIndent()]);
      },
    };
  },
});
const getDefaultSpacing = () => ({
  lineSpaceAfter: 0,
  lineSpaceBefore: 0,
  line: 0,
  lineRule: null,
});
const Paragraph = OxmlNode.create({
  name: 'paragraph',
  oXmlName: 'w:p',
  priority: 1e3,
  group: 'block',
  content: 'inline*',
  inline: false,
  addOptions() {
    return {
      headingLevels: [1, 2, 3, 4, 5, 6],
      htmlAttributes: {},
    };
  },
  addAttributes() {
    return {
      paraId: { rendered: false },
      textId: { rendered: false },
      rsidR: { rendered: false },
      rsidRDefault: { rendered: false },
      rsidP: { rendered: false },
      rsidRPr: { rendered: false },
      rsidDel: { rendered: false },
      spacing: {
        default: getDefaultSpacing(),
        parseDOM: (element) => {
          if (element && element.closest('[data-superdoc-import]')) {
            return {
              lineSpaceAfter: 11,
              lineSpaceBefore: 0,
              line: 1.15,
              lineRule: 'auto',
            };
          }
          return void 0;
        },
        renderDOM: (attrs) => {
          const { spacing } = attrs;
          if (!spacing) return {};
          const spacingCopy = { ...spacing };
          if (attrs.lineHeight) delete spacingCopy.line;
          const style = getSpacingStyleString(spacingCopy);
          if (style) return { style };
          return {};
        },
      },
      extraAttrs: {
        default: {},
        parseDOM: (element) => {
          const extra = {};
          Array.from(element.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return extra;
        },
        renderDOM: (attributes) => {
          return attributes.extraAttrs || {};
        },
      },
      marksAttrs: {
        renderDOM: (attrs) => {
          const { marksAttrs } = attrs;
          if (!marksAttrs?.length) return {};
          const style = getMarksStyle(marksAttrs);
          if (style) return { style };
          return {};
        },
      },
      indent: {
        default: null,
        renderDOM: ({ indent }) => {
          if (!indent) return {};
          const { left, right, firstLine, hanging } = indent;
          if (indent && Object.values(indent).every((v) => v === 0)) {
            return {};
          }
          let style = '';
          if (left) style += `margin-left: ${left}px;`;
          if (right) style += `margin-right: ${right}px;`;
          if (firstLine && !hanging) style += `text-indent: ${firstLine}px;`;
          if (firstLine && hanging) style += `text-indent: ${firstLine - hanging}px;`;
          if (!firstLine && hanging) style += `text-indent: ${-hanging}px;`;
          return { style };
        },
      },
      borders: {
        default: null,
        renderDOM: ({ borders }) => {
          if (!borders) return {};
          const sideOrder = ['top', 'right', 'bottom', 'left'];
          const valToCss = {
            single: 'solid',
            dashed: 'dashed',
            dotted: 'dotted',
            double: 'double',
          };
          let style = '';
          sideOrder.forEach((side) => {
            const b = borders[side];
            if (!b) return;
            const width = b.size != null ? `${b.size}px` : '1px';
            const cssStyle = valToCss[b.val] || 'solid';
            const color = b.color || '#000000';
            style += `border-${side}: ${width} ${cssStyle} ${color};`;
            if (b.space != null && side === 'bottom') {
              style += `padding-bottom: ${b.space}px;`;
            }
          });
          return style ? { style } : {};
        },
      },
      class: {
        renderDOM: (attributes) => {
          if (attributes.dropcap) {
            return { class: `sd-editor-dropcap` };
          }
          return null;
        },
      },
      styleId: {},
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      attributes: {
        rendered: false,
      },
      filename: { rendered: false },
      keepLines: { rendered: false },
      keepNext: { rendered: false },
      paragraphProperties: { rendered: false },
      dropcap: { rendered: false },
      pageBreakSource: { rendered: false },
      justify: {
        renderDOM: ({ justify }) => {
          const { val: jc } = justify || {};
          if (!jc) return {};
          let style = '';
          if (jc === 'left') style += 'text-align: left;';
          else if (jc === 'right') style += 'text-align: right;';
          else if (jc === 'center') style += 'text-align: center;';
          else if (jc === 'both') style += 'text-align: justify;';
          return { style };
        },
      },
      tabStops: { rendered: false },
    };
  },
  parseDOM() {
    return [
      {
        tag: 'p',
        getAttrs: (node) => {
          const { styleid, ...extraAttrs } = Array.from(node.attributes).reduce((acc, attr) => {
            acc[attr.name] = attr.value;
            return acc;
          }, {});
          return {
            styleId: styleid || null,
            extraAttrs,
          };
        },
      },
      {
        tag: 'div',
        getAttrs: (node) => {
          const extra = {};
          Array.from(node.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return { extraAttrs: extra };
        },
      },
      {
        tag: 'blockquote',
        attrs: { styleId: 'BlockQuote' },
      },
      ...this.options.headingLevels.map((level) => ({
        tag: `h${level}`,
        attrs: { level, styleId: `Heading${level}` },
      })),
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['p', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addPmPlugins() {
    const { view } = this.editor;
    const dropcapWidthCache = /* @__PURE__ */ new Map();
    const hasDropcapParagraph = (node) => node.type.name === 'paragraph' && node.attrs.dropcap?.type === 'margin';
    const invalidateCacheForRange = (from, to) => {
      for (const [pos] of dropcapWidthCache) {
        if (pos >= from && pos <= to) {
          dropcapWidthCache.delete(pos);
        }
      }
    };
    const dropcapPlugin = new Plugin({
      name: 'dropcapPlugin',
      key: new PluginKey('dropcapPlugin'),
      state: {
        init(_, state) {
          const decorations = getDropcapDecorations(state, view, dropcapWidthCache);
          return DecorationSet.create(state.doc, decorations);
        },
        apply(tr, oldDecorationSet, oldState, newState) {
          if (!tr.docChanged) return oldDecorationSet;
          let hasDropcaps = false;
          newState.doc.descendants((node) => {
            if (hasDropcapParagraph(node)) {
              hasDropcaps = true;
              return false;
            }
          });
          if (!hasDropcaps) {
            dropcapWidthCache.clear();
            return DecorationSet.empty;
          }
          let affectsDropcaps = false;
          tr.steps.forEach((step) => {
            if (step.slice?.content) {
              step.slice.content.descendants((node) => {
                if (hasDropcapParagraph(node)) {
                  affectsDropcaps = true;
                  return false;
                }
              });
            }
            if (step.jsonID === 'replace' && step.from !== void 0 && step.to !== void 0) {
              try {
                oldState.doc.nodesBetween(step.from, step.to, (node) => {
                  if (hasDropcapParagraph(node)) {
                    affectsDropcaps = true;
                    return false;
                  }
                });
              } catch {
                affectsDropcaps = true;
              }
            }
          });
          if (!affectsDropcaps) {
            return oldDecorationSet.map(tr.mapping, tr.doc);
          }
          tr.steps.forEach((step) => {
            if (step.from !== void 0 && step.to !== void 0) {
              invalidateCacheForRange(step.from, step.to);
            }
          });
          const decorations = getDropcapDecorations(newState, view, dropcapWidthCache);
          return DecorationSet.create(newState.doc, decorations);
        },
      },
      props: {
        decorations(state) {
          return this.getState(state);
        },
      },
    });
    return [dropcapPlugin];
  },
});
const getDropcapDecorations = (state, view, widthCache) => {
  const decorations = [];
  state.doc.descendants((node, pos) => {
    if (node.type.name === 'paragraph') {
      if (node.attrs.dropcap?.type === 'margin') {
        const width = getDropcapWidth(view, pos, widthCache);
        decorations.push(Decoration.inline(pos, pos + node.nodeSize, { style: `margin-left: -${width}px;` }));
      }
      return false;
    }
  });
  return decorations;
};
function getDropcapWidth(view, pos, widthCache) {
  if (widthCache.has(pos)) {
    return widthCache.get(pos);
  }
  const domNode = view.nodeDOM(pos);
  if (domNode) {
    const range = document.createRange();
    range.selectNodeContents(domNode);
    const width = range.getBoundingClientRect().width;
    widthCache.set(pos, width);
    return width;
  }
  return 0;
}
const Heading = Extension.create({
  name: 'heading',
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
    };
  },
  addCommands() {
    return {
      /**
       * Set a heading with specified level
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @example
       * editor.commands.setHeading({ level: 2 })
       * @note Converts current block to heading
       */
      setHeading:
        (attributes) =>
        ({ commands: commands2 }) => {
          const containsLevel = this.options.levels.includes(attributes.level);
          if (!containsLevel) return false;
          return commands2.setLinkedStyle({ id: `Heading${attributes.level}` });
        },
      /**
       * Toggle between heading and paragraph
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @example
       * editor.commands.toggleHeading({ level: 1 })
       * editor.commands.toggleHeading({ level: 3 })
       * @note Switches between heading and paragraph for the same level
       */
      toggleHeading:
        (attributes) =>
        ({ commands: commands2 }) => {
          const containsLevel = this.options.levels.includes(attributes.level);
          if (!containsLevel) return false;
          return commands2.toggleLinkedStyle({ id: `Heading${attributes.level}` }, 'paragraph');
        },
    };
  },
  addShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),
        },
      }),
      {},
    );
  },
});
const CommentRangeStart = Node$1.create({
  name: 'commentRangeStart',
  group: 'inline',
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  parseDOM() {
    return [{ tag: 'commentRangeStart' }];
  },
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: 'false',
        'aria-label': 'Comment range start node',
      },
    };
  },
  renderDOM({ htmlAttributes }) {
    return ['commentRangeStart', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      'w:id': {
        rendered: false,
      },
      internal: {
        default: true,
        rendered: false,
      },
    };
  },
});
const CommentRangeEnd = Node$1.create({
  name: 'commentRangeEnd',
  group: 'inline',
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: 'false',
        'aria-label': 'Comment range end node',
      },
    };
  },
  parseDOM() {
    return [{ tag: 'commentRangeEnd' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['commentRangeEnd', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      'w:id': {
        rendered: false,
      },
    };
  },
});
const CommentReference = Node$1.create({
  name: 'commentReference',
  group: 'inline',
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: 'false',
        'aria-label': 'Comment reference node',
      },
    };
  },
  parseDOM() {
    return [{ tag: 'commentReference' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['commentReference', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false,
      },
    };
  },
});
const CommentsMark = Mark.create({
  name: CommentMarkName,
  group: 'comments',
  excludes: '',
  addOptions() {
    return {
      htmlAttributes: { class: 'sd-editor-comment' },
    };
  },
  addAttributes() {
    return {
      commentId: {},
      importedId: {},
      internal: {
        default: true,
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: CommentMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [CommentMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
});
const defaultTabDistance = 48;
const defaultLineLength = 816;
const getTabDecorations = (doc, view, helpers2, from = 0, to = null) => {
  const decorations = [];
  const paragraphCache = /* @__PURE__ */ new Map();
  const coordCache = /* @__PURE__ */ new Map();
  const domPosCache = /* @__PURE__ */ new Map();
  const end = to ?? doc.content.size;
  doc.nodesBetween(from, end, (node, pos) => {
    if (node.type.name !== 'tab') return;
    let extraStyles = '';
    const $pos = doc.resolve(pos);
    const paragraphContext = getParagraphContext($pos, paragraphCache, helpers2);
    if (!paragraphContext) return;
    try {
      const { tabStops, flattened, positionMap, startPos } = paragraphContext;
      const entryIndex = positionMap.get(pos);
      if (entryIndex === void 0) return;
      if (paragraphContext.indentWidth === void 0) {
        paragraphContext.indentWidth = getIndentWidth(view, startPos, paragraphContext.indent, coordCache, domPosCache);
      }
      if (paragraphContext.tabHeight === void 0) {
        paragraphContext.tabHeight = calcTabHeight($pos);
      }
      const indentWidth = paragraphContext.indentWidth;
      const accumulatedTabWidth = paragraphContext.accumulatedTabWidth || 0;
      const currentWidth =
        indentWidth + measureRangeWidth(view, startPos + 1, pos, coordCache, domPosCache) + accumulatedTabWidth;
      let tabWidth;
      if (tabStops.length) {
        const tabStop = tabStops.find((stop) => stop.pos > currentWidth && stop.val !== 'clear');
        if (tabStop) {
          tabWidth = tabStop.pos - currentWidth;
          if (tabStop.val === 'center' || tabStop.val === 'end' || tabStop.val === 'right') {
            const nextTabIndex = findNextTabIndex(flattened, entryIndex + 1);
            const segmentStartPos = pos + node.nodeSize;
            const segmentEndPos =
              nextTabIndex === -1 ? startPos + paragraphContext.paragraph.nodeSize - 1 : flattened[nextTabIndex].pos;
            const segmentWidth = measureRangeWidth(view, segmentStartPos, segmentEndPos, coordCache, domPosCache);
            tabWidth -= tabStop.val === 'center' ? segmentWidth / 2 : segmentWidth;
          } else if (tabStop.val === 'decimal' || tabStop.val === 'num') {
            const breakChar = tabStop.decimalChar || '.';
            const decimalPos = findDecimalBreakPos(flattened, entryIndex + 1, breakChar);
            const integralWidth = decimalPos
              ? measureRangeWidth(view, pos + node.nodeSize, decimalPos, coordCache, domPosCache)
              : measureRangeWidth(
                  view,
                  pos + node.nodeSize,
                  startPos + paragraphContext.paragraph.nodeSize - 1,
                  coordCache,
                  domPosCache,
                );
            tabWidth -= integralWidth;
          }
          if (tabStop.leader) {
            const leaderStyles = {
              dot: 'border-bottom: 1px dotted black;',
              heavy: 'border-bottom: 2px solid black;',
              hyphen: 'border-bottom: 1px solid black;',
              middleDot: 'border-bottom: 1px dotted black; margin-bottom: 2px;',
              underscore: 'border-bottom: 1px solid black;',
            };
            extraStyles += leaderStyles[tabStop.leader] || '';
          }
        }
      }
      if (!tabWidth || tabWidth < 1) {
        tabWidth = defaultTabDistance - ((currentWidth % defaultLineLength) % defaultTabDistance);
        if (tabWidth === 0) tabWidth = defaultTabDistance;
      }
      const tabHeight = paragraphContext.tabHeight;
      decorations.push(
        Decoration.node(pos, pos + node.nodeSize, {
          style: `width: ${tabWidth}px; height: ${tabHeight};${extraStyles}`,
        }),
      );
      paragraphContext.accumulatedTabWidth = accumulatedTabWidth + tabWidth;
    } catch (error) {
      console.error('tab decoration error', error);
    }
  });
  return decorations;
};
function getParagraphContext($pos, cache, helpers2) {
  for (let depth = $pos.depth; depth >= 0; depth--) {
    const node = $pos.node(depth);
    if (node?.type?.name === 'paragraph') {
      const startPos = $pos.start(depth);
      if (!cache.has(startPos)) {
        let tabStops = [];
        if (Array.isArray(node.attrs?.tabStops)) {
          tabStops = node.attrs.tabStops;
        } else {
          const style = helpers2.linkedStyles.getStyleById(node.attrs?.styleId);
          if (Array.isArray(style?.definition?.styles?.tabStops)) {
            tabStops = style.definition.styles.tabStops;
          }
        }
        const { entries, positionMap } = flattenParagraph(node, startPos);
        cache.set(startPos, {
          paragraph: node,
          paragraphDepth: depth,
          startPos,
          indent: node.attrs?.indent || {},
          tabStops,
          flattened: entries,
          positionMap,
          // Store position map for O(1) lookups
          accumulatedTabWidth: 0,
        });
      }
      return cache.get(startPos);
    }
  }
  return null;
}
function flattenParagraph(paragraph, paragraphStartPos) {
  const entries = [];
  const positionMap = /* @__PURE__ */ new Map();
  const walk = (node, basePos) => {
    if (!node) return;
    if (node.type?.name === 'run') {
      node.forEach((child, offset) => {
        const childPos = basePos + offset + 1;
        walk(child, childPos);
      });
      return;
    }
    const pos = basePos - 1;
    const index = entries.length;
    entries.push({ node, pos });
    positionMap.set(pos, index);
  };
  paragraph.forEach((child, offset) => {
    const childPos = paragraphStartPos + offset + 1;
    walk(child, childPos);
  });
  return { entries, positionMap };
}
function findNextTabIndex(flattened, fromIndex) {
  for (let i = fromIndex; i < flattened.length; i++) {
    if (flattened[i]?.node?.type?.name === 'tab') {
      return i;
    }
  }
  return -1;
}
function findDecimalBreakPos(flattened, startIndex, breakChar) {
  for (let i = startIndex; i < flattened.length; i++) {
    const entry = flattened[i];
    if (!entry) break;
    if (entry.node.type?.name === 'tab') break;
    if (entry.node.type?.name === 'text') {
      const index = entry.node.text?.indexOf(breakChar);
      if (index !== void 0 && index !== -1) {
        return entry.pos + index + 1;
      }
    }
  }
  return null;
}
function measureRangeWidth(view, from, to, coordCache = null, domPosCache = null) {
  if (!Number.isFinite(from) || !Number.isFinite(to) || to <= from) return 0;
  try {
    const range = document.createRange();
    const fromRef = getCachedDomAtPos(view, from, domPosCache);
    const toRef = getCachedDomAtPos(view, to, domPosCache);
    range.setStart(fromRef.node, fromRef.offset);
    range.setEnd(toRef.node, toRef.offset);
    const rect = range.getBoundingClientRect();
    range.detach?.();
    return rect.width || 0;
  } catch {
    const startLeft = getLeftCoord(view, from, coordCache, domPosCache);
    const endLeft = getLeftCoord(view, to, coordCache, domPosCache);
    if (startLeft == null || endLeft == null) return 0;
    return Math.max(0, endLeft - startLeft);
  }
}
function getIndentWidth(view, paragraphStartPos, indentAttrs = {}, coordCache = null, domPosCache = null) {
  const marginLeft = getLeftCoord(view, paragraphStartPos, coordCache, domPosCache);
  const lineLeft = getLeftCoord(view, paragraphStartPos + 1, coordCache, domPosCache);
  if (marginLeft != null && lineLeft != null) {
    const diff = lineLeft - marginLeft;
    if (!Number.isNaN(diff) && Math.abs(diff) > 0.5) {
      return diff;
    }
  }
  return calculateIndentFallback(indentAttrs);
}
function calculateIndentFallback(indentAttrs = {}) {
  if (!indentAttrs) return 0;
  const left = Number(indentAttrs.left) || 0;
  const firstLine = Number(indentAttrs.firstLine) || 0;
  const hanging = Number(indentAttrs.hanging) || 0;
  let textIndent = 0;
  if (firstLine && hanging) {
    textIndent = firstLine - hanging;
  } else if (firstLine) {
    textIndent = firstLine;
  } else if (hanging) {
    textIndent = -hanging;
  } else if (typeof indentAttrs.textIndent === 'string') {
    const match = indentAttrs.textIndent.match(/(-?\d*\.?\d+)in$/);
    if (match) {
      textIndent = Number(match[1]) * 96;
    }
  }
  if (textIndent) return left + textIndent;
  if (left) return left;
  return 0;
}
function getLeftCoord(view, pos, coordCache = null, domPosCache = null) {
  if (!Number.isFinite(pos)) return null;
  if (coordCache && coordCache.has(pos)) {
    return coordCache.get(pos);
  }
  let result = null;
  try {
    result = view.coordsAtPos(pos).left;
  } catch {
    try {
      const ref2 = getCachedDomAtPos(view, pos, domPosCache);
      const range = document.createRange();
      range.setStart(ref2.node, ref2.offset);
      range.setEnd(ref2.node, ref2.offset);
      const rect = range.getBoundingClientRect();
      range.detach?.();
      result = rect.left;
    } catch {
      result = null;
    }
  }
  if (coordCache) {
    coordCache.set(pos, result);
  }
  return result;
}
function getCachedDomAtPos(view, pos, domPosCache = null) {
  if (domPosCache && domPosCache.has(pos)) {
    return domPosCache.get(pos);
  }
  const result = view.domAtPos(pos);
  if (domPosCache) {
    domPosCache.set(pos, result);
  }
  return result;
}
function calcTabHeight(pos) {
  const ptToPxRatio = 1.333;
  const defaultFontSize = 16;
  const defaultLineHeight = 1.1;
  const blockParent = pos.node(1);
  const parentTextStyleMark = blockParent.firstChild.marks.find((mark) => mark.type.name === 'textStyle');
  const fontSize = parseInt(parentTextStyleMark?.attrs.fontSize) * ptToPxRatio || defaultFontSize;
  return `${fontSize * defaultLineHeight}px`;
}
const TabNode = Node$1.create({
  name: 'tab',
  group: 'inline',
  inline: true,
  // need this prop so Prosemirror doesn't treat tab as an
  // empty node and doesn't insert separator after
  content: 'inline*',
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-editor-tab',
        // this works together with content prop:
        // since tab can't have content inside but content prop is defined I have to manually add attribute
        contentEditable: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'span.sd-editor-tab' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      tabSize: {
        renderDOM: ({ tabSize }) => {
          if (!tabSize) return {};
          const style = `width: ${tabSize}px; min-width: ${tabSize}px;`;
          return { style };
        },
      },
    };
  },
  addPmPlugins() {
    const { view, helpers: helpers2 } = this.editor;
    const mergeRanges2 = (ranges) => {
      if (ranges.length === 0) return [];
      const sorted = ranges.slice().sort((a, b) => a[0] - b[0]);
      const merged = [sorted[0]];
      for (let i = 1; i < sorted.length; i++) {
        const [start, end] = sorted[i];
        const last = merged[merged.length - 1];
        if (start <= last[1]) {
          last[1] = Math.max(last[1], end);
        } else {
          merged.push([start, end]);
        }
      }
      return merged;
    };
    const tabPlugin = new Plugin({
      name: 'tabPlugin',
      key: new PluginKey('tabPlugin'),
      state: {
        init() {
          return { decorations: false };
        },
        apply(tr, { decorations }, _oldState, newState) {
          if (!decorations) {
            decorations = DecorationSet.create(newState.doc, getTabDecorations(newState.doc, view, helpers2));
            return { decorations };
          }
          if (!tr.docChanged || tr.getMeta('blockNodeInitialUpdate')) {
            return { decorations };
          }
          decorations = decorations.map(tr.mapping, tr.doc);
          const rangesToRecalculate = [];
          const containsTab = (node) => node.type.name === 'tab';
          tr.steps.forEach((step, index) => {
            if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1)) {
              return;
            }
            let hasTabInRange = false;
            if (step.slice?.content) {
              step.slice.content.descendants((node) => {
                if (containsTab(node)) {
                  hasTabInRange = true;
                  return false;
                }
              });
            }
            if (!hasTabInRange) {
              tr.docs[index].nodesBetween(step.from, step.to, (node) => {
                if (containsTab(node)) {
                  hasTabInRange = true;
                  return false;
                }
              });
            }
            if (!hasTabInRange) {
              return;
            }
            let fromPos = step.from;
            let toPos = step.to;
            for (let i = index; i < tr.steps.length; i++) {
              const stepMap = tr.steps[i].getMap();
              fromPos = stepMap.map(fromPos, -1);
              toPos = stepMap.map(toPos, 1);
            }
            const $from = newState.doc.resolve(fromPos);
            const $to = newState.doc.resolve(toPos);
            const start = $from.start(Math.min($from.depth, 1));
            const end = $to.end(Math.min($to.depth, 1));
            rangesToRecalculate.push([start, end]);
          });
          if (rangesToRecalculate.length === 0) {
            return { decorations };
          }
          const mergedRanges = mergeRanges2(rangesToRecalculate);
          mergedRanges.forEach(([start, end]) => {
            const oldDecorations = decorations.find(start, end);
            decorations = decorations.remove(oldDecorations);
            const newDecorations = getTabDecorations(newState.doc, view, helpers2, start, end);
            decorations = decorations.add(newState.doc, newDecorations);
          });
          return { decorations };
        },
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        },
      },
    });
    return [tabPlugin];
  },
});
const LineBreak = Node$1.create({
  name: 'lineBreak',
  group: 'inline',
  inline: true,
  marks: '',
  defining: true,
  selectable: false,
  content: '',
  atom: true,
  addOptions() {
    return {};
  },
  parseDOM() {
    return [{ tag: 'br' }];
  },
  renderDOM() {
    return ['br', {}];
  },
  addAttributes() {
    return {
      lineBreakType: { rendered: false },
      clear: { rendered: false },
    };
  },
  addCommands() {
    return {
      /**
       * Insert a line break
       * @category Command
       * @example
       * editor.commands.insertLineBreak()
       * @note Creates a soft break within the same paragraph
       */
      insertLineBreak:
        () =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({ type: 'lineBreak' });
        },
    };
  },
});
const HardBreak = Node$1.create({
  name: 'hardBreak',
  group: 'inline',
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: 'false',
        lineBreakType: 'page',
        'aria-hidden': 'true',
        'aria-label': 'Hard break node',
      },
    };
  },
  addAttributes() {
    return {
      pageBreakSource: {
        rendered: false,
        default: null,
      },
      pageBreakType: {
        default: null,
        rendered: false,
      },
      lineBreakType: { rendered: false },
      clear: { rendered: false },
    };
  },
  parseDOM() {
    return [
      {
        tag: 'span[linebreaktype="page"]',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) return false;
          return {
            pageBreakSource: dom.getAttribute('pagebreaksource') || null,
            pageBreakType: dom.getAttribute('linebreaktype') || null,
          };
        },
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a page break
       * @category Command
       * @example
       * editor.commands.insertPageBreak()
       * @note Forces content to start on a new page when printed
       */
      insertPageBreak:
        () =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: 'hardBreak',
            attrs: { pageBreakType: 'page' },
          });
        },
    };
  },
});
const getColStyleDeclaration = (minWidth, width) => {
  if (width != null) {
    const numericWidth = Number(width);
    if (Number.isFinite(numericWidth) && numericWidth >= 0) {
      return ['width', `${numericWidth}px`];
    }
  }
  return ['min-width', `${minWidth}px`];
};
const createTableView = ({ editor }) => {
  return class TableView {
    constructor(node, cellMinWidth2) {
      __publicField(this, 'editor');
      __publicField(this, 'node');
      __publicField(this, 'dom');
      __publicField(this, 'table');
      __publicField(this, 'colgroup');
      __publicField(this, 'contentDOM');
      __publicField(this, 'cellMinWidth');
      this.editor = editor;
      this.node = node;
      this.cellMinWidth = cellMinWidth2;
      this.dom = document.createElement('div');
      this.dom.className = 'tableWrapper';
      this.table = this.dom.appendChild(document.createElement('table'));
      this.colgroup = this.table.appendChild(document.createElement('colgroup'));
      updateTable(this.editor, this.node, this.table);
      updateColumns(node, this.colgroup, this.table, cellMinWidth2, void 0, void 0, this.editor);
      this.contentDOM = this.table.appendChild(document.createElement('tbody'));
      setTimeout(() => {
        updateTableWrapper(this.dom, this.table);
      }, 0);
    }
    update(node) {
      if (node.type !== this.node.type) {
        return false;
      }
      this.node = node;
      updateTable(this.editor, node, this.table);
      updateColumns(node, this.colgroup, this.table, this.cellMinWidth, void 0, void 0, this.editor);
      updateTableWrapper(this.dom, this.table);
      return true;
    }
    ignoreMutation(mutation) {
      const tableWrapper = this.dom;
      if (mutation.target === tableWrapper && mutation.type === 'attributes' && mutation.attributeName === 'style') {
        return true;
      }
      return (
        mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target))
      );
    }
  };
};
function updateColumns(node, colgroup, table, cellMinWidth2, overrideCol, overrideValue, editor) {
  const gridColumns =
    Array.isArray(node.attrs?.grid) && node.attrs.grid.length
      ? node.attrs.grid.map((col) => twipsToPixels(col.col))
      : null;
  const totalColumns = gridColumns?.length ?? null;
  const pageBody = table.closest('.page__body');
  const wrapper = table.parentElement;
  let availableWidth = pageBody?.getBoundingClientRect?.().width;
  if (!availableWidth && wrapper) {
    availableWidth = wrapper.getBoundingClientRect().width;
  }
  if (typeof availableWidth === 'number' && !Number.isNaN(availableWidth)) {
    availableWidth = Math.max(availableWidth - 2, 0);
  } else {
    availableWidth = null;
  }
  const pageStyles = editor?.converter?.pageStyles;
  if (pageStyles?.pageSize?.width) {
    const toNumber = (v) => (typeof v === 'number' ? v : parseFloat(v) || 0);
    const pageWidth = toNumber(pageStyles.pageSize.width);
    const marginLeft = toNumber(pageStyles.pageMargins?.left);
    const marginRight = toNumber(pageStyles.pageMargins?.right);
    const pageAvailableWidthPx = Math.max((pageWidth - marginLeft - marginRight) * PIXELS_PER_INCH, 0);
    if (pageAvailableWidthPx > 0) {
      availableWidth = availableWidth ? Math.min(availableWidth, pageAvailableWidthPx) : pageAvailableWidthPx;
    }
  }
  const resolveColumnWidth = (colIndex2, colwidthValue) => {
    if (overrideCol === colIndex2) return overrideValue;
    if (colwidthValue != null) return colwidthValue;
    if (gridColumns && gridColumns[colIndex2] != null) return gridColumns[colIndex2];
    return null;
  };
  const widths = [];
  const row = node.firstChild;
  let colIndex = 0;
  if (row !== null) {
    for (let i = 0; i < row.childCount; i++) {
      const child = row.child(i);
      const { colspan, colwidth } = child.attrs;
      for (let span = 0; span < colspan; span += 1, colIndex += 1) {
        widths.push(resolveColumnWidth(colIndex, colwidth && colwidth[span]));
      }
    }
  }
  if (totalColumns != null && colIndex < totalColumns) {
    for (let col = colIndex; col < totalColumns; col += 1) {
      widths.push(resolveColumnWidth(col));
    }
  }
  const normalizedWidths = widths.map((widthPx) => {
    const numericWidth = Number(widthPx);
    if (!Number.isFinite(numericWidth)) return null;
    if (numericWidth < 0) return null;
    if (numericWidth === 0) return 0;
    if (numericWidth < 1) return 0;
    return numericWidth;
  });
  const rawTotalWidth = normalizedWidths.reduce((sum, width) => sum + (width != null ? width : cellMinWidth2), 0);
  let scale = 1;
  if (availableWidth && rawTotalWidth > 0 && rawTotalWidth > availableWidth) {
    scale = availableWidth / rawTotalWidth;
  }
  let totalWidth = 0;
  let hasUndefinedWidth = false;
  let dom = colgroup.firstChild;
  normalizedWidths.forEach((width) => {
    let scaledWidth = width;
    if (scaledWidth != null) {
      scaledWidth = scaledWidth * scale;
    }
    const [propKey, propVal] = getColStyleDeclaration(cellMinWidth2, scaledWidth);
    if (scaledWidth == null) {
      totalWidth += cellMinWidth2;
      hasUndefinedWidth = true;
    } else {
      totalWidth += scaledWidth;
    }
    if (!dom) {
      const colElement = document.createElement('col');
      colElement.style.setProperty(propKey, propVal);
      colgroup.appendChild(colElement);
    } else {
      dom.style.setProperty(propKey, propVal);
      dom = dom.nextSibling;
    }
  });
  while (dom) {
    const next = dom.nextSibling;
    dom.parentNode?.removeChild(dom);
    dom = next;
  }
  if (scale < 1 || !hasUndefinedWidth) {
    const clampedWidth = Math.min(totalWidth, availableWidth || totalWidth);
    table.style.width = `${clampedWidth}px`;
    table.style.minWidth = '';
  } else {
    table.style.width = '';
    table.style.minWidth = `${totalWidth}px`;
  }
  table.style.maxWidth = '100%';
}
function updateTable(editor, node, table) {
  const allExtensionsAttrs = editor.extensionService.attributes;
  const tableExtensionAttrs = allExtensionsAttrs.filter((e) => e.type === 'table');
  const htmlAttributes = Attribute.getAttributesToRender(node, tableExtensionAttrs);
  Object.entries(htmlAttributes).forEach(([key2, value]) => {
    if (key2 === 'style') {
      table.style.cssText = value;
    } else {
      table.setAttribute(key2, value);
    }
  });
}
function updateTableWrapper(tableWrapper, table) {
  let defaultBorderWidth = 1;
  let borderWidth;
  if (!table) {
    return;
  }
  let borderLeftMax = parseFloat(table.style.borderLeftWidth || 0);
  let borderRightMax = parseFloat(table.style.borderRightWidth) || 0;
  let firstColumnCells = [...table.querySelectorAll(':scope > tbody > tr > td:first-child')];
  let lastColumnCells = [...table.querySelectorAll(':scope > tbody > tr > td:last-child')];
  for (let cell of firstColumnCells) {
    let borderLeft = parseFloat(cell.style.borderLeftWidth) || 0;
    borderLeftMax = Math.max(borderLeftMax, borderLeft);
  }
  for (let cell of lastColumnCells) {
    let borderRight = parseFloat(cell.style.borderRightWidth) || 0;
    borderRightMax = Math.max(borderRightMax, borderRight);
  }
  borderWidth = Math.ceil(Math.max(borderLeftMax, borderRightMax));
  tableWrapper.style.setProperty('--table-border-width', `${borderWidth || defaultBorderWidth}px`);
}
const createCell = (cellType, cellContent = null) => {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
};
const createTableBorders = ({ size = 0.66665, color = '#000000' } = {}) => {
  return {
    top: { size, color },
    left: { size, color },
    bottom: { size, color },
    right: { size, color },
    insideH: { size, color },
    insideV: { size, color },
  };
};
const createTable = (schema, rowsCount, colsCount, withHeaderRow, cellContent = null) => {
  const types = {
    table: getNodeType('table', schema),
    tableRow: getNodeType('tableRow', schema),
    tableCell: getNodeType('tableCell', schema),
    tableHeader: getNodeType('tableHeader', schema),
  };
  const headerCells = [];
  const cells = [];
  for (let index = 0; index < colsCount; index++) {
    const cell = createCell(types.tableCell, cellContent);
    if (cell) cells.push(cell);
    if (withHeaderRow) {
      const headerCell = createCell(types.tableHeader, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index = 0; index < rowsCount; index++) {
    const cellsToInsert = withHeaderRow && index === 0 ? headerCells : cells;
    rows.push(types.tableRow.createChecked(null, cellsToInsert));
  }
  const tableBorders = createTableBorders();
  return types.table.createChecked({ borders: tableBorders }, rows);
};
const MIN_MEANINGFUL_WIDTH_PX = 1;
const createColGroup = (node, cellMinWidth2, overrideCol, overrideValue) => {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const colsValues = [];
  const row = node.firstChild;
  const gridColumns =
    Array.isArray(node.attrs?.grid) && node.attrs.grid.length
      ? node.attrs.grid.map((col) => twipsToPixels(col.col))
      : null;
  if (!row) return {};
  const totalColumns = gridColumns?.length;
  const resolveColumnWidth = (colIndex2, colwidthValue) => {
    if (overrideCol === colIndex2) return overrideValue;
    if (colwidthValue != null) return colwidthValue;
    if (gridColumns && gridColumns[colIndex2] != null) return gridColumns[colIndex2];
    return null;
  };
  let colIndex = 0;
  for (let i = 0; i < row.childCount; i++) {
    const child = row.child(i);
    const { colspan, colwidth } = child.attrs;
    for (let j = 0; j < colspan; j++, colIndex++) {
      const candidateWidth = resolveColumnWidth(colIndex, colwidth && colwidth[j]);
      const numericWidth = Number(candidateWidth);
      let effectiveWidth = Number.isFinite(numericWidth) && numericWidth > 0 ? numericWidth : null;
      if (effectiveWidth != null && effectiveWidth < MIN_MEANINGFUL_WIDTH_PX) {
        effectiveWidth = 0;
      }
      if (effectiveWidth == null) {
        totalWidth += cellMinWidth2;
        fixedWidth = false;
      } else {
        totalWidth += effectiveWidth;
      }
      const [prop, value] = getColStyleDeclaration(cellMinWidth2, effectiveWidth);
      cols.push(['col', { style: `${prop}: ${value}` }]);
      colsValues.push(parseFloat(value));
    }
  }
  if (totalColumns != null) {
    for (let col = colIndex; col < totalColumns; col++) {
      const candidateWidth = resolveColumnWidth(col);
      const numericWidth = Number(candidateWidth);
      let effectiveWidth = Number.isFinite(numericWidth) && numericWidth > 0 ? numericWidth : null;
      if (effectiveWidth != null && effectiveWidth < MIN_MEANINGFUL_WIDTH_PX) {
        effectiveWidth = 0;
      }
      if (effectiveWidth == null) {
        totalWidth += cellMinWidth2;
        fixedWidth = false;
      } else {
        totalWidth += effectiveWidth;
      }
      const [prop, value] = getColStyleDeclaration(cellMinWidth2, effectiveWidth);
      cols.push(['col', { style: `${prop}: ${value}` }]);
      colsValues.push(parseFloat(value));
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : '';
  const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`;
  const colgroup = ['colgroup', {}, ...cols];
  const colgroupValues = [...colsValues];
  return {
    colgroup,
    tableWidth,
    tableMinWidth,
    colgroupValues,
  };
};
const isCellSelection = (value) => value instanceof CellSelection;
const deleteTableWhenSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) return false;
  let cellCount = 0;
  const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
    return node.type.name === 'table';
  });
  table?.node.descendants((node) => {
    if (node.type.name === 'table') return false;
    if (['tableCell', 'tableHeader'].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
const createCellBorders = ({ size = 0.66665, color = '#000000' } = {}) => {
  return {
    top: { size, color },
    left: { size, color },
    bottom: { size, color },
    right: { size, color },
  };
};
function cellAround($pos) {
  for (let d2 = $pos.depth - 1; d2 > 0; d2--)
    if ($pos.node(d2).type.spec.tableRole == 'row') return $pos.node(0).resolve($pos.before(d2 + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d2 = $pos.depth; d2 > 0; d2--) {
    const role = $pos.node(d2).type.spec.tableRole;
    if (role === 'cell' || role === 'header_cell') return $pos.node(d2);
  }
  return null;
}
function resolveTable(tr, tablePos, tableNode) {
  if (tableNode && tableNode.type && tableNode.type.name === 'table') {
    return tableNode;
  }
  if (typeof tablePos === 'number') {
    const current = tr.doc.nodeAt(tablePos);
    if (current && current.type.name === 'table') {
      return current;
    }
  }
  return null;
}
function pickTemplateRowForAppend(tableNode, schema) {
  const RowType = schema.nodes.tableRow;
  const rows = [];
  tableNode.descendants((child) => {
    if (child.type === RowType) rows.push(child);
  });
  if (!rows.length) return null;
  for (let i = rows.length - 1; i >= 0; i--) {
    const r2 = rows[i];
    const hasBodyCell = r2.content?.content?.some((c) => c.type.name === 'tableCell');
    if (hasBodyCell) return r2;
  }
  return rows[rows.length - 1];
}
function extractRowTemplateFormatting(cellNode, schema) {
  const ParagraphType = schema.nodes.paragraph;
  let blockType = ParagraphType;
  let blockAttrs = null;
  let textMarks = [];
  const blocks = cellNode?.content?.content || [];
  for (const block of blocks) {
    const isParagraphish = block.type === ParagraphType || block.type.name === 'heading';
    if (isParagraphish) {
      blockType = block.type || ParagraphType;
      blockAttrs = block.attrs || null;
    }
    let foundText = null;
    block.descendants?.((n) => {
      if (!foundText && n.isText) foundText = n;
    });
    if (foundText) {
      textMarks = foundText.marks ? Array.from(foundText.marks) : [];
      break;
    }
  }
  if (!blockType || !blockType.validContent) blockType = ParagraphType;
  return { blockType, blockAttrs, textMarks };
}
function buildFormattedCellBlock(schema, value, { blockType, blockAttrs, textMarks }, copyRowStyle = false) {
  const text = typeof value === 'string' ? value : value == null ? '' : String(value);
  const marks = copyRowStyle ? textMarks || [] : [];
  const textNode = schema.text(text, marks);
  const type = blockType || schema.nodes.paragraph;
  return type.createAndFill(blockAttrs || null, textNode);
}
function buildRowFromTemplateRow({ schema, tableNode, templateRow, values, copyRowStyle = false }) {
  const RowType = schema.nodes.tableRow;
  const CellType = schema.nodes.tableCell;
  const HeaderType = schema.nodes.tableHeader;
  const map = TableMap.get(tableNode);
  const totalColumns = map.width;
  const byColumns = Array.isArray(values) && values.length === totalColumns;
  const newCells = [];
  let columnCursor = 0;
  templateRow.content.content.forEach((cellNode, cellIndex) => {
    const isHeaderCell = cellNode.type === HeaderType;
    const targetCellType = isHeaderCell ? CellType : cellNode.type;
    const attrs = { ...cellNode.attrs };
    const formatting = extractRowTemplateFormatting(cellNode, schema);
    let cellValue = '';
    if (byColumns) {
      const span = Math.max(1, attrs.colspan || 1);
      cellValue = values[columnCursor] ?? '';
      columnCursor += span;
    } else {
      cellValue = Array.isArray(values) ? (values[cellIndex] ?? '') : '';
    }
    const content = buildFormattedCellBlock(schema, cellValue, formatting, copyRowStyle);
    const newCell = targetCellType.createAndFill(attrs, content);
    if (newCell) newCells.push(newCell);
  });
  return RowType.createAndFill(null, newCells);
}
function insertRowsAtTableEnd({ tr, tablePos, tableNode, rows }) {
  if (!rows || !rows.length) return;
  const RowTypeName = 'tableRow';
  let lastRowRelPos = 0;
  let lastRowNode = null;
  tableNode.descendants((child, relPos) => {
    if (child.type.name === RowTypeName) {
      lastRowRelPos = relPos;
      lastRowNode = child;
    }
  });
  if (!lastRowNode) return;
  const lastRowAbsEnd = tablePos + 1 + lastRowRelPos + lastRowNode.nodeSize;
  const frag = Fragment.fromArray(rows);
  tr.insert(lastRowAbsEnd, frag);
}
const Table = Node$1.create({
  name: 'table',
  content: 'tableRow+',
  group: 'block',
  isolating: true,
  tableRole: 'table',
  addOptions() {
    return {
      htmlAttributes: {
        'aria-label': 'Table node',
      },
      resizable: true,
      handleWidth: 5,
      cellMinWidth: 10,
      lastColumnResizable: true,
      allowTableNodeSelection: false,
    };
  },
  addAttributes() {
    return {
      /* tableWidth: {
        renderDOM: ({ tableWidth }) => {
          if (!tableWidth) return {};
          const { width, type = 'auto' } = tableWidth;
          return { 
            style: `width: ${width}px` 
          };
        },
      }, */
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      /**
       * @category Attribute
       * @param {TableIndent} [tableIndent] - Table indentation configuration
       */
      tableIndent: {
        renderDOM: ({ tableIndent }) => {
          if (!tableIndent) return {};
          const { width } = tableIndent;
          let style = '';
          if (width) style += `margin-left: ${width}px`;
          return {
            style,
          };
        },
      },
      /**
       * @category Attribute
       * @param {import("./tableHelpers/createTableBorders.js").TableBorders} [borders] - Border styling for this table
       */
      borders: {
        default: {},
        renderDOM({ borders }) {
          if (!borders) return {};
          const style = Object.entries(borders).reduce((acc, [key2, { size, color }]) => {
            return `${acc}border-${key2}: ${Math.ceil(size)}px solid ${color || 'black'};`;
          }, '');
          return {
            style,
          };
        },
      },
      /**
       * @category Attribute
       * @param {string} [borderCollapse='collapse'] - CSS border-collapse property
       */
      borderCollapse: {
        default: null,
        renderDOM({ borderCollapse }) {
          return {
            style: `border-collapse: ${borderCollapse || 'collapse'}`,
          };
        },
      },
      /**
       * @category Attribute
       * @param {string} [justification] - Table alignment ('left', 'center', 'right')
       */
      justification: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.justification) return {};
          if (attrs.justification === 'center') {
            return { style: `margin: 0 auto` };
          }
          if (attrs.justification === 'right') {
            return { style: `margin-left: auto` };
          }
          return {};
        },
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableStyleId] - Internal reference to table style (not user-configurable)
       */
      tableStyleId: {
        rendered: false,
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableLayout] - CSS table-layout property (advanced usage)
       */
      tableLayout: {
        rendered: false,
      },
      /**
       * @category Attribute
       * @param {number} [tableCellSpacing] - Cell spacing in pixels for this table
       */
      tableCellSpacing: {
        default: null,
        rendered: false,
      },
      /**
       * @category Attribute
       * @param {TableProperties} [tableProperties] - Properties for the table.
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 371-483
       */
      tableProperties: {
        default: null,
        rendered: false,
      },
      /**
       * @category Attribute
       * @param {TableGrid} [grid] - Grid definition for the table
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 432
       */
      grid: {
        default: null,
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'table' }];
  },
  renderDOM({ node, htmlAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
    const attrs = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
      style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`,
    });
    const table = ['table', attrs, colgroup, ['tbody', 0]];
    return table;
  },
  addCommands() {
    return {
      /**
       * Append multiple rows to the end of a table in a single transaction.
       * @category Command
       * @param {appendRowsWithContentOptions} options - Append configuration
       * @example
       * editor.commands.appendRowsWithContent({ tablePos, valueRows: [['A','B'], ['C','D']], copyRowStyle: true })
       */
      appendRowsWithContent:
        ({ tablePos, tableNode, valueRows = [], copyRowStyle = false }) =>
        ({ editor, chain }) => {
          if ((typeof tablePos !== 'number' && !tableNode) || !Array.isArray(valueRows) || !valueRows.length) {
            return false;
          }
          return chain()
            .command(({ tr, dispatch }) => {
              const workingTable = resolveTable(tr, tablePos, tableNode);
              if (!workingTable) return false;
              const templateRow = pickTemplateRowForAppend(workingTable, editor.schema);
              if (!templateRow) return false;
              const newRows = valueRows
                .map((vals) =>
                  buildRowFromTemplateRow({
                    schema: editor.schema,
                    tableNode: workingTable,
                    templateRow,
                    values: vals,
                    copyRowStyle,
                  }),
                )
                .filter(Boolean);
              if (!newRows.length) return false;
              let resolvedTablePos = tablePos;
              if (typeof resolvedTablePos !== 'number' && workingTable) {
                const tables = editor.getNodesOfType('table');
                const match = workingTable ? tables.find((t) => t.node.eq(workingTable)) : tables[0];
                resolvedTablePos = match?.pos ?? null;
              }
              if (typeof resolvedTablePos !== 'number') {
                return false;
              }
              if (dispatch) {
                insertRowsAtTableEnd({ tr, tablePos, tableNode: workingTable, rows: newRows });
              }
              return true;
            })
            .run();
        },
      /**
       * Insert a new table into the document
       * @category Command
       * @param {TableConfig} [config] - Table configuration options
       * @example
       * editor.commands.insertTable()
       * editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })
       */
      insertTable:
        ({ rows = 3, cols = 3, withHeaderRow = false } = {}) =>
        ({ tr, dispatch, editor }) => {
          const node = createTable(editor.schema, rows, cols, withHeaderRow);
          if (dispatch) {
            const offset = tr.selection.from + 1;
            tr.replaceSelectionWith(node)
              .scrollIntoView()
              .setSelection(TextSelection.near(tr.doc.resolve(offset)));
          }
          return true;
        },
      /**
       * Delete the entire table containing the cursor
       * @category Command
       * @example
       * editor.commands.deleteTable()
       */
      deleteTable:
        () =>
        ({ state, dispatch }) => {
          return deleteTable(state, dispatch);
        },
      /**
       * Add a column before the current column
       * @category Command
       * @example
       * editor.commands.addColumnBefore()
       * @note Preserves cell attributes from current column
       */
      addColumnBefore:
        () =>
        ({ state, dispatch, chain }) => {
          if (!addColumnBefore(state)) return false;
          let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
          return chain()
            .command(() => addColumnBefore(state, dispatch))
            .command(({ tr }) => {
              let table = tr.doc.nodeAt(rect.tableStart - 1);
              if (!table) return false;
              let updatedMap = TableMap.get(table);
              let newColumnIndex = rect.left;
              if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
                return false;
              }
              for (let row = 0; row < updatedMap.height; row++) {
                let cellIndex = row * updatedMap.width + newColumnIndex;
                let cellPos = updatedMap.map[cellIndex];
                let cellAbsolutePos = rect.tableStart + cellPos;
                let cell = tr.doc.nodeAt(cellAbsolutePos);
                if (cell) {
                  let attrs = {
                    ...currentCellAttrs,
                    colspan: cell.attrs.colspan,
                    rowspan: cell.attrs.rowspan,
                    colwidth: cell.attrs.colwidth,
                  };
                  tr.setNodeMarkup(cellAbsolutePos, null, attrs);
                }
              }
              return true;
            })
            .run();
        },
      /**
       * Add a column after the current column
       * @category Command
       * @returns {Function} Command
       * @example
       * addColumnAfter()
       * @note Preserves cell attributes from current column
       */
      addColumnAfter:
        () =>
        ({ state, dispatch, chain }) => {
          if (!addColumnAfter(state)) return false;
          let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
          return chain()
            .command(() => addColumnAfter(state, dispatch))
            .command(({ tr }) => {
              let table = tr.doc.nodeAt(rect.tableStart - 1);
              if (!table) return false;
              let updatedMap = TableMap.get(table);
              let newColumnIndex = rect.left + 1;
              if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
                return false;
              }
              for (let row = 0; row < updatedMap.height; row++) {
                let cellIndex = row * updatedMap.width + newColumnIndex;
                let cellPos = updatedMap.map[cellIndex];
                let cellAbsolutePos = rect.tableStart + cellPos;
                let cell = tr.doc.nodeAt(cellAbsolutePos);
                if (cell) {
                  let attrs = {
                    ...currentCellAttrs,
                    colspan: cell.attrs.colspan,
                    rowspan: cell.attrs.rowspan,
                    colwidth: cell.attrs.colwidth,
                  };
                  tr.setNodeMarkup(cellAbsolutePos, null, attrs);
                }
              }
              return true;
            })
            .run();
        },
      /**
       * Delete the column containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteColumn()
       */
      deleteColumn:
        () =>
        ({ state, dispatch }) => {
          return deleteColumn(state, dispatch);
        },
      /**
       * Add a row before the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowBefore()
       * @note Preserves cell attributes from current row
       */
      addRowBefore:
        () =>
        ({ state, dispatch, chain }) => {
          if (!addRowBefore(state)) return false;
          let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
          return chain()
            .command(() => addRowBefore(state, dispatch))
            .command(({ tr }) => {
              let table = tr.doc.nodeAt(rect.tableStart - 1);
              if (!table) return false;
              let updatedMap = TableMap.get(table);
              let newRowIndex = rect.top;
              if (newRowIndex < 0 || newRowIndex >= updatedMap.height) {
                return false;
              }
              for (let col = 0; col < updatedMap.width; col++) {
                let cellIndex = newRowIndex * updatedMap.width + col;
                let cellPos = updatedMap.map[cellIndex];
                let cellAbsolutePos = rect.tableStart + cellPos;
                let cell = tr.doc.nodeAt(cellAbsolutePos);
                if (cell) {
                  let attrs = {
                    ...currentCellAttrs,
                    colspan: cell.attrs.colspan,
                    rowspan: cell.attrs.rowspan,
                    colwidth: cell.attrs.colwidth,
                  };
                  tr.setNodeMarkup(cellAbsolutePos, null, attrs);
                }
              }
              return true;
            })
            .run();
        },
      /**
       * Add a row after the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowAfter()
       * @note Preserves cell attributes from current row
       */
      addRowAfter:
        () =>
        ({ state, dispatch, chain }) => {
          if (!addRowAfter(state)) return false;
          let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
          return chain()
            .command(() => addRowAfter(state, dispatch))
            .command(({ tr }) => {
              let table = tr.doc.nodeAt(rect.tableStart - 1);
              if (!table) return false;
              let updatedMap = TableMap.get(table);
              let newRowIndex = rect.top + 1;
              if (newRowIndex >= updatedMap.height) return false;
              for (let col = 0; col < updatedMap.width; col++) {
                let cellIndex = newRowIndex * updatedMap.width + col;
                let cellPos = updatedMap.map[cellIndex];
                let cellAbsolutePos = rect.tableStart + cellPos;
                let cell = tr.doc.nodeAt(cellAbsolutePos);
                if (cell) {
                  let attrs = {
                    ...currentCellAttrs,
                    colspan: cell.attrs.colspan,
                    rowspan: cell.attrs.rowspan,
                    colwidth: cell.attrs.colwidth,
                  };
                  tr.setNodeMarkup(cellAbsolutePos, null, attrs);
                }
              }
              return true;
            })
            .run();
        },
      /**
       * Delete the row containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteRow()
       */
      deleteRow:
        () =>
        ({ state, dispatch }) => {
          return deleteRow(state, dispatch);
        },
      /**
       * Merge selected cells into one
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeCells()
       * @note Content from all cells is preserved
       */
      mergeCells:
        () =>
        ({ state, dispatch }) => {
          return mergeCells(state, dispatch);
        },
      /**
       * Split a merged cell back into individual cells
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitCell()
       */
      splitCell:
        () =>
        ({ state, dispatch, commands: commands2 }) => {
          if (splitCell(state, dispatch)) {
            return true;
          }
          return commands2.splitSingleCell();
        },
      /**
       * Split a single unmerged cell into two cells horizontally
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitSingleCell()
       * @note This command splits a single cell (not merged) into two cells by:
       * - Dividing the cell width in half
       * - Inserting a new cell to the right
       * - Adjusting colspan for cells in other rows that span this column
       * - Only works on cells with colspan=1 and rowspan=1
       * @note Different from splitCell which splits merged cells back to original cells
       */
      splitSingleCell:
        () =>
        ({ state, dispatch, tr }) => {
          const sel = state.selection;
          let cellNode;
          let cellPos;
          if (!(sel instanceof CellSelection)) {
            cellNode = cellWrapping(sel.$from);
            if (!cellNode) return false;
            cellPos = cellAround(sel.$from)?.pos;
          } else {
            if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
            cellNode = sel.$anchorCell.nodeAfter;
            cellPos = sel.$anchorCell.pos;
          }
          if (cellNode == null || cellPos == null) {
            return false;
          }
          if (cellNode.attrs.colspan != 1 || cellNode.attrs.rowspan != 1) {
            return false;
          }
          if (dispatch) {
            let rect = selectedRect(state);
            let currentRow = rect.top;
            let currentCol = rect.left;
            let baseAttrs = { ...cellNode.attrs };
            let currentColWidth = baseAttrs.colwidth;
            let newCellWidth = null;
            if (currentColWidth && currentColWidth[0]) {
              newCellWidth = Math.ceil(currentColWidth[0] / 2);
            }
            if (newCellWidth) {
              tr.setNodeMarkup(tr.mapping.map(cellPos, 1), null, { ...baseAttrs, colwidth: [newCellWidth] });
            }
            const newCellAttrs = { ...baseAttrs, colwidth: newCellWidth ? [newCellWidth] : null };
            const newCell = getCellType({ node: cellNode, state }).createAndFill(newCellAttrs);
            tr.insert(tr.mapping.map(cellPos + cellNode.nodeSize, 1), newCell);
            for (let row = 0; row < rect.map.height; row++) {
              if (row === currentRow) continue;
              let rowCells = /* @__PURE__ */ new Set();
              for (let col = 0; col < rect.map.width; col++) {
                let cellIndex = rect.map.map[row * rect.map.width + col];
                if (cellIndex != null) rowCells.add(cellIndex);
              }
              [...rowCells].forEach((cellIndex) => {
                let cellRect = rect.map.findCell(cellIndex);
                if (cellRect.left <= currentCol && cellRect.right > currentCol) {
                  let cellPos2 = tr.mapping.map(rect.tableStart + cellIndex, 1);
                  let cell = tr.doc.nodeAt(cellPos2);
                  if (cell) {
                    let newColspan = (cell.attrs.colspan || 1) + 1;
                    let updatedColwidth = cell.attrs.colwidth;
                    if (updatedColwidth && newCellWidth) {
                      let originalColIndex = currentCol - cellRect.left;
                      updatedColwidth = [
                        ...updatedColwidth.slice(0, originalColIndex),
                        newCellWidth,
                        // current cell width
                        newCellWidth,
                        // new cell width
                        ...updatedColwidth.slice(originalColIndex + 1),
                      ];
                    }
                    let cellAttrs = { ...cell.attrs, colspan: newColspan, colwidth: updatedColwidth };
                    tr.setNodeMarkup(cellPos2, null, cellAttrs);
                  }
                }
              });
            }
          }
          return true;
        },
      /**
       * Toggle between merge and split cells based on selection
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeOrSplit()
       * @note Merges if multiple cells selected, splits if merged cell selected
       */
      mergeOrSplit:
        () =>
        ({ state, dispatch, commands: commands2 }) => {
          if (mergeCells(state, dispatch)) {
            return true;
          }
          return commands2.splitCell();
        },
      /**
       * Toggle the first column as header column
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderColumn()
       */
      toggleHeaderColumn:
        () =>
        ({ state, dispatch }) => {
          return toggleHeader('column')(state, dispatch);
        },
      /**
       * Toggle the first row as header row
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderRow()
       */
      toggleHeaderRow:
        () =>
        ({ state, dispatch }) => {
          return toggleHeader('row')(state, dispatch);
        },
      /**
       * Toggle current cell as header cell
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderCell()
       */
      toggleHeaderCell:
        () =>
        ({ state, dispatch }) => {
          return toggleHeaderCell(state, dispatch);
        },
      /**
       * Set an attribute on selected cells
       * @category Command
       * @param {string} name - Attribute name
       * @param {*} value - Attribute value
       * @returns {Function} Command
       * @example
       * setCellAttr('background', { color: 'ff0000' })
       * setCellAttr('verticalAlign', 'middle')
       */
      setCellAttr:
        (name, value) =>
        ({ state, dispatch }) => {
          return setCellAttr(name, value)(state, dispatch);
        },
      /**
       * Navigate to the next cell (Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToNextCell()
       */
      goToNextCell:
        () =>
        ({ state, dispatch }) => {
          return goToNextCell(1)(state, dispatch);
        },
      /**
       * Navigate to the previous cell (Shift+Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToPreviousCell()
       */
      goToPreviousCell:
        () =>
        ({ state, dispatch }) => {
          return goToNextCell(-1)(state, dispatch);
        },
      /**
       * Fix table structure inconsistencies
       * @category Command
       * @returns {Function} Command
       * @example
       * fixTables()
       * @note Repairs malformed tables and normalizes structure
       */
      fixTables:
        () =>
        ({ state, dispatch }) => {
          if (dispatch) {
            fixTables(state);
          }
          return true;
        },
      /**
       * Set cell selection programmatically
       * @category Command
       * @param {CellSelectionPosition} pos - Cell selection coordinates
       * @returns {Function} Command
       * @example
       * setCellSelection({ anchorCell: 10, headCell: 15 })
       */
      setCellSelection:
        (pos) =>
        ({ tr, dispatch }) => {
          if (dispatch) {
            tr.setSelection(CellSelection.create(tr.doc, pos.anchorCell, pos.headCell));
          }
          return true;
        },
      /**
       * Set background color for selected cells
       * @category Command
       * @param {string} value - Color value (hex with or without #)
       * @example
       * editor.commands.setCellBackground('#ff0000')
       * editor.commands.setCellBackground('ff0000')
       */
      setCellBackground:
        (value) =>
        ({ editor, commands: commands2, dispatch }) => {
          const { selection } = editor.state;
          if (!isCellSelection(selection)) {
            return false;
          }
          const color = value?.startsWith('#') ? value.slice(1) : value;
          if (dispatch) {
            return commands2.setCellAttr('background', { color });
          }
          return true;
        },
      /**
       * Remove all borders from table and its cells
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteCellAndTableBorders()
       * @note Sets all border sizes to 0
       */
      deleteCellAndTableBorders:
        () =>
        ({ state, tr }) => {
          if (!isInTable(state)) {
            return false;
          }
          const table = findParentNode((node) => node.type.name === this.name)(state.selection);
          if (!table) {
            return false;
          }
          const from = table.pos;
          const to = table.pos + table.node.nodeSize;
          state.doc.nodesBetween(from, to, (node, pos) => {
            if (['tableCell', 'tableHeader'].includes(node.type.name)) {
              tr.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                borders: createCellBorders({ size: 0 }),
              });
            }
          });
          tr.setNodeMarkup(table.pos, void 0, {
            ...table.node.attrs,
            borders: createTableBorders({ size: 0 }),
          });
          return true;
        },
    };
  },
  addShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenSelected,
      'Mod-Backspace': deleteTableWhenSelected,
      Delete: deleteTableWhenSelected,
      'Mod-Delete': deleteTableWhenSelected,
    };
  },
  addPmPlugins() {
    const resizable = this.options.resizable && this.editor.isEditable;
    return [
      ...(resizable
        ? [
            columnResizing({
              handleWidth: this.options.handleWidth,
              cellMinWidth: this.options.cellMinWidth,
              defaultCellMinWidth: this.options.cellMinWidth,
              lastColumnResizable: this.options.lastColumnResizable,
              View: createTableView({
                editor: this.editor,
              }),
            }),
          ]
        : []),
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection,
      }),
    ];
  },
  extendNodeSchema(extension) {
    return {
      tableRole: callOrGet(
        getExtensionConfigField(extension, 'tableRole', {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
        }),
      ),
    };
  },
});
function getCellType({ node, state }) {
  const nodeTypes = tableNodeTypes(state.schema);
  return nodeTypes[node.type.spec.tableRole];
}
function copyCellAttrs(node) {
  const { colspan, rowspan, colwidth, ...attrs } = node.attrs;
  return attrs;
}
function getCurrentCellAttrs(state) {
  let rect = selectedRect(state);
  let index = rect.top * rect.map.width + rect.left;
  let pos = rect.map.map[index];
  let cell = rect.table.nodeAt(pos);
  let attrs = copyCellAttrs(cell);
  return { rect, cell, attrs };
}
const TableHeader = Node$1.create({
  name: 'tableHeader',
  content: 'block+',
  tableRole: 'header_cell',
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        'aria-label': 'Table head node',
      },
    };
  },
  addAttributes() {
    return {
      colspan: {
        default: 1,
      },
      rowspan: {
        default: 1,
      },
      colwidth: {
        default: null,
        parseDOM: (element) => {
          const colwidth = element.getAttribute('data-colwidth');
          const value = colwidth ? colwidth.split(',').map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            'data-colwidth': attrs.colwidth.join(','),
          };
        },
      },
      __placeholder: {
        default: null,
        parseDOM: (element) => {
          const value = element.getAttribute('data-placeholder');
          return value || null;
        },
        renderDOM({ __placeholder }) {
          if (!__placeholder) return {};
          return {
            'data-placeholder': __placeholder,
          };
        },
      },
    };
  },
  parseDOM() {
    return [{ tag: 'th' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['th', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
const TableRow = Node$1.create({
  name: 'tableRow',
  content: '(tableCell | tableHeader)*',
  tableRole: 'row',
  addOptions() {
    return {
      htmlAttributes: {
        'aria-label': 'Table row node',
      },
    };
  },
  addAttributes() {
    return {
      rowHeight: {
        renderDOM({ rowHeight }) {
          if (!rowHeight) return {};
          const style = `height: ${rowHeight}px`;
          return { style };
        },
      },
      cantSplit: {
        default: false,
        parseDOM() {
          return {};
        },
        renderDOM({ cantSplit }) {
          if (!cantSplit) return {};
          return { 'data-cant-split': 'true' };
        },
      },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 377-482
       */
      tableRowProperties: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 472
       */
      rsidDel: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 472
       */
      rsidR: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 473
       */
      rsidRPr: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 473
       */
      rsidTr: { rendered: false },
      /**
       * @see {@link https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/a0e7d2e2-2246-44c6-96e8-1cf009823615}
       */
      paraId: { rendered: false },
      /**
       * @see {@link https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b7eeddec-7c50-47fb-88b6-1feec3ed832c}
       */
      textId: { rendered: false },
    };
  },
  parseDOM() {
    return [{ tag: 'tr' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['tr', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
const TableCell = Node$1.create({
  name: 'tableCell',
  content: 'block+',
  tableRole: 'cell',
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        'aria-label': 'Table cell node',
      },
    };
  },
  addAttributes() {
    return {
      colspan: {
        default: 1,
      },
      rowspan: {
        default: 1,
      },
      colwidth: {
        default: [100],
        parseDOM: (elem) => {
          const colwidth = elem.getAttribute('data-colwidth');
          const value = colwidth ? colwidth.split(',').map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            'data-colwidth': attrs.colwidth.join(','),
          };
        },
      },
      background: {
        renderDOM({ background }) {
          if (!background) return {};
          const { color } = background || {};
          const style = `background-color: ${color ? `#${color}` : 'transparent'}`;
          return { style };
        },
      },
      verticalAlign: {
        renderDOM({ verticalAlign }) {
          if (!verticalAlign) return {};
          const style = `vertical-align: ${verticalAlign}`;
          return { style };
        },
      },
      cellMargins: {
        renderDOM({ cellMargins }) {
          if (!cellMargins) return {};
          const sides = ['top', 'right', 'bottom', 'left'];
          const style = sides
            .map((side) => {
              const margin = cellMargins?.[side];
              if (margin) return `padding-${side}: ${margin}px;`;
              return '';
            })
            .join(' ');
          return { style };
        },
      },
      borders: {
        default: () => createCellBorders(),
        renderDOM({ borders }) {
          if (!borders) return {};
          const sides = ['top', 'right', 'bottom', 'left'];
          const style = sides
            .map((side) => {
              const border = borders?.[side];
              if (border && border.val === 'none') return `border-${side}: ${border.val};`;
              if (border) return `border-${side}: ${Math.ceil(border.size)}px solid ${border.color || 'black'};`;
              return '';
            })
            .join(' ');
          return { style };
        },
      },
      widthType: {
        default: 'auto',
        rendered: false,
      },
      widthUnit: {
        default: 'px',
        rendered: false,
      },
      __placeholder: {
        default: null,
        parseDOM: (element) => {
          const value = element.getAttribute('data-placeholder');
          return value || null;
        },
        renderDOM({ __placeholder }) {
          if (!__placeholder) return {};
          return {
            'data-placeholder': __placeholder,
          };
        },
      },
      /**
       * @category Attribute
       * @param {TableCellProperties} tableCellProperties - Properties for the table cell.
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 463
       */
      tableCellProperties: {
        default: null,
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'td' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['td', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
class FieldAnnotationView {
  constructor(options) {
    __privateAdd(this, _FieldAnnotationView_instances);
    __publicField(this, 'editor');
    __publicField(this, 'node');
    __publicField(this, 'decorations');
    __publicField(this, 'getPos');
    __publicField(this, 'htmlAttributes');
    __publicField(this, 'dom');
    __publicField(this, 'annotationClass');
    __publicField(this, 'annotationContentClass');
    __publicField(this, 'borderColor');
    this.editor = options.editor;
    this.node = options.node;
    this.decorations = options.decorations;
    this.getPos = options.getPos;
    this.htmlAttributes = options.htmlAttributes;
    this.annotationClass = options.annotationClass;
    this.annotationContentClass = options.annotationContentClass;
    this.borderColor = options.borderColor;
    this.handleAnnotationClick = this.handleAnnotationClick.bind(this);
    this.handleAnnotationDoubleClick = this.handleAnnotationDoubleClick.bind(this);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.buildView();
    this.attachEventListeners();
  }
  buildView() {
    let { type } = this.node.attrs;
    let handlers = {
      text: (...args) => this.buildTextView(...args),
      image: (...args) => this.buildImageView(...args),
      signature: (...args) => this.buildSignatureView(...args),
      checkbox: (...args) => this.buildCheckboxView(...args),
      html: (...args) => this.buildHTMLView(...args),
      link: (...args) => this.buildLinkView(...args),
      default: (...args) => this.buildTextView(...args),
    };
    let buildHandler = handlers[type] ?? handlers.default;
    buildHandler();
  }
  buildTextView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this, {
      displayLabel,
    });
    this.dom = annotation;
  }
  buildImageView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (imageSrc) {
      let img = document.createElement('img');
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = 'auto';
      img.style.maxWidth = '100%';
      img.style.pointerEvents = 'none';
      img.style.verticalAlign = 'middle';
      content.append(img);
      annotation.style.display = 'inline-block';
      content.style.display = 'inline-block';
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildSignatureView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    displayLabel = displayLabel || 'Signature';
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (imageSrc) {
      let img = document.createElement('img');
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = 'auto';
      img.style.maxWidth = '100%';
      img.style.maxHeight = '28px';
      img.style.pointerEvents = 'none';
      img.style.verticalAlign = 'middle';
      content.append(img);
      annotation.style.display = 'inline-block';
      content.style.display = 'inline-block';
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildCheckboxView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this, {
      displayLabel,
    });
    this.dom = annotation;
  }
  buildHTMLView() {
    let { displayLabel, rawHtml } = this.node.attrs;
    if (!this.editor.options.isHeadless && !!rawHtml) {
      try {
        const tempDiv = document.createElement('div');
        const childEditor = this.editor.createChildEditor({
          element: tempDiv,
          html: rawHtml,
        });
        rawHtml = childEditor.view.dom.innerHTML;
      } catch (error) {
        console.warn('Error parsing HTML in FieldAnnotationView:', error);
      }
    }
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (rawHtml) {
      content.innerHTML = rawHtml.trim();
      annotation.style.display = 'inline-block';
      content.style.display = 'inline-block';
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildLinkView() {
    let { displayLabel, linkUrl } = this.node.attrs;
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (linkUrl) {
      let link = document.createElement('a');
      link.href = linkUrl;
      link.target = '_blank';
      link.textContent = linkUrl;
      link.style.textDecoration = 'none';
      content.append(link);
      content.style.pointerEvents = 'all';
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  attachEventListeners() {
    this.dom.addEventListener('click', this.handleAnnotationClick);
    this.dom.addEventListener('dblclick', this.handleAnnotationDoubleClick);
    this.editor.on('selectionUpdate', this.handleSelectionUpdate);
  }
  removeEventListeners() {
    this.dom.removeEventListener('click', this.handleAnnotationClick);
    this.dom.removeEventListener('dblclick', this.handleAnnotationDoubleClick);
    this.editor.off('selectionUpdate', this.handleSelectionUpdate);
  }
  handleSelectionUpdate({ editor }) {
    if (!this.editor.isEditable) {
      return;
    }
    let { selection } = editor.state;
    if (selection instanceof NodeSelection) {
      let currentNode = selection.node;
      if (this.node.eq(currentNode)) {
        this.editor.emit('fieldAnnotationSelected', {
          editor: this.editor,
          node: this.node,
          nodePos: this.getPos(),
          target: this.dom,
        });
      }
    }
  }
  handleAnnotationClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit('fieldAnnotationClicked', {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget,
    });
  }
  handleAnnotationDoubleClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit('fieldAnnotationDoubleClicked', {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget,
    });
  }
  stopEvent(event) {
    if (!this.editor.isEditable) {
      event.preventDefault();
      return true;
    }
    return false;
  }
  // Can be used to manually update the NodeView.
  // Otherwise the NodeView is recreated.
  update() {
    return false;
  }
  ignoreMutation() {
    return true;
  }
  destroy() {
    this.removeEventListeners();
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr }) => {
      tr.setNodeMarkup(this.getPos(), void 0, {
        ...this.node.attrs,
        ...attributes,
      });
      return true;
    });
  }
}
_FieldAnnotationView_instances = new WeakSet();
createAnnotation_fn = function ({ displayLabel } = {}) {
  let { highlighted } = this.node.attrs;
  let annotation = document.createElement('span');
  annotation.classList.add(this.annotationClass);
  let content = document.createElement('span');
  content.classList.add(this.annotationContentClass);
  content.style.pointerEvents = 'none';
  content.contentEditable = 'false';
  if (displayLabel) {
    content.textContent = displayLabel;
  }
  annotation.append(content);
  let omitHighlight = highlighted === false;
  let styles = [
    `border: 2px solid ${this.borderColor}`,
    `border-radius: 2px`,
    `padding: 1px 2px`,
    `box-sizing: border-box`,
  ];
  let annotationStyle = styles.join('; ');
  let mergedAttrs = Attribute.mergeAttributes(this.htmlAttributes, {
    style: omitHighlight ? '' : annotationStyle,
  });
  for (let [key2, value] of Object.entries(mergedAttrs)) {
    if (key2 === 'style') {
      annotation.style.cssText = value;
    } else {
      annotation.setAttribute(key2, value);
    }
  }
  return {
    annotation,
    content,
  };
};
const mergeRanges = (ranges) => {
  if (ranges.length === 0) return [];
  const sorted = [...ranges].sort((a, b) => a[0] - b[0]).map((range) => [...range]);
  const merged = [sorted[0]];
  for (let i = 1; i < sorted.length; i++) {
    const current = sorted[i];
    const lastMerged = merged[merged.length - 1];
    if (current[0] <= lastMerged[1]) {
      lastMerged[1] = Math.max(lastMerged[1], current[1]);
    } else {
      merged.push(current);
    }
  }
  return merged;
};
const clampRange = (start, end, docSize) => {
  const safeStart = Math.max(0, Math.min(start, docSize));
  const safeEnd = Math.max(0, Math.min(end, docSize));
  if (safeStart >= safeEnd) {
    return null;
  }
  return [safeStart, safeEnd];
};
const FieldAnnotationPlugin = (options = {}) => {
  let { editor, annotationClass: annotationClass2 } = options;
  return new Plugin({
    key: new PluginKey('fieldAnnotation'),
    state: {
      init() {
        return null;
      },
      apply(tr, prevState) {
        trackFieldAnnotationsDeletion(editor, tr);
        return prevState;
      },
    },
    props: {
      handleDrop(view, event, slice, moved) {
        if (moved) return false;
        let fieldAnnotation = event?.dataTransfer.getData('fieldAnnotation');
        if (fieldAnnotation) {
          if (options.handleDropOutside) {
            handleDropOutside({
              fieldAnnotation,
              editor,
              view,
              event,
            });
          } else {
            let annotationAttrs;
            try {
              let fieldAnnotationObj = JSON.parse(fieldAnnotation);
              annotationAttrs = fieldAnnotationObj.attributes;
            } catch {
              return false;
            }
            const coordinates = view.posAtCoords({
              left: event.clientX,
              top: event.clientY,
            });
            if (coordinates) {
              editor.commands.addFieldAnnotation(coordinates.pos, {
                ...annotationAttrs,
              });
            }
          }
          return true;
        }
        return false;
      },
      handlePaste(view, event, slice) {
        const content = slice.content.content.filter((item) => item.type.name === 'fieldAnnotation');
        if (content.length) {
          editor.emit('fieldAnnotationPaste', {
            content,
            editor,
          });
        }
        return false;
      },
      handleDOMEvents: {
        dragstart: (view, event) => {
          if (!event.target) return false;
          let { target } = event;
          let isAnnotationField = target.classList?.contains(annotationClass2);
          if (isAnnotationField) {
            event.dataTransfer?.setDragImage(target, 0, 0);
          }
          return false;
        },
        // drop: (view, event) => {
        //   console.log({ view, event });
        // },
      },
    },
    /// For y-prosemirror support.
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      const affectedRanges = [];
      let hasFieldAnnotationsInSlice = false;
      let hasSteps = false;
      transactions.forEach((transaction) => {
        if (!transaction.steps) return;
        hasSteps = true;
        transaction.steps.forEach((step) => {
          if (step.slice?.content) {
            step.slice.content.descendants((node) => {
              if (node.type.name === 'fieldAnnotation') {
                hasFieldAnnotationsInSlice = true;
                return false;
              }
            });
          }
          if (typeof step.from === 'number' && typeof step.to === 'number') {
            const from = step.from;
            const to = step.from === step.to && step.slice?.size ? step.from + step.slice.size : step.to;
            affectedRanges.push([from, to]);
          }
        });
      });
      if (hasSteps && !hasFieldAnnotationsInSlice && affectedRanges.length > 0) {
        const mergedRanges = mergeRanges(affectedRanges);
        let hasExistingAnnotations = false;
        for (const [start, end] of mergedRanges) {
          const clampedRange = clampRange(start, end, newState.doc.content.size);
          if (!clampedRange) continue;
          const [validStart, validEnd] = clampedRange;
          try {
            newState.doc.nodesBetween(validStart, validEnd, (node) => {
              if (node.type.name === 'fieldAnnotation') {
                hasExistingAnnotations = true;
                return false;
              }
            });
          } catch (error) {
            console.warn('FieldAnnotationPlugin: range check failed, assuming annotations exist', error);
            hasExistingAnnotations = true;
            break;
          }
          if (hasExistingAnnotations) break;
        }
        if (!hasExistingAnnotations) {
          return;
        }
      }
      const { tr } = newState;
      let changed = false;
      const removeMarksFromAnnotation = (node, pos) => {
        const { marks } = node;
        const currentNode = tr.doc.nodeAt(pos);
        if (marks.length > 0 && node.eq(currentNode)) {
          tr.removeMark(pos, pos + node.nodeSize, null);
          changed = true;
        }
      };
      if (affectedRanges.length > 0) {
        const mergedRanges = mergeRanges(affectedRanges);
        let shouldFallbackToFullScan = false;
        for (const [start, end] of mergedRanges) {
          const clampedRange = clampRange(start, end, newState.doc.content.size);
          if (!clampedRange) continue;
          const [validStart, validEnd] = clampedRange;
          try {
            newState.doc.nodesBetween(validStart, validEnd, (node, pos) => {
              if (node.type.name === 'fieldAnnotation') {
                removeMarksFromAnnotation(node, pos);
              }
            });
          } catch (error) {
            console.warn('FieldAnnotationPlugin: nodesBetween failed, falling back to full scan', error);
            shouldFallbackToFullScan = true;
            break;
          }
        }
        if (shouldFallbackToFullScan) {
          const annotations = getAllFieldAnnotations(newState);
          if (!annotations.length) {
            return changed ? tr : null;
          }
          annotations.forEach(({ node, pos }) => {
            removeMarksFromAnnotation(node, pos);
          });
        }
      } else {
        const annotations = getAllFieldAnnotations(newState);
        if (!annotations.length) {
          return;
        }
        annotations.forEach(({ node, pos }) => {
          removeMarksFromAnnotation(node, pos);
        });
      }
      return changed ? tr : null;
    },
    ///
  });
};
function handleDropOutside({ fieldAnnotation, editor, view, event }) {
  let sourceField;
  try {
    let fieldAnnotationObj = JSON.parse(fieldAnnotation);
    sourceField = fieldAnnotationObj.sourceField;
  } catch {
    return;
  }
  let coordinates = view.posAtCoords({
    left: event.clientX,
    top: event.clientY,
  });
  if (coordinates) {
    editor.emit('fieldAnnotationDropped', {
      sourceField,
      editor,
      coordinates,
      pos: coordinates.pos,
    });
  }
}
const cleanUpListsWithAnnotations =
  (fieldsToDelete = []) =>
  ({ dispatch, tr, state }) => {
    if (!dispatch) return true;
    if (!Array.isArray(fieldsToDelete)) fieldsToDelete = [fieldsToDelete];
    const { doc } = state;
    const docxAnnotations = getAllFieldAnnotations(state) || [];
    const nodesToDelete = [];
    fieldsToDelete.forEach((fieldId) => {
      const matched = docxAnnotations.find((a) => a.node.attrs.fieldId === fieldId);
      if (!matched) return;
      const listItem = findParentNodeClosestToPos(doc.resolve(matched.pos), (node2) => node2.type.name === 'listItem');
      if (!listItem) return;
      let remainingNodes = 0;
      listItem.node.descendants((node2) => {
        if (node2.type.name === 'fieldAnnotation') {
          remainingNodes += 1;
        }
      });
      let matchingNodesFound = 0;
      let hasOtherNodes = false;
      listItem.node.children.forEach((child) => {
        const { type } = child;
        if (type.name !== 'paragraph' && type.name !== 'fieldAnnotation') return;
        child.children.forEach((inline) => {
          const isFieldToDelete = fieldsToDelete.includes(inline.attrs.fieldId);
          const isFieldType = inline.type.name === 'fieldAnnotation';
          const isMatchingField = isFieldType && isFieldToDelete;
          if (!isFieldType && !isMatchingField) hasOtherNodes = true;
          if (isMatchingField) matchingNodesFound += 1;
        });
      });
      if (!hasOtherNodes && matchingNodesFound > 0) {
        remainingNodes -= matchingNodesFound;
      }
      if (remainingNodes > 0) {
        return;
      }
      let { pos, node, depth } = listItem;
      let $pos = doc.resolve(pos);
      while (depth > 0) {
        const parent = $pos.node(depth - 1);
        if (parent.childCount === 1) {
          depth -= 1;
          pos = $pos.before(depth);
          node = parent;
          $pos = doc.resolve(pos);
        } else {
          break;
        }
      }
      if (!nodesToDelete.some((n) => n.pos === pos)) {
        nodesToDelete.push({ pos, node });
      }
    });
    if (!nodesToDelete.length) return true;
    nodesToDelete
      .sort((a, b) => b.pos - a.pos)
      .forEach(({ pos, node }) => {
        tr.delete(pos, pos + node.nodeSize);
      });
    tr.setMeta('updateListSync', true);
    return true;
  };
const cleanUpListsCommands = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      cleanUpListsWithAnnotations,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
const cleanUpParagraphWithAnnotations =
  (fieldsToDelete = []) =>
  ({ dispatch, tr, state }) => {
    if (!dispatch) return true;
    const annotations =
      (typeof findFieldAnnotationsByFieldId === 'function'
        ? findFieldAnnotationsByFieldId(fieldsToDelete, state)
        : []) || [];
    const toDelete = /* @__PURE__ */ new Map();
    const sizeOf = (doc) => doc.content.size;
    const inRange = (doc, pos) => Number.isInteger(pos) && pos >= 0 && pos <= sizeOf(doc);
    for (const annotation of annotations) {
      const origPos = annotation && annotation.pos;
      if (!Number.isInteger(origPos)) continue;
      const mappedPos = tr.mapping.map(origPos, 1);
      if (!inRange(tr.doc, mappedPos)) continue;
      let $pos;
      try {
        $pos = tr.doc.resolve(mappedPos);
      } catch {
        continue;
      }
      const parent = $pos.parent;
      if (!parent) continue;
      if (parent.childCount >= 2) continue;
      const currentNode = tr.doc.nodeAt(mappedPos);
      const annotatedNode = annotation && annotation.node;
      if (!currentNode) continue;
      if (annotatedNode && !annotatedNode.sameMarkup?.(currentNode) && annotatedNode.type !== currentNode.type) {
        continue;
      }
      const parentPos = $pos.before();
      if (!inRange(tr.doc, parentPos)) continue;
      toDelete.set(parentPos, true);
    }
    if (toDelete.size === 0) return true;
    const sorted = [...toDelete.keys()].sort((a, b) => b - a);
    let changed = false;
    for (const originalParentPos of sorted) {
      const mappedParentPos = tr.mapping.map(originalParentPos, -1);
      if (!inRange(tr.doc, mappedParentPos)) continue;
      const targetNode = tr.doc.nodeAt(mappedParentPos);
      if (!targetNode) continue;
      const from = mappedParentPos;
      const to = mappedParentPos + targetNode.nodeSize;
      if (!inRange(tr.doc, from) || !inRange(tr.doc, to) || to <= from) continue;
      try {
        tr.delete(from, to);
        changed = true;
      } catch {
        continue;
      }
    }
    if (changed) dispatch(tr);
    return true;
  };
const cleanUpParagraphCommands = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      cleanUpParagraphWithAnnotations,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
const commands = {
  ...cleanUpListsCommands,
  ...cleanUpParagraphCommands,
};
const annotationClass = 'annotation';
const annotationContentClass = 'annotation-content';
const FieldAnnotation = Node$1.create({
  name: 'fieldAnnotation',
  group: 'inline',
  inline: true,
  atom: true,
  draggable: true,
  selectable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: annotationClass,
        'aria-label': 'Field annotation node',
      },
      annotationClass,
      annotationContentClass,
      types: ['text', 'image', 'signature', 'checkbox', 'html', 'link'],
      // annotation types
      defaultType: 'text',
      borderColor: '#b015b3',
      visibilityOptions: ['visible', 'hidden'],
      handleDropOutside: true,
      /// for y-prosemirror support
      toggleFormatNames: ['bold', 'italic', 'underline'],
    };
  },
  addAttributes() {
    return {
      type: {
        default: this.options.defaultType,
        parseDOM: (elem) => elem.getAttribute('data-type'),
        renderDOM: (attrs) => {
          if (!attrs.type) return {};
          return {
            'data-type': attrs.type,
          };
        },
      },
      defaultDisplayLabel: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-default-display-label'),
        renderDOM: (attrs) => {
          if (!attrs.defaultDisplayLabel) return {};
          return {
            'data-default-display-label': attrs.defaultDisplayLabel,
          };
        },
      },
      displayLabel: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-display-label'),
        renderDOM: (attrs) => {
          if (!attrs.displayLabel) return {};
          return {
            'data-display-label': attrs.displayLabel,
          };
        },
      },
      imageSrc: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let img = elem.querySelector('img');
          return img?.getAttribute('src') || null;
        },
      },
      rawHtml: {
        default: null,
        parseDOM: (elem) => {
          try {
            const isHtmlType = elem.getAttribute('data-type') === 'html';
            if (!isHtmlType) return null;
            return JSON.parse(elem.getAttribute('data-raw-html'));
          } catch (e) {
            console.warn('Paste parse error', e);
          }
          return null;
        },
        renderDOM: (attrs) => {
          if (!attrs.rawHtml) return {};
          return {
            'data-raw-html': JSON.stringify(attrs.rawHtml),
          };
        },
      },
      linkUrl: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let link = elem.querySelector('a');
          return link?.getAttribute('href') || null;
        },
      },
      fieldId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-field-id'),
        renderDOM: (attrs) => {
          if (!attrs.fieldId) return {};
          return {
            'data-field-id': attrs.fieldId,
          };
        },
      },
      fieldType: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-field-type'),
        renderDOM: (attrs) => {
          if (!attrs.fieldType) return {};
          return {
            'data-field-type': attrs.fieldType,
          };
        },
      },
      fieldColor: {
        default: '#980043',
        parseDOM: (elem) => elem.getAttribute('data-field-color') || elem.style.backgroundColor || null,
        renderDOM: (attrs) => {
          if (!attrs.fieldColor || attrs.fieldColor == 'None') return {};
          let hexColor = toHex(attrs.fieldColor);
          let isSixValueSyntax = hexColor.slice(1).length === 6;
          if (isSixValueSyntax) {
            hexColor = `${hexColor}33`;
          }
          let omitHighlight = attrs.highlighted === false;
          if (omitHighlight) {
            return {
              'data-field-color': hexColor,
            };
          }
          return {
            'data-field-color': hexColor,
            style: `background-color: ${hexColor}`,
          };
        },
      },
      hidden: {
        default: false,
        parseDOM: (elem) => {
          let hasHiddenAttr = elem.hasAttribute('hidden');
          let hasDisplayNoneStyle = elem.style.display === 'none';
          let isHidden = hasHiddenAttr || hasDisplayNoneStyle;
          return isHidden;
        },
        renderDOM: (attrs) => {
          if (!attrs.hidden) return {};
          return {
            style: 'display: none',
          };
        },
      },
      visibility: {
        default: 'visible',
        parseDOM: (el) => {
          let visibility = el.style.visibility || 'visible';
          let containsVisibility = this.options.visibilityOptions.includes(visibility);
          return containsVisibility ? visibility : 'visible';
        },
        renderDOM: (attrs) => {
          if (!attrs.visibility || attrs.visibility === 'visible') return {};
          return { style: `visibility: ${attrs.visibility}` };
        },
      },
      highlighted: {
        default: true,
        rendered: false,
      },
      multipleImage: {
        default: false,
        parseDOM: (elem) => elem.getAttribute('data-multiple-image'),
        renderDOM: (attrs) => {
          if (!attrs.multipleImage) return {};
          return {
            'data-multiple-image': attrs.multipleImage,
          };
        },
      },
      size: {
        default: null,
        renderDOM: ({ size }) => {
          if (!size || !size.width) return {};
          const style = `width: ${size.width}px; height: ${size.height}px; overflow: hidden;`;
          return { style };
        },
      },
      extras: {
        default: {},
        rendered: false,
      },
      /// Formatting attrs for y-prosemirror support.
      bold: {
        default: false,
        parseDOM: (elem) => elem.getAttribute('data-bold') === 'true',
        renderDOM: (attrs) => {
          if (!attrs.bold) return {};
          return {
            'data-bold': 'true',
            style: 'font-weight: bold',
          };
        },
      },
      italic: {
        default: false,
        parseDOM: (elem) => elem.getAttribute('data-italic') === 'true',
        renderDOM: (attrs) => {
          if (!attrs.italic) return {};
          return {
            'data-italic': 'true',
            style: 'font-style: italic',
          };
        },
      },
      underline: {
        default: false,
        parseDOM: (elem) => elem.getAttribute('data-underline') === 'true',
        renderDOM: (attrs) => {
          if (!attrs.underline) return {};
          return {
            'data-underline': 'true',
            style: 'text-decoration: underline',
          };
        },
      },
      fontFamily: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-font-family') || elem.style.fontFamily || null,
        renderDOM: (attrs) => {
          if (!attrs.fontFamily) return {};
          return {
            'data-font-family': attrs.fontFamily,
            style: `font-family: ${attrs.fontFamily}`,
          };
        },
      },
      fontSize: {
        default: null,
        parseDOM: (elem) => elem.getAttribute('data-font-size') || elem.style.fontSize || null,
        renderDOM: (attrs) => {
          if (!attrs.fontSize) return {};
          let [value, unit] = parseSizeUnit(attrs.fontSize);
          if (Number.isNaN(value)) return {};
          unit = unit ? unit : 'pt';
          let fontSize = `${value}${unit}`;
          return {
            'data-font-size': fontSize,
            style: `font-size: ${fontSize}`,
          };
        },
      },
      textHighlight: {
        default: null,
        parseDOM: (element) => element.getAttribute('data-text-highlight'),
        renderDOM: (attrs) => {
          if (!attrs.textHighlight) return {};
          return {
            'data-text-highlight': attrs.textHighlight,
            // takes precedence over the fieldColor.
            style: `background-color: ${attrs.textHighlight} !important`,
          };
        },
      },
      textColor: {
        default: null,
        parseDOM: (element) => element.getAttribute('data-text-color'),
        renderDOM: (attrs) => {
          if (!attrs.textColor) return {};
          return {
            'data-text-color': attrs.textColor,
            style: `color: ${attrs.textColor}`,
          };
        },
      },
      /// Formatting attrs - end.
      generatorIndex: {
        rendered: false,
        default: null,
      },
      hash: {
        rendered: false,
        default: null,
      },
      sdtId: {
        rendered: false,
        default: null,
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: `span.${this.options.annotationClass}`,
        priority: 60,
      },
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    let { type, displayLabel, imageSrc, linkUrl } = node.attrs;
    let textRenderer = () => {
      return [
        'span',
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          'span',
          {
            class: `${this.options.annotationContentClass}`,
          },
          displayLabel,
        ],
      ];
    };
    let imageRenderer = () => {
      let contentRenderer = () => {
        if (!imageSrc) return displayLabel;
        return [
          'img',
          {
            src: imageSrc,
            alt: displayLabel,
          },
        ];
      };
      return [
        'span',
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          'span',
          {
            class: `${this.options.annotationContentClass}`,
          },
          contentRenderer(),
        ],
      ];
    };
    let linkRenderer = () => {
      let contentRenderer = () => {
        if (!linkUrl) return displayLabel;
        return [
          'a',
          {
            href: linkUrl,
            target: '_blank',
          },
          linkUrl,
        ];
      };
      return [
        'span',
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          'span',
          {
            class: `${this.options.annotationContentClass}`,
          },
          contentRenderer(),
        ],
      ];
    };
    let renderers = {
      text: () => textRenderer(),
      image: () => imageRenderer(),
      signature: () => imageRenderer(),
      checkbox: () => textRenderer(),
      html: () => textRenderer(),
      link: () => linkRenderer(),
      default: () => textRenderer(),
    };
    let renderer = renderers[type] ?? renderers.default;
    return renderer();
  },
  addCommands() {
    const annotationTypes = this.options.types;
    return {
      /**
       * Add field annotation.
       * @param pos The position in the doc.
       * @param attrs The attributes.
       * @example
       * editor.commands.addFieldAnnotation(0, {
       *  displayLabel: 'Enter your info',
       *  fieldId: `123`,
       *  fieldType: 'TEXTINPUT',
       *  fieldColor: '#980043',
       * })
       */
      addFieldAnnotation:
        (pos, attrs = {}, editorFocus = false) =>
        ({ editor, dispatch, state, tr }) => {
          if (dispatch) {
            let { schema } = editor;
            let newPos = tr.mapping.map(pos);
            let $pos = state.doc.resolve(newPos);
            let currentMarks = $pos.marks();
            currentMarks = currentMarks.length ? [...currentMarks] : null;
            let formatAttrs = getFormatAttrsFromMarks(currentMarks);
            let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || '';
            let node = schema.nodes[this.name].create(
              {
                ...attrs,
                ...formatAttrs,
                defaultDisplayLabel,
                hash: attrs.hash || generateDocxRandomId(4),
              },
              null,
              null,
            );
            state.tr.insert(newPos, node).setSelection(Selection.near(tr.doc.resolve(newPos + node.nodeSize)));
            if (editorFocus) {
              this.editor.view.focus();
            }
          }
          return true;
        },
      addFieldAnnotationAtSelection:
        (attrs = {}, editorFocus = false) =>
        ({ state, commands: commands2 }) => {
          const { from } = state.selection;
          return commands2.addFieldAnnotation(from, attrs, editorFocus);
        },
      /**
       * Replace field annotation.
       * @param fieldsArray array of fields with attrs to add as annotation.
       * @example
       * editor.commands.replaceWithFieldAnnotation([
       *  from: 20,
       *  to: 45,
       *  attrs: {
       *    fieldType: 'TEXTINPUT'
       *    fieldColor: '#980043'
       *  }
       * ])
       */
      replaceWithFieldAnnotation:
        (fieldsArray) =>
        ({ editor, dispatch, tr }) => {
          if (!dispatch) return true;
          fieldsArray.forEach((annotation) => {
            let { from, to, attrs } = annotation;
            let { schema } = editor;
            let newPosFrom = tr.mapping.map(from);
            let newPosTo = tr.mapping.map(to);
            let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || '';
            attrs.hash = generateDocxRandomId(4);
            let node = schema.nodes[this.name].create(
              {
                ...attrs,
                defaultDisplayLabel,
                hash: attrs.hash || generateDocxRandomId(4),
              },
              null,
              null,
            );
            tr.replaceWith(newPosFrom, newPosTo, node);
          });
          return true;
        },
      /**
       * Replace annotations with a label (as text node) in selection.
       * @param options Additional options.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabelInSelection()
       */
      replaceFieldAnnotationsWithLabelInSelection:
        (options = {}) =>
        ({ commands: commands2 }) => {
          return commands2.replaceFieldAnnotationsWithLabel(null, {
            ...options,
            isInSelection: true,
          });
        },
      /**
       * Replace annotations with a label (as text node).
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param options.isInSelection Find in selection instead of field IDs.
       * @param options.addToHistory Add to history or not.
       * @param options.types Annotation types to replace.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabel(['1', '2'])
       */
      replaceFieldAnnotationsWithLabel:
        (fieldIdOrArray, { isInSelection = false, addToHistory = false, types = annotationTypes } = {}) =>
        ({ dispatch, state, tr }) => {
          let { from, to } = state.selection;
          let annotations = isInSelection
            ? findFieldAnnotationsBetween(from, to, state.doc)
            : findFieldAnnotationsByFieldId(fieldIdOrArray, state);
          annotations = types.length ? annotations.filter(({ node }) => types.includes(node.attrs.type)) : annotations;
          if (!annotations.length) {
            return true;
          }
          if (!addToHistory) {
            tr.setMeta('addToHistory', false);
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              let { pos, node } = annotation;
              let newPosFrom = tr.mapping.map(pos);
              let newPosTo = tr.mapping.map(pos + node.nodeSize);
              let currentNode = tr.doc.nodeAt(newPosFrom);
              let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
              let $newPosFrom = tr.doc.resolve(newPosFrom);
              let currentMarks = $newPosFrom.marks();
              currentMarks = currentMarks.length ? [...currentMarks] : null;
              if (nodeEqual) {
                let label = node.attrs.displayLabel || ' ';
                let textNode = state.schema.text(label, currentMarks);
                tr.replaceWith(newPosFrom, newPosTo, textNode);
              }
            });
          }
          return true;
        },
      /**
       * Resets all annotations to default values.
       * @example
       * editor.commands.resetFieldAnnotations()
       */
      resetFieldAnnotations:
        () =>
        ({ dispatch, state, tr }) => {
          let annotations = getAllFieldAnnotations(state);
          if (!annotations.length) {
            return true;
          }
          tr.setMeta('fieldAnnotationUpdate', true);
          if (dispatch) {
            annotations.forEach(({ pos, node }) => {
              let newPos = tr.mapping.map(pos);
              let currentNode = tr.doc.nodeAt(newPos);
              let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
              if (nodeEqual) {
                let displayLabel = node.attrs.defaultDisplayLabel || node.attrs.displayLabel || '';
                tr.setNodeMarkup(newPos, void 0, {
                  ...node.attrs,
                  // reset displayLabel to default.
                  displayLabel,
                  // reset attrs for specific types.
                  imageSrc: null,
                  rawHtml: null,
                  linkUrl: null,
                  hash: null,
                });
              }
            });
          }
          return true;
        },
      /**
       * Update annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param attrs The attributes.
       * @example
       * editor.commands.updateFieldAnnotations('123', {
       *  displayLabel: 'Updated!',
       * })
       * @example
       * editor.commands.updateFieldAnnotations(['123', '456'], {
       *  displayLabel: 'Updated!',
       * })
       */
      updateFieldAnnotations:
        (fieldIdOrArray, attrs = {}) =>
        ({ dispatch, state, commands: commands2 }) => {
          let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            return commands2.updateFieldAnnotationsAttributes(annotations, attrs);
          }
          return true;
        },
      /**
       * Update particular annotation's attributes.
       * @param annotation field annotation node to be updated.
       * @param attrs The attributes.
       *
       * Used for a case when multiple annotations for one input presented
       */
      updateFieldAnnotation:
        (annotation, attrs = {}) =>
        ({ dispatch, commands: commands2 }) => {
          if (!annotation) {
            return true;
          }
          if (dispatch) {
            commands2.updateFieldAnnotationsAttributes([annotation], attrs);
            if (this.editor.options.pagination && !isHeadless(this.editor)) {
              setTimeout(() => {
                const newTr = this.editor.view.state.tr;
                newTr.setMeta('forceUpdatePagination', true);
                this.editor.view.dispatch(newTr);
              }, 50);
            }
            return true;
          }
          return true;
        },
      /**
       * Update the attributes of annotations.
       * @param annotations The annotations array [{pos, node}].
       * @param attrs The attributes object.
       */
      updateFieldAnnotationsAttributes:
        (annotations, attrs = {}) =>
        ({ dispatch, tr }) => {
          if (!dispatch) return true;
          tr.setMeta('fieldAnnotationUpdate', true);
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPos = tr.mapping.map(pos);
            let currentNode = tr.doc.nodeAt(newPos);
            let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
            if (nodeEqual) {
              tr.setNodeMarkup(newPos, void 0, {
                ...node.attrs,
                ...attrs,
              });
            }
          });
          return true;
        },
      /**
       * Delete annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @example
       * editor.commands.deleteFieldAnnotations('123')
       * @example
       * editor.commands.deleteFieldAnnotations(['123', '456'])
       */
      deleteFieldAnnotations:
        (fieldIdOrArray) =>
        ({ dispatch, state, tr }) => {
          let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              let { pos, node } = annotation;
              let newPosFrom = tr.mapping.map(pos);
              let newPosTo = tr.mapping.map(pos + node.nodeSize);
              let currentNode = tr.doc.nodeAt(newPosFrom);
              if (node.eq(currentNode)) {
                tr.delete(newPosFrom, newPosTo);
              }
            });
          }
          return true;
        },
      deleteFieldAnnotationsByNode:
        (annotations) =>
        ({ dispatch, tr }) => {
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              let { pos, node } = annotation;
              let newPosFrom = tr.mapping.map(pos);
              let newPosTo = tr.mapping.map(pos + node.nodeSize);
              let currentNode = tr.doc.nodeAt(newPosFrom);
              if (node.eq(currentNode)) {
                tr.delete(newPosFrom, newPosTo);
              }
            });
          }
          return true;
        },
      deleteFieldAnnotation:
        (annotation) =>
        ({ dispatch, tr }) => {
          if (!annotation) {
            return true;
          }
          if (dispatch) {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          }
          return true;
        },
      /**
       * Delete a portion of annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param end index at which to end extraction
       * @example
       * editor.commands.sliceFieldAnnotations('123', 5) - will remove a portion of annotations array starting from index 6
       * @example
       * editor.commands.sliceFieldAnnotations(['123', '456'], 5)
       */
      sliceFieldAnnotations:
        (fieldIdOrArray, end) =>
        ({ dispatch, state, tr }) => {
          let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation, index) => {
              if (index >= end) {
                let { pos, node } = annotation;
                let newPosFrom = tr.mapping.map(pos);
                let newPosTo = tr.mapping.map(pos + node.nodeSize);
                let currentNode = tr.doc.nodeAt(newPosFrom);
                if (node.eq(currentNode)) {
                  tr.delete(newPosFrom, newPosTo);
                }
              }
            });
          }
          return true;
        },
      /**
       * Set `hidden` for annotations matching predicate.
       * Other annotations become unhidden.
       * @param predicate The predicate function.
       * @param unsetFromOthers If should unset hidden from other annotations.
       * @example
       * editor.commands.setFieldAnnotationsHiddenByCondition((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * })
       */
      setFieldAnnotationsHiddenByCondition:
        (predicate = () => false, unsetFromOthers = false) =>
        ({ dispatch, state, chain }) => {
          let annotations = getAllFieldAnnotations(state);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            let otherAnnotations = [];
            let matchedAnnotations = annotations.filter((annotation) => {
              if (predicate(annotation.node)) return annotation;
              else otherAnnotations.push(annotation);
            });
            if (unsetFromOthers) {
              return chain()
                .updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true })
                .updateFieldAnnotationsAttributes(otherAnnotations, { hidden: false })
                .run();
            } else {
              return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).run();
            }
          }
          return true;
        },
      /**
       * Unset `hidden` for all annotations.
       * @example
       * editor.commands.unsetFieldAnnotationsHidden()
       */
      unsetFieldAnnotationsHidden:
        () =>
        ({ dispatch, state, commands: commands2 }) => {
          let annotations = getAllFieldAnnotations(state);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            return commands2.updateFieldAnnotationsAttributes(annotations, { hidden: false });
          }
          return true;
        },
      /**
       * Set `visibility` for all annotations (without changing the layout).
       * @param visibility The visibility value (visible, hidden).
       * @example
       * editor.commands.setFieldAnnotationsVisibility('visible');
       * @example
       * editor.commands.setFieldAnnotationsVisibility('hidden');
       */
      setFieldAnnotationsVisibility:
        (visibility = 'visible') =>
        ({ dispatch, state, commands: commands2 }) => {
          let annotations = getAllFieldAnnotations(state);
          if (!annotations.length) {
            return true;
          }
          let containsVisibility = this.options.visibilityOptions.includes(visibility);
          if (!containsVisibility) {
            return false;
          }
          if (dispatch) {
            return commands2.updateFieldAnnotationsAttributes(annotations, {
              visibility,
            });
          }
          return true;
        },
      /**
       * Set `highlighted` for annotations matching predicate.
       * @param predicate The predicate function.
       * @param highlighted The highlighted attribute.
       * @example
       * editor.commands.setFieldAnnotationsHighlighted((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * }, false)
       * @example Set for all annotations.
       * editor.commands.setFieldAnnotationsHighlighted(() => true, false)
       * editor.commands.setFieldAnnotationsHighlighted(() => true, true)
       */
      setFieldAnnotationsHighlighted:
        (predicate = () => false, highlighted = true) =>
        ({ dispatch, state, commands: commands2 }) => {
          let annotations = getAllFieldAnnotations(state);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            let matchedAnnotations = annotations.filter((annotation) => {
              if (predicate(annotation.node)) return annotation;
            });
            return commands2.updateFieldAnnotationsAttributes(matchedAnnotations, {
              highlighted,
            });
          }
          return true;
        },
      /// Formatting commands for y-prosemirror support.
      toggleFieldAnnotationsFormat:
        (name, setSelection = false) =>
        ({ dispatch, tr, state, commands: commands2 }) => {
          let formats = this.options.toggleFormatNames;
          if (!formats.includes(name)) {
            return false;
          }
          let { from, to, node } = state.selection;
          let annotations = findFieldAnnotationsBetween(from, to, state.doc);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              commands2.updateFieldAnnotationsAttributes([annotation], {
                [name]: !annotation.node.attrs[name],
              });
            });
            if (setSelection && node?.type.name === this.name) {
              tr.setSelection(NodeSelection.create(tr.doc, from));
            }
          }
          return true;
        },
      setFieldAnnotationsFontFamily:
        (fontFamily, setSelection = false) =>
        ({ dispatch, tr, state, commands: commands2 }) => {
          let { from, to, node } = state.selection;
          let annotations = findFieldAnnotationsBetween(from, to, state.doc);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              commands2.updateFieldAnnotationsAttributes([annotation], {
                fontFamily,
              });
            });
            if (setSelection && node?.type.name === this.name) {
              tr.setSelection(NodeSelection.create(tr.doc, from));
            }
          }
          return true;
        },
      setFieldAnnotationsFontSize:
        (fontSize, setSelection = false) =>
        ({ dispatch, tr, state, commands: commands2 }) => {
          let { from, to, node } = state.selection;
          let annotations = findFieldAnnotationsBetween(from, to, state.doc);
          if (!annotations.length) {
            return true;
          }
          let [value, unit] = parseSizeUnit(fontSize);
          let min = 8,
            max = 96,
            defaultUnit = 'pt';
          if (Number.isNaN(value)) {
            return false;
          }
          value = minMax(value, min, max);
          unit = unit ? unit : defaultUnit;
          if (dispatch) {
            annotations.forEach((annotation) => {
              commands2.updateFieldAnnotationsAttributes([annotation], {
                fontSize: `${value}${unit}`,
              });
            });
            if (setSelection && node?.type.name === this.name) {
              tr.setSelection(NodeSelection.create(tr.doc, from));
            }
          }
          return true;
        },
      setFieldAnnotationsTextHighlight:
        (color, setSelection = false) =>
        ({ dispatch, tr, state, commands: commands2 }) => {
          let { from, to, node } = state.selection;
          let annotations = findFieldAnnotationsBetween(from, to, state.doc);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              commands2.updateFieldAnnotationsAttributes([annotation], {
                textHighlight: color,
              });
            });
            if (setSelection && node?.type.name === this.name) {
              tr.setSelection(NodeSelection.create(tr.doc, from));
            }
          }
          return true;
        },
      setFieldAnnotationsTextColor:
        (color, setSelection = false) =>
        ({ dispatch, tr, state, commands: commands2 }) => {
          let { from, to, node } = state.selection;
          let annotations = findFieldAnnotationsBetween(from, to, state.doc);
          if (!annotations.length) {
            return true;
          }
          if (dispatch) {
            annotations.forEach((annotation) => {
              commands2.updateFieldAnnotationsAttributes([annotation], {
                textColor: color,
              });
            });
            if (setSelection && node?.type.name === this.name) {
              tr.setSelection(NodeSelection.create(tr.doc, from));
            }
          }
          return true;
        },
      /// Formatting commands - end.
      // Clean up commands (after field deletion)
      ...commands,
    };
  },
  addNodeView() {
    return (props) => {
      return new FieldAnnotationView({
        ...props,
        annotationClass: this.options.annotationClass,
        annotationContentClass: this.options.annotationContentClass,
        borderColor: this.options.borderColor,
      });
    };
  },
  addPmPlugins() {
    return [
      FieldAnnotationPlugin({
        editor: this.editor,
        annotationClass: this.options.annotationClass,
        handleDropOutside: this.options.handleDropOutside,
      }),
    ];
  },
});
function getFormatAttrsFromMarks(marks) {
  if (!marks) {
    return {};
  }
  let formatAttrs = {
    bold: false,
    italic: false,
    underline: false,
    fontFamily: null,
    fontSize: null,
  };
  if (marks && marks.length) {
    formatAttrs.bold = marks.some((mark) => mark.type.name === 'bold');
    formatAttrs.italic = marks.some((mark) => mark.type.name === 'italic');
    formatAttrs.underline = marks.some((mark) => mark.type.name === 'underline');
    let textStyle = marks.find((mark) => mark.type.name === 'textStyle');
    if (textStyle) {
      formatAttrs.fontFamily = textStyle.attrs.fontFamily ?? null;
      formatAttrs.fontSize = textStyle.attrs.fontSize ?? null;
    }
  }
  return formatAttrs;
}
const DEFAULT_MIME_TYPE = 'application/octet-stream';
const simpleHash = (str) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString();
};
const decodeBase64ToBinaryString = (data) => {
  if (!data) return '';
  if (typeof atob === 'function') {
    return atob(data);
  }
  if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {
    return Buffer.from(data, 'base64').toString('binary');
  }
  throw new Error('Unable to decode base64 payload in the current environment.');
};
const extractBase64Meta = (base64String) => {
  const [meta = '', payload = ''] = base64String.split(',');
  const mimeMatch = meta.match(/:(.*?);/);
  const rawMimeType = mimeMatch ? mimeMatch[1] : '';
  const mimeType = rawMimeType || DEFAULT_MIME_TYPE;
  const binaryString = decodeBase64ToBinaryString(payload);
  const hash = simpleHash(binaryString);
  const extension = mimeType.split('/')[1] || 'bin';
  const filename = `image-${hash}.${extension}`;
  return { mimeType, binaryString, filename };
};
const getBase64FileMeta = (base64String) => {
  const { mimeType, filename } = extractBase64Meta(base64String);
  return { mimeType, filename };
};
const base64ToFile = (base64String) => {
  const { mimeType, binaryString, filename } = extractBase64Meta(base64String);
  const fileType = mimeType || DEFAULT_MIME_TYPE;
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  const blob = new Blob([bytes], { type: fileType });
  return new File([blob], filename, { type: fileType });
};
const urlToFile = async (url, filename, mimeType) => {
  try {
    const response = await fetch(url, {
      mode: 'cors',
      credentials: 'omit',
      headers: {
        // Add common headers that might help with CORS
        Accept: 'image/*,*/*;q=0.8',
      },
    });
    if (!response.ok) {
      console.warn(`Failed to fetch image from ${url}: ${response.status} ${response.statusText}`);
      return null;
    }
    const blob = await response.blob();
    const finalFilename = filename || extractFilenameFromUrl(url);
    const finalMimeType = mimeType || response.headers.get('content-type') || blob.type || 'image/jpeg';
    return new File([blob], finalFilename, { type: finalMimeType });
  } catch (error) {
    if (isCorsError(error)) {
      console.warn(`CORS policy prevents accessing image from ${url}:`, error.message);
      return null;
    }
    console.error(`Error fetching image from ${url}:`, error);
    return null;
  }
};
const isCorsError = (error) => {
  const errorMessage = error.message.toLowerCase();
  const errorName = error.name.toLowerCase();
  return (
    errorName.includes('cors') ||
    errorMessage.includes('cors') ||
    errorMessage.includes('cross-origin') ||
    errorMessage.includes('access-control') ||
    errorMessage.includes('network error') || // Often indicates CORS in browsers
    errorMessage.includes('failed to fetch')
  );
};
const extractFilenameFromUrl = (url) => {
  try {
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    const filename = pathname.split('/').pop();
    if (filename && !filename.includes('.')) {
      return `${filename}.jpg`;
    }
    return filename || 'image.jpg';
  } catch {
    return 'image.jpg';
  }
};
const validateUrlAccessibility = async (url) => {
  try {
    const response = await fetch(url, {
      method: 'HEAD',
      mode: 'cors',
      credentials: 'omit',
    });
    return response.ok;
  } catch {
    return false;
  }
};
const handleImageUpload = (file) => {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = (event) => {
      resolve(event.target.result);
    };
    reader.onerror = reject;
    setTimeout(() => reader.readAsDataURL(file), 250);
  });
};
const processUploadedImage = (fileData, getMaxContentSize) => {
  return new Promise((resolve, reject) => {
    const img = new window.Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const { width: logicalWidth, height: logicalHeight } = getAllowedImageDimensions(
        img.width,
        img.height,
        getMaxContentSize,
      );
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.imageSmoothingEnabled = true;
        try {
          ctx.imageSmoothingQuality = 'high';
        } catch {}
      }
      ctx.drawImage(img, 0, 0, img.width, img.height);
      const dpr = typeof window !== 'undefined' && window.devicePixelRatio ? window.devicePixelRatio : 1;
      const targetPixelWidth = Math.round(logicalWidth * dpr);
      const targetPixelHeight = Math.round(logicalHeight * dpr);
      const finalTargetWidth = Math.min(targetPixelWidth, img.width);
      const finalTargetHeight = Math.min(targetPixelHeight, img.height);
      const resizeNeeded = finalTargetWidth !== img.width || finalTargetHeight !== img.height;
      if (resizeNeeded) {
        multiStepResize(canvas, finalTargetWidth, finalTargetHeight);
      }
      if (typeof fileData === 'string') {
        const resizedBase64 = canvas.toDataURL();
        resolve(resizedBase64);
      } else {
        canvas.toBlob((blob) => {
          const updatedFile = new File([blob], fileData.name, {
            type: fileData.type,
            lastModified: Date.now(),
          });
          resolve({ file: updatedFile, width: logicalWidth, height: logicalHeight });
        });
      }
    };
    img.onerror = (error) => reject(error);
    img.src = typeof fileData === 'string' ? fileData : URL.createObjectURL(fileData);
  });
};
const getAllowedImageDimensions = (width, height, getMaxContentSize) => {
  const { width: maxWidth, height: maxHeight } = getMaxContentSize();
  if (!maxWidth || !maxHeight) return { width, height };
  let adjustedWidth = width;
  let adjustedHeight = height;
  const aspectRatio = width / height;
  if (height > maxHeight) {
    adjustedHeight = maxHeight;
    adjustedWidth = Math.round(maxHeight * aspectRatio);
  }
  if (adjustedWidth > maxWidth) {
    adjustedWidth = maxWidth;
    adjustedHeight = Math.round(maxWidth / aspectRatio);
  }
  return { width: adjustedWidth, height: adjustedHeight };
};
function resample_high_quality(canvas, width, height, resize_canvas) {
  var width_source = canvas.width;
  var height_source = canvas.height;
  width = Math.round(width);
  height = Math.round(height);
  var ratio_w = width_source / width;
  var ratio_h = height_source / height;
  var ratio_w_half = Math.ceil(ratio_w / 2);
  var ratio_h_half = Math.ceil(ratio_h / 2);
  var ctx = canvas.getContext('2d');
  var img = ctx.getImageData(0, 0, width_source, height_source);
  var img2 = ctx.createImageData(width, height);
  var data = img.data;
  var data2 = img2.data;
  for (var j = 0; j < height; j++) {
    for (var i = 0; i < width; i++) {
      var x2 = (i + j * width) * 4;
      var weight = 0;
      var weights = 0;
      var weights_alpha = 0;
      var gx_r = 0;
      var gx_g = 0;
      var gx_b = 0;
      var gx_a = 0;
      var center_y = (j + 0.5) * ratio_h;
      var yy_start = Math.floor(j * ratio_h);
      var yy_stop = Math.ceil((j + 1) * ratio_h);
      for (var yy = yy_start; yy < yy_stop; yy++) {
        var dy = Math.abs(center_y - (yy + 0.5)) / ratio_h_half;
        var center_x = (i + 0.5) * ratio_w;
        var w0 = dy * dy;
        var xx_start = Math.floor(i * ratio_w);
        var xx_stop = Math.ceil((i + 1) * ratio_w);
        for (var xx = xx_start; xx < xx_stop; xx++) {
          var dx = Math.abs(center_x - (xx + 0.5)) / ratio_w_half;
          var w = Math.sqrt(w0 + dx * dx);
          if (w >= 1) {
            continue;
          }
          weight = 2 * w * w * w - 3 * w * w + 1;
          var pos_x = 4 * (xx + yy * width_source);
          gx_a += weight * data[pos_x + 3];
          weights_alpha += weight;
          if (data[pos_x + 3] < 255) weight = (weight * data[pos_x + 3]) / 250;
          gx_r += weight * data[pos_x];
          gx_g += weight * data[pos_x + 1];
          gx_b += weight * data[pos_x + 2];
          weights += weight;
        }
      }
      data2[x2] = gx_r / weights;
      data2[x2 + 1] = gx_g / weights;
      data2[x2 + 2] = gx_b / weights;
      data2[x2 + 3] = gx_a / weights_alpha;
    }
  }
  {
    canvas.width = width;
    canvas.height = height;
  }
  ctx.putImageData(img2, 0, 0);
}
function multiStepResize(canvas, width, height) {
  let oc = document.createElement('canvas');
  let octx = oc.getContext('2d');
  let ctx = canvas.getContext('2d');
  let steps = Math.ceil(Math.log(canvas.width / width) / Math.log(2));
  steps = Math.max(steps, 1);
  let stepWidth = width * Math.pow(2, steps - 1);
  let stepHeight = height * Math.pow(2, steps - 1);
  let currentWidth = canvas.width;
  let currentHeight = canvas.height;
  oc.width = currentWidth;
  oc.height = currentHeight;
  octx.drawImage(canvas, 0, 0);
  while (steps > 0) {
    stepWidth = Math.max(stepWidth, width);
    stepHeight = Math.max(stepHeight, height);
    canvas.width = stepWidth;
    canvas.height = stepHeight;
    ctx.drawImage(oc, 0, 0, currentWidth, currentHeight, 0, 0, stepWidth, stepHeight);
    currentWidth = stepWidth;
    currentHeight = stepHeight;
    oc.width = currentWidth;
    oc.height = currentHeight;
    octx.drawImage(canvas, 0, 0);
    stepWidth = Math.round(stepWidth / 2);
    stepHeight = Math.round(stepHeight / 2);
    steps--;
  }
  resample_high_quality(canvas, width, height);
}
const FALLBACK_NAME = 'image';
const stripDiacritics = (value) => value.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
const sanitizeSegment = (segment, { allowDots = false } = {}) => {
  if (!segment) return '';
  const normalized = stripDiacritics(segment)
    .replace(/[\s\u2000-\u206f]+/g, '_')
    .replace(/[\\/]+/g, '_');
  const allowedPattern = allowDots ? /[^0-9A-Za-z._-]+/g : /[^0-9A-Za-z_-]+/g;
  let sanitized = normalized.replace(allowedPattern, '_');
  sanitized = sanitized.replace(/_+/g, '_');
  sanitized = sanitized.replace(/^[_.-]+/, '');
  sanitized = sanitized.replace(/[_-]+$/, '');
  return sanitized;
};
const splitFileName = (name) => {
  const trimmed = name?.trim?.() ?? '';
  const lastDot = trimmed.lastIndexOf('.');
  if (lastDot <= 0 || lastDot === trimmed.length - 1) {
    return { base: trimmed, ext: '' };
  }
  return {
    base: trimmed.slice(0, lastDot),
    ext: trimmed.slice(lastDot + 1),
  };
};
const sanitizeImageFileName = (inputName) => {
  const { base, ext } = splitFileName(inputName || '');
  const sanitizedBase = sanitizeSegment(base, { allowDots: true }) || FALLBACK_NAME;
  const sanitizedExt = sanitizeSegment(ext, { allowDots: false }).toLowerCase();
  if (!sanitizedExt) return sanitizedBase;
  return `${sanitizedBase}.${sanitizedExt}`;
};
const ensureUniqueFileName = (preferredName, existingNames = /* @__PURE__ */ new Set()) => {
  const sanitized = sanitizeImageFileName(preferredName);
  if (!existingNames || typeof existingNames.has !== 'function') {
    return sanitized;
  }
  const existingSet = /* @__PURE__ */ new Set();
  existingNames.forEach((name) => existingSet.add(sanitizeImageFileName(name)));
  if (!existingSet.has(sanitized)) {
    return sanitized;
  }
  const { base, ext } = splitFileName(sanitized);
  let counter = 1;
  let candidate = sanitized;
  const suffix = () => `${base}-${counter}${ext ? `.${ext}` : ''}`;
  while (existingSet.has(candidate)) {
    candidate = suffix();
    counter += 1;
  }
  return candidate;
};
const buildMediaPath = (fileName) => `word/media/${fileName}`;
const fileTooLarge = (file) => {
  let fileSizeMb = Number((file.size / (1024 * 1024)).toFixed(4));
  if (fileSizeMb > 5) {
    window.alert('Image size must be less than 5MB');
    return true;
  }
  return false;
};
const checkAndProcessImage = async ({ getMaxContentSize, file }) => {
  if (fileTooLarge(file)) {
    return { file: null, size: { width: 0, height: 0 } };
  }
  try {
    const processedImageResult = await processUploadedImage(file, getMaxContentSize);
    const process2 = processedImageResult;
    return { file: process2.file, size: { width: process2.width, height: process2.height } };
  } catch (err) {
    console.warn('Error processing image:', err);
    return { file: null, size: { width: 0, height: 0 } };
  }
};
const generateUniqueDocPrId = (editor) => {
  const existingIds = /* @__PURE__ */ new Set();
  editor?.state?.doc?.descendants((node) => {
    if (node.type.name === 'image' && node.attrs.id !== void 0 && node.attrs.id !== null) {
      existingIds.add(String(node.attrs.id));
    }
  });
  let candidate;
  do {
    const hex = generateDocxRandomId();
    candidate = String(parseInt(hex, 16));
  } while (!candidate || existingIds.has(candidate));
  return candidate;
};
async function uploadAndInsertImage({ editor, view, file, size, id }) {
  const imageUploadHandler =
    typeof editor.options.handleImageUpload === 'function' ? editor.options.handleImageUpload : handleImageUpload;
  const placeholderId = id;
  try {
    const existingFileNames = new Set(
      Object.keys(editor.storage.image.media ?? {}).map((key2) => key2.split('/').pop()),
    );
    const uniqueFileName = ensureUniqueFileName(file.name, existingFileNames);
    const normalizedFile =
      uniqueFileName === file.name
        ? file
        : new File([file], uniqueFileName, {
            type: file.type,
            lastModified: file.lastModified ?? Date.now(),
          });
    let url = await imageUploadHandler(normalizedFile);
    let placeholderPos = findPlaceholder(view.state, placeholderId);
    if (placeholderPos == null) {
      return;
    }
    const mediaPath = buildMediaPath(uniqueFileName);
    const docPrId = generateUniqueDocPrId(editor);
    let rId = null;
    if (editor.options.mode === 'docx') {
      const [, path] = mediaPath.split('word/');
      const id2 = addImageRelationship({ editor, path });
      if (id2) rId = id2;
    }
    let imageNode = view.state.schema.nodes.image.create({
      src: mediaPath,
      size,
      id: docPrId,
      rId,
    });
    editor.storage.image.media = Object.assign(editor.storage.image.media, { [mediaPath]: url });
    if (editor.options.ydoc && typeof editor.commands.addImageToCollaboration === 'function') {
      editor.commands.addImageToCollaboration({ mediaPath, fileData: url });
    }
    let tr = view.state.tr;
    tr.replaceWith(placeholderPos, placeholderPos, imageNode);
    tr = removeImagePlaceholder(view.state, tr, placeholderId);
    view.dispatch(tr);
  } catch {
    const tr = removeImagePlaceholder(view.state, view.state.tr, placeholderId);
    view.dispatch(tr);
  }
}
function addImageRelationship({ editor, path }) {
  const target = path;
  const type = 'image';
  try {
    const id = insertNewRelationship(target, type, editor);
    return id;
  } catch {
    return null;
  }
}
const key = new PluginKey('ImageRegistration');
const WORD_MEDIA_PREFIX = 'word/';
const ImageRegistrationPlugin = ({ editor }) => {
  const { view } = editor;
  return new Plugin({
    key,
    state: {
      init() {
        return { set: DecorationSet.empty };
      },
      apply(tr, { set }) {
        const meta = tr.getMeta(key);
        if (meta) {
          set = meta.set;
          return { set };
        }
        set = set.map(tr.mapping, tr.doc);
        return { set };
      },
    },
    appendTransaction: (trs, _oldState, state) => {
      let foundImages = [];
      if (!trs.some((tr) => tr.docChanged)) return null;
      trs.forEach((tr) => {
        if (tr.docChanged) {
          tr.steps.forEach((step, index) => {
            const stepMap = step.getMap();
            foundImages = foundImages.map(({ node, pos, id }) => {
              const mappedPos = stepMap.map(pos, -1);
              return { node, pos: mappedPos, id };
            });
            if (step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1) {
              (tr.docs[index + 1] || tr.doc).nodesBetween(
                stepMap.map(step.from, -1),
                stepMap.map(step.to, 1),
                (node, pos) => {
                  if (node.type.name === 'image' && !node.attrs.src.startsWith('word/media')) {
                    const id = {};
                    foundImages.push({ node, pos, id });
                  } else {
                    return true;
                  }
                },
              );
            }
          });
        }
      });
      if (!foundImages || foundImages.length === 0) {
        return null;
      }
      if (editor.options.isHeadless) {
        return handleNodePath(foundImages, editor, state);
      }
      return handleBrowserPath(foundImages, editor, view, state);
    },
    props: {
      decorations(state) {
        let { set } = key.getState(state);
        return set;
      },
    },
  });
};
const derivePreferredFileName = (src) => {
  if (typeof src !== 'string' || src.length === 0) {
    return 'image.bin';
  }
  if (src.startsWith('data:')) {
    return getBase64FileMeta(src).filename;
  }
  const lastSegment = src.split('/').pop() ?? '';
  const trimmed = lastSegment.split(/[?#]/)[0];
  return trimmed || 'image.bin';
};
const handleNodePath = (foundImages, editor, state) => {
  const { tr } = state;
  const mediaStore = editor.storage.image.media ?? {};
  if (!editor.storage.image.media) {
    editor.storage.image.media = mediaStore;
  }
  const existingFileNames = new Set(Object.keys(mediaStore).map((key2) => key2.split('/').pop()));
  foundImages.forEach(({ node, pos }) => {
    const { src } = node.attrs;
    const preferredFileName = derivePreferredFileName(src);
    const uniqueFileName = ensureUniqueFileName(preferredFileName, existingFileNames);
    existingFileNames.add(uniqueFileName);
    const mediaPath = buildMediaPath(uniqueFileName);
    mediaStore[mediaPath] = src;
    const path = mediaPath.startsWith(WORD_MEDIA_PREFIX) ? mediaPath.slice(WORD_MEDIA_PREFIX.length) : mediaPath;
    const rId = addImageRelationship({ editor, path });
    tr.setNodeMarkup(pos, void 0, {
      ...node.attrs,
      src: mediaPath,
      rId,
    });
  });
  return tr;
};
const handleBrowserPath = (foundImages, editor, view, state) => {
  registerImages(foundImages, editor, view);
  const tr = state.tr;
  let { set } = key.getState(state);
  foundImages
    .slice()
    .sort((a, b) => a.pos - b.pos)
    .forEach(({ pos, id }) => {
      let deco = Decoration.widget(pos, () => document.createElement('placeholder'), {
        side: -1,
        id,
      });
      set = set.add(tr.doc, [deco]);
    });
  foundImages
    .slice()
    .sort((a, b) => b.pos - a.pos)
    .forEach(({ node, pos }) => {
      tr.delete(pos, pos + node.nodeSize);
    });
  set = set.map(tr.mapping, tr.doc);
  tr.setMeta(key, { set });
  return tr;
};
const findPlaceholder = (state, id) => {
  let { set } = key.getState(state);
  let found = set?.find(null, null, (spec) => spec.id === id);
  return found?.length ? found[0].from : null;
};
const removeImagePlaceholder = (state, tr, id) => {
  let { set } = key.getState(state);
  set = set.map(tr.mapping, tr.doc);
  set = set.remove(set.find(null, null, (spec) => spec.id == id));
  return tr.setMeta(key, { set, type: 'remove' });
};
const getImageRegistrationMetaType = (tr) => {
  const meta = tr.getMeta(key);
  if (meta && meta.type) {
    return meta.type;
  }
  return null;
};
const registerImages = async (foundImages, editor, view) => {
  foundImages.forEach(async (image) => {
    const src = image.node.attrs.src;
    const id = image.id;
    let file = null;
    if (src.startsWith('http')) {
      const isAccessible = await validateUrlAccessibility(src);
      if (isAccessible) {
        file = await urlToFile(src);
      } else {
        console.warn(`Image URL ${src} is not accessible due to CORS or other restrictions. Using original URL.`);
        const tr = view.state.tr;
        removeImagePlaceholder(view.state, tr, id);
        view.dispatch(tr);
        return;
      }
    } else if (src.startsWith('data:')) {
      file = base64ToFile(src);
    } else {
      console.error(`Unsupported image source: ${src}`);
    }
    if (!file) {
      const tr = view.state.tr;
      removeImagePlaceholder(view.state, tr, id);
      view.dispatch(tr);
      return;
    }
    try {
      const process2 = await checkAndProcessImage({
        getMaxContentSize: () => editor.getMaxContentSize(),
        file,
      });
      if (!process2.file) {
        const tr = view.state.tr;
        removeImagePlaceholder(view.state, tr, id);
        view.dispatch(tr);
        return;
      }
      await uploadAndInsertImage({ editor, view, file: process2.file, size: process2.size, id });
    } catch (error) {
      console.error(`Error processing image from ${src}:`, error);
      const tr = view.state.tr;
      removeImagePlaceholder(view.state, tr, id);
      view.dispatch(tr);
    }
  });
};
const stepHasSlice = (step) => 'slice' in step && Boolean(step.slice);
const ImagePositionPluginKey = new PluginKey('ImagePosition');
const pageBreakPositionCache = /* @__PURE__ */ new WeakMap();
const ImagePositionPlugin = ({ editor }) => {
  const { view } = editor;
  let shouldUpdate = false;
  return new Plugin({
    name: 'ImagePositionPlugin',
    key: ImagePositionPluginKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldDecorationSet, oldState, newState) {
        if (!tr.docChanged && !shouldUpdate) return oldDecorationSet;
        let affectsImages = false;
        tr.steps.forEach((step) => {
          if (stepHasSlice(step)) {
            step.slice.content.descendants((node) => {
              if (node.type.name === 'image' || node.attrs?.anchorData) {
                affectsImages = true;
                return false;
              }
            });
          }
        });
        if (!affectsImages && !shouldUpdate) {
          return oldDecorationSet.map(tr.mapping, tr.doc);
        }
        const decorations = getImagePositionDecorations(newState, view);
        shouldUpdate = false;
        return DecorationSet.create(newState.doc, decorations);
      },
    },
    view: () => {
      return {
        update: (view2, lastState) => {
          const pagination = PaginationPluginKey.getState(lastState);
          if (shouldUpdate) {
            const decorations = getImagePositionDecorations(lastState, view2);
            const updateTransaction = view2.state.tr.setMeta(ImagePositionPluginKey, { decorations });
            view2.dispatch(updateTransaction);
          }
          if (pagination?.isReadyToInit) {
            shouldUpdate = true;
          }
        },
      };
    },
    props: {
      decorations(state) {
        return this.getState(state);
      },
    },
  });
};
const getImagePositionDecorations = (state, view) => {
  let decorations = [];
  let hasAnchoredImages = false;
  state.doc.descendants((node) => {
    if (node.attrs?.anchorData) {
      hasAnchoredImages = true;
      return false;
    }
  });
  if (!hasAnchoredImages) {
    return decorations;
  }
  state.doc.descendants((node, pos) => {
    if (node.attrs.anchorData) {
      let style = '';
      let className = '';
      const { vRelativeFrom, alignH } = node.attrs.anchorData;
      const { size, padding } = node.attrs;
      const pageBreak = findPreviousDomNodeWithClass(view, pos, 'pagination-break-wrapper');
      if (pageBreak && vRelativeFrom === 'margin' && alignH) {
        let pageBreakPos = pageBreakPositionCache.get(pageBreak);
        if (!pageBreakPos) {
          pageBreakPos = {
            top: pageBreak.offsetTop,
            height: pageBreak.offsetHeight,
          };
          pageBreakPositionCache.set(pageBreak, pageBreakPos);
        }
        const topPos = pageBreakPos.top + pageBreakPos.height;
        let horizontalAlignment = `${alignH}: 0;`;
        if (alignH === 'center') horizontalAlignment = 'left: 50%; transform: translateX(-50%);';
        style += vRelativeFrom === 'margin' ? `position: absolute; top: ${topPos}px; ${horizontalAlignment}` : '';
        const nextPos = view.posAtDOM(pageBreak, 1);
        if (nextPos < 0) {
          const $pos = view.state.doc.resolve(pos);
          decorations.push(
            Decoration.node(pos - 1, pos + $pos.parent.nodeSize - 1, {
              style: `height: ${size.height + parseInt(padding.top) + parseInt(padding.bottom)}px`,
            }),
          );
        }
        const imageBlock = document.createElement('div');
        imageBlock.className = 'anchor-image-placeholder';
        imageBlock.style.float = alignH === 'left' || alignH === 'right' ? alignH : 'none';
        let paddingHorizontal;
        if (alignH === 'center') {
          paddingHorizontal = (parseInt(padding.left) || 0) + (parseInt(padding.right) || 0);
        } else {
          paddingHorizontal = parseInt(padding[alignH]) || 0;
        }
        imageBlock.style.width = size.width + paddingHorizontal + 'px';
        imageBlock.style.height = size.height + parseInt(padding.top) + parseInt(padding.bottom) + 'px';
        decorations.push(Decoration.widget(nextPos, imageBlock, { key: 'stable-key' }));
        decorations.push(Decoration.inline(pos, pos + node.nodeSize, { style, class: className }));
      }
    }
  });
  return decorations;
};
const findPreviousDomNodeWithClass = (view, pos, className) => {
  let { node } = view.domAtPos(pos);
  if (node.nodeType === 3) {
    node = node.parentNode;
  }
  while (node) {
    if (node.classList && node.classList.contains(className)) {
      return node;
    }
    if (node.previousSibling) {
      node = node.previousSibling;
      while (node && node.lastChild) {
        node = node.lastChild;
      }
    } else {
      node = node.parentNode;
    }
  }
  return null;
};
const normalizeWrap = (attrs = {}) => {
  const wrap = attrs.wrap;
  if (wrap?.type && wrap.type !== 'Inline') {
    return {
      type: wrap.type,
      attrs: wrap.attrs ?? {},
    };
  }
  if (wrap?.type === 'Inline' && Object.keys(wrap.attrs ?? {}).length) {
    return {
      type: 'Inline',
      attrs: wrap.attrs,
    };
  }
  if (!wrap && attrs.wrapText) {
    return {
      type: 'Square',
      attrs: {
        wrapText: attrs.wrapText,
      },
    };
  }
  if (!wrap && attrs.wrapTopAndBottom) {
    return {
      type: 'TopAndBottom',
      attrs: {},
    };
  }
  if (wrap?.type === 'Inline') {
    return {
      type: 'Inline',
      attrs: wrap.attrs ?? {},
    };
  }
  return {
    type: 'Inline',
    attrs: {},
  };
};
const normalizeMarginOffset = (marginOffset = {}) => {
  const { left, horizontal, ...rest } = marginOffset;
  return {
    ...rest,
    horizontal: horizontal ?? left,
  };
};
const getNormalizedImageAttrs = (attrs = {}) => {
  return {
    wrap: normalizeWrap(attrs),
    marginOffset: normalizeMarginOffset(attrs.marginOffset ?? {}),
  };
};
const getRotationMargins = (w, h, angleDegrees) => {
  const rad = angleDegrees * (Math.PI / 180);
  const cos = Math.abs(Math.cos(rad));
  const sin = Math.abs(Math.sin(rad));
  const boundingWidth = w * cos + h * sin;
  const boundingHeight = w * sin + h * cos;
  const marginLeftRight = Math.round(Math.max(0, (boundingWidth - w) / 2));
  const marginTopBottom = Math.round(Math.max(0, (boundingHeight - h) / 2));
  return {
    horizontal: marginLeftRight,
    vertical: marginTopBottom,
  };
};
const Image = Node$1.create({
  name: 'image',
  group: 'inline',
  inline: true,
  draggable: true,
  addOptions() {
    return {
      allowBase64: true,
      htmlAttributes: {
        style: 'display: inline-block;',
        'aria-label': 'Image node',
      },
    };
  },
  addStorage() {
    return {
      media: {},
    };
  },
  addAttributes() {
    return {
      src: {
        default: null,
        renderDOM: ({ src }) => {
          return {
            src: this.storage.media[src] ?? src,
          };
        },
      },
      alt: {
        default: 'Uploaded picture',
      },
      id: { rendered: false },
      title: {
        default: null,
      },
      rId: {
        default: null,
        rendered: false,
      },
      originalPadding: {
        default: null,
        rendered: false,
      },
      originalAttributes: { rendered: false },
      /**
       * @category Attribute
       * @param {Object} wrap - Wrapping options
       * @param {string} wrap.type - Wrap type: "None", "Square", "Through", "Tight", "TopAndBottom", "Inline"
       * @param {Object} [wrap.attrs] - Wrap attributes (only allowed attributes for the given type will be accepted)
       * @param {string} [wrap.attrs.wrapText] - Text wrapping mode for Square type: "bothSides", "largest", "left", "right"
       * @param {number} [wrap.attrs.distTop] - Top distance in pixels
       * @param {number} [wrap.attrs.distBottom] - Bottom distance in pixels
       * @param {number} [wrap.attrs.distLeft] - Left distance in pixels
       * @param {number} [wrap.attrs.distRight] - Right distance in pixels
       * @param {Array} [wrap.attrs.polygon] - Polygon points for Through/Tight types: [[x1,y1], [x2,y2], ...]
       * @param {boolean} [wrap.attrs.behindDoc] - Whether image should be behind document text (for wrapNone)
       */
      wrap: {
        default: { type: 'Inline' },
        rendered: false,
        // Handled in main renderDOM
      },
      anchorData: {
        default: null,
        rendered: false,
      },
      isAnchor: { rendered: false },
      /**
       * @category Attribute
       * @param {Object} [transformData] - Transform data for image (turn and flip)
       * @param {number} [transformData.rotation] - Turn angle in degrees
       * @param {boolean} [transformData.verticalFlip] - Whether to flip vertically
       * @param {boolean} [transformData.horizontalFlip] - Whether to flip horizontally
       * @param {Object} [transformData.sizeExtension] - Size extension for image due to transformation
       * @param {number} [transformData.sizeExtension.left] - Left size extension for image
       * @param {number} [transformData.sizeExtension.top] - Top size extension for image
       * @param {number} [transformData.sizeExtension.right] - Right size extension for image
       * @param {number} [transformData.sizeExtension.bottom] - Bottom size extension for image
       *
       * @private
       */
      transformData: {
        default: {},
        renderDOM: ({ transformData }) => {
          let style = '';
          if (transformData?.rotation) {
            style += `rotate(${Math.round(transformData.rotation)}deg) `;
          }
          if (transformData?.verticalFlip) {
            style += 'scaleY(-1) ';
          }
          if (transformData?.horizontalFlip) {
            style += 'scaleX(-1) ';
          }
          style = style.trim();
          if (style.length > 0) {
            return { style: `transform: ${style};` };
          }
          return;
        },
      },
      /**
       * @category Attribute
       * @param {boolean} [simplePos] - Simple positioning flag
       * @private
       */
      simplePos: { rendered: false },
      extension: { rendered: false },
      size: {
        default: {},
        renderDOM: ({ size, extension }) => {
          let style = '';
          let { width, height } = size ?? {};
          if (width) style += `width: ${width}px;`;
          if (height && ['emf', 'wmf'].includes(extension))
            style += `height: ${height}px; border: 1px solid black; position: absolute;`;
          else if (height) style += 'height: auto;';
          return { style };
        },
      },
      padding: {
        default: {},
        rendered: false,
        // Handled in main renderDOM
      },
      marginOffset: {
        default: {},
        rendered: false,
        // Handled in main renderDOM
      },
      style: {
        default: null,
        rendered: true,
        renderDOM: ({ style }) => {
          if (!style) return {};
          return { style };
        },
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: this.options.allowBase64 ? 'img[src]' : 'img[src]:not([src^="data:"])',
      },
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    const { wrap, marginOffset } = getNormalizedImageAttrs(node.attrs);
    const { anchorData, padding, transformData = {}, size = { width: 0, height: 0 } } = node.attrs;
    const margin = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
    };
    let centered = false;
    let floatRight = false;
    let baseHorizontal = marginOffset?.horizontal || 0;
    let style = '';
    if (padding) {
      if (padding.left) margin.left += padding.left;
      if (padding.right) margin.right += padding.right;
      if (padding.top) margin.top += padding.top;
      if (padding.bottom) margin.bottom += padding.bottom;
    }
    const { rotation } = transformData;
    const { height, width } = size;
    if (rotation && height && width) {
      const { horizontal, vertical } = getRotationMargins(width, height, rotation);
      margin.left += horizontal;
      margin.right += horizontal;
      margin.top += vertical;
      margin.bottom += vertical;
    }
    if (wrap && wrap.type) {
      const { type, attrs = {} } = wrap;
      switch (type) {
        case 'None':
          style += 'position: absolute;';
          if (attrs.behindDoc) {
            style += 'z-index: -1;';
          } else {
            style += 'z-index: 1;';
          }
          break;
        case 'Square':
          style += 'shape-outside: border-box; clear: both;';
          if (attrs.wrapText === 'right') {
            style += 'float: left;';
          } else if (attrs.wrapText === 'left') {
            style += 'float: right;';
            floatRight = true;
          } else if (['largest', 'bothSides'].includes(attrs.wrapText)) {
            const pageStylesData = getDataFromPageStyles({
              editor: this.editor,
              marginOffset,
              size,
              attrs,
            });
            style += pageStylesData.style;
            floatRight = pageStylesData.floatRight;
            baseHorizontal = pageStylesData.baseHorizontal;
          }
          if (attrs.distTop) margin.top += attrs.distTop;
          if (attrs.distBottom) margin.bottom += attrs.distBottom;
          if (attrs.distLeft) margin.left += attrs.distLeft;
          if (attrs.distRight) margin.right += attrs.distRight;
          break;
        case 'Through':
        case 'Tight': {
          style += 'clear: both;';
          const pageStylesData = getDataFromPageStyles({
            editor: this.editor,
            marginOffset,
            size,
            attrs,
          });
          style += pageStylesData.style;
          floatRight = pageStylesData.floatRight;
          baseHorizontal = pageStylesData.baseHorizontal;
          if (attrs.distTop) margin.top += attrs.distTop;
          if (attrs.distBottom) margin.bottom += attrs.distBottom;
          if (attrs.distLeft) margin.left += attrs.distLeft;
          if (attrs.distRight) margin.right += attrs.distRight;
          if (attrs.polygon) {
            let horizontalOffset = floatRight ? attrs.polygon[0][0] || 0 : marginOffset.horizontal + 15;
            let maxX = 0;
            let minX = 0;
            let minY = 0;
            let maxY = 0;
            attrs.polygon.forEach(([x, y]) => {
              if (floatRight && x < horizontalOffset) horizontalOffset = x;
              if (x > maxX) maxX = x;
              if (x < minX) minX = x;
              if (y > maxY) maxY = y;
              if (y < minY) minY = y;
            });
            const originalWidth = maxX - minX;
            const originalHeight = maxY - minY;
            const scaleWidth = Math.min(1, size.width / originalWidth);
            const scaleHeight = Math.min(1, size.height / originalHeight);
            const verticalOffset = Math.max(0, marginOffset.top);
            const points = attrs.polygon
              .map(([x, y]) => `${horizontalOffset + x * scaleWidth}px ${verticalOffset + y * scaleHeight}px`)
              .join(', ');
            style += `shape-outside: polygon(${points});`;
          }
          break;
        }
        case 'TopAndBottom':
          style += 'display: block; clear: both;';
          if (!anchorData) {
            centered = true;
          }
          if (attrs.distTop) margin.top += attrs.distTop;
          if (attrs.distBottom) margin.bottom += attrs.distBottom;
          break;
      }
    }
    const hasAnchorData = Boolean(anchorData);
    const hasMarginOffsets = marginOffset?.horizontal != null || marginOffset?.top != null;
    if (hasAnchorData) {
      switch (anchorData.hRelativeFrom) {
        case 'page':
          const pageStyles =
            this.editor?.converter?.pageStyles || this.editor?.options.parentEditor?.converter?.pageStyles;
          margin.left -= inchesToPixels(pageStyles?.pageMargins?.left) || 0;
          break;
        case 'margin':
          if (anchorData.alignH === 'center') {
            style += 'position: absolute; left: 50%; transform: translateX(-50%);';
          }
          if (anchorData.alignH === 'left' || anchorData.alignH === 'right') {
            style += `position: absolute; ${anchorData.alignH}: 0;`;
          }
          break;
        case 'column':
          if (anchorData.alignH === 'center') {
            centered = true;
          } else if (anchorData.alignH === 'right') {
            floatRight = true;
            if (!style.includes('float: right;')) {
              style += 'float: right;';
            }
          } else if (anchorData.alignH === 'left') {
            if (!style.includes('float: left;')) {
              style += 'float: left;';
            }
          }
          break;
      }
    }
    if (hasAnchorData || hasMarginOffsets) {
      const relativeFromPageV = anchorData?.vRelativeFrom === 'page';
      const maxMarginV = 500;
      const baseTop = Math.max(0, marginOffset?.top ?? 0);
      let rotationHorizontal = 0;
      let rotationTop = 0;
      const { rotation: rotation2 } = transformData ?? {};
      const { height: height2, width: width2 } = size ?? {};
      if (rotation2 && height2 && width2) {
        const { horizontal: horizontal2, vertical } = getRotationMargins(width2, height2, rotation2);
        rotationHorizontal = horizontal2;
        rotationTop = vertical;
      }
      const horizontal = baseHorizontal + rotationHorizontal;
      const top = baseTop + rotationTop;
      if (horizontal) {
        if (floatRight) {
          margin.right += horizontal;
        } else {
          margin.left += horizontal;
        }
      }
      if (top) {
        if (relativeFromPageV && top >= maxMarginV) margin.top += maxMarginV;
        else margin.top += top;
      }
    }
    if (centered) {
      style += 'margin-left: auto; margin-right: auto;';
    } else {
      if (margin.left) style += `margin-left: ${margin.left}px;`;
      if (margin.right) style += `margin-right: ${margin.right}px;`;
    }
    if (margin.top) style += `margin-top: ${margin.top}px;`;
    if (margin.bottom) style += `margin-bottom: ${margin.bottom}px;`;
    const finalAttributes = { ...htmlAttributes };
    if (style) {
      const existingStyle = finalAttributes.style || '';
      finalAttributes.style = existingStyle + (existingStyle ? ' ' : '') + style;
    }
    return ['img', Attribute.mergeAttributes(this.options.htmlAttributes, finalAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert an image at the current position
       * @category Command
       * @param {ImageInsertOptions} options - Image insertion options
       * @example
       * editor.commands.setImage({ src: 'https://example.com/image.jpg' })
       * editor.commands.setImage({
       *   src: 'data:image/png;base64,...',
       *   alt: 'Company logo',
       *   size: { width: 200 }
       * })
       * @note Supports URLs, relative paths, and base64 data URIs
       */
      setImage:
        (options) =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: this.name,
            attrs: options,
          });
        },
      /**
       * Set the wrapping mode and attributes for the selected image
       * @category Command
       * @param {Object} options - Wrapping options
       * @param {string} options.type - Wrap type: "None", "Square", "Through", "Tight", "TopAndBottom", "Inline"
       * @param {Object} [options.attrs] - Wrap attributes (only allowed attributes for the given type will be accepted)
       * @param {string} [options.attrs.wrapText] - Text wrapping mode for Square type: "bothSides", "largest", "left", "right"
       * @param {number} [options.attrs.distTop] - Top distance in pixels
       * @param {number} [options.attrs.distBottom] - Bottom distance in pixels
       * @param {number} [options.attrs.distLeft] - Left distance in pixels
       * @param {number} [options.attrs.distRight] - Right distance in pixels
       * @param {Array} [options.attrs.polygon] - Polygon points for Through/Tight types: [[x1,y1], [x2,y2], ...]
       * @param {boolean} [options.attrs.behindDoc] - Whether image should be behind document text (for wrapNone)
       * @example
       * // No wrapping, behind document
       * editor.commands.setWrapping({ type: 'None', attrs: {behindDoc: true} })
       *
       * // Square wrapping on both sides with distances
       * editor.commands.setWrapping({
       *   type: 'Square',
       *   attrs: {
       *     wrapText: 'bothSides',
       *     distTop: 10,
       *     distBottom: 10,
       *     distLeft: 10,
       *     distRight: 10
       *   }
       * })
       *
       * // Tight wrapping with polygon
       * editor.commands.setWrapping({
       *   type: 'Tight',
       *   attrs: {
       *     polygon: [[0, 0], [100, 0], [100, 100], [0, 100]]
       *   }
       * })
       *
       * // Top and bottom wrapping
       * editor.commands.setWrapping({
       *   type: 'TopAndBottom',
       *   attrs: {
       *     distTop: 15,
       *     distBottom: 15
       *   }
       * })
       */
      setWrapping:
        (options) =>
        ({ chain, state }) => {
          const { selection } = state;
          const { $from } = selection;
          const node = $from.nodeAfter;
          if (!node || node.type.name !== this.name) {
            return false;
          }
          const { type, attrs = {} } = options;
          const allowedAttrs = {};
          const allowedAttributes = {
            None: ['behindDoc'],
            Square: ['wrapText', 'distTop', 'distBottom', 'distLeft', 'distRight'],
            Through: ['distTop', 'distBottom', 'distLeft', 'distRight', 'polygon'],
            Tight: ['distTop', 'distBottom', 'distLeft', 'distRight', 'polygon'],
            TopAndBottom: ['distTop', 'distBottom'],
            Inline: [],
          };
          const allowedForType = allowedAttributes[type] || [];
          Object.keys(attrs).forEach((key2) => {
            if (allowedForType.includes(key2)) {
              allowedAttrs[key2] = attrs[key2];
            }
          });
          const updatedAttrs = {
            ...node.attrs,
            wrap: {
              type,
              attrs: allowedAttrs,
            },
            isAnchor: type !== 'Inline',
          };
          return chain().updateAttributes(this.name, updatedAttrs).run();
        },
    };
  },
  addPmPlugins() {
    return [ImageRegistrationPlugin({ editor: this.editor }), ImagePositionPlugin({ editor: this.editor })];
  },
});
const getDataFromPageStyles = ({ editor, marginOffset, size, attrs }) => {
  let style = '';
  let floatRight = false;
  let baseHorizontal = marginOffset?.horizontal || 0;
  const pageStyles = editor?.converter?.pageStyles || editor?.options.parentEditor?.converter?.pageStyles;
  if (pageStyles?.pageSize && pageStyles?.pageMargins && size.width) {
    const pageWidth = inchesToPixels(pageStyles.pageSize.width);
    const leftMargin = inchesToPixels(pageStyles.pageMargins.left);
    const rightMargin = inchesToPixels(pageStyles.pageMargins.right);
    const contentWidth = pageWidth - leftMargin - rightMargin;
    const imageWidth = size.width + (attrs.distLeft || 0) + (attrs.distRight || 0);
    const leftSpace = marginOffset.horizontal;
    const rightSpace = contentWidth - leftSpace - imageWidth;
    if (rightSpace < 0) {
      style += 'float: left;';
    } else if (rightSpace > leftSpace) {
      style += 'float: left;';
    } else {
      style += 'float: right;';
      floatRight = true;
      baseHorizontal = rightSpace;
    }
  } else {
    style += 'float: left;';
  }
  return {
    style,
    floatRight,
    baseHorizontal,
  };
};
const BookmarkStart = Node$1.create({
  name: 'bookmarkStart',
  group: 'inline',
  content: 'inline*',
  inline: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} BookmarkOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the bookmark element
       */
      htmlAttributes: {
        style: 'height: 0; width: 0;',
        'aria-label': 'Bookmark start node',
        role: 'link',
      },
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [name] - Bookmark name for cross-references and navigation
       */
      name: {
        default: null,
        renderDOM: ({ name }) => {
          if (name) return { name };
          return {};
        },
      },
      /**
       * @category Attribute
       * @param {string} [id] - Unique identifier for the bookmark
       */
      id: {
        default: null,
        renderDOM: ({ id }) => {
          if (id) return { id };
          return {};
        },
      },
    };
  },
  renderDOM({ htmlAttributes }) {
    return ['a', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a bookmark at the current position
       * @category Command
       * @param {BookmarkConfig} config - Bookmark configuration
       * @returns {Function} Command function
       * @example
       * // Insert a named bookmark
       * insertBookmark({ name: 'chapter1' })
       *
       * // Insert with ID
       * insertBookmark({ name: 'introduction', id: 'intro-001' })
       * @note Bookmarks are invisible markers for navigation and cross-references
       */
      insertBookmark:
        (config2) =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: this.name,
            attrs: config2,
          });
        },
      /**
       * Navigate to a bookmark by name
       * @category Command
       * @param {string} name - Bookmark name to navigate to
       * @returns {Function} Command function
       * @example
       * goToBookmark('chapter1')
       * @note Scrolls the document to the bookmark position
       */
      goToBookmark:
        (name) =>
        ({ editor, tr }) => {
          const { doc } = tr;
          let targetPos = null;
          doc.descendants((node, pos) => {
            if (node.type.name === 'bookmarkStart' && node.attrs.name === name) {
              targetPos = pos;
              return false;
            }
          });
          if (targetPos !== null) {
            editor.commands.focus(targetPos);
            return true;
          }
          return false;
        },
    };
  },
});
const BookmarkEnd = Node$1.create({
  name: 'bookmarkEnd',
  group: 'inline',
  inline: true,
  atom: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} BookmarkEndOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the bookmark end element
       */
      htmlAttributes: {
        style: 'height: 0; width: 0; display: none;',
        'aria-label': 'Bookmark end node',
        role: 'none',
      },
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [id] - Unique identifier matching the corresponding bookmarkStart
       */
      id: {
        default: null,
        renderDOM: ({ id }) => {
          if (id) return { 'data-bookmark-end-id': id };
          return {};
        },
      },
      /**
       * @category Attribute
       * @param {string} [displacedByCustomXml] - Indicates if bookmark was displaced by custom XML
       */
      displacedByCustomXml: {
        default: null,
        renderDOM: ({ displacedByCustomXml }) => {
          if (displacedByCustomXml) return { 'data-displaced-by-custom-xml': displacedByCustomXml };
          return {};
        },
      },
      // Pass-through attributes that may not be used in rendering but should be preserved
      colFirst: {
        default: null,
      },
      colLast: {
        default: null,
      },
    };
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a bookmark end marker at the current position
       * @category Command
       * @param {string} id - The bookmark ID to match with bookmarkStart
       * @returns {Function} Command function
       * @example
       * // Insert bookmark end
       * insertBookmarkEnd('bookmark-001')
       */
      insertBookmarkEnd:
        (id) =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: this.name,
            attrs: { id },
          });
        },
    };
  },
});
const Mention = Node$1.create({
  name: 'mention',
  group: 'inline',
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-editor-mention',
        'aria-label': 'Mention node',
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: `span[data-type="${this.name || this.email}"]`,
        getAttrs: (node) => ({
          name: node.getAttribute('name') || null,
          email: node.getAttribute('email') || null,
        }),
      },
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    const { name, email } = node.attrs;
    return [
      'span',
      Attribute.mergeAttributes({ 'data-type': this.name || this.email }, this.options.htmlAttributes, htmlAttributes),
      `@${name ? name : email}`,
    ];
  },
  addAttributes() {
    return {
      name: { default: null },
      email: { default: null },
    };
  },
});
const PageNumber = Node$1.create({
  name: 'page-number',
  group: 'inline',
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  defining: true,
  content: '',
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        'data-id': 'auto-page-number',
        'aria-label': 'Page number node',
      },
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false,
      },
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-page-number"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert an automatic page number
       * @category Command
       * @returns {Function} Command function
       * @example
       * editor.commands.addAutoPageNumber()
       * @note Only works in header/footer contexts
       */
      addAutoPageNumber:
        () =>
        ({ tr, dispatch, state, editor }) => {
          const { options } = editor;
          if (!options.isHeaderOrFooter) return false;
          const { schema } = state;
          const pageNumberType = schema?.nodes?.['page-number'];
          if (!pageNumberType) return false;
          const pageNumberNodeJSON = { type: 'page-number' };
          const pageNumberNode = schema.nodeFromJSON(pageNumberNodeJSON);
          if (dispatch) {
            tr.replaceSelectionWith(pageNumberNode, false);
            if (!isHeadless(editor)) {
              tr.setMeta('forceUpdatePagination', true);
            }
          }
          return true;
        },
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-alt-p': () => this.editor.commands.addAutoPageNumber(),
    };
  },
});
const TotalPageCount = Node$1.create({
  name: 'total-page-number',
  group: 'inline',
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: 'text*',
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        'data-id': 'auto-total-pages',
        'aria-label': 'Total page count node',
        class: 'sd-editor-auto-total-pages',
      },
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false,
      },
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-total-pages"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Insert total page count
       * @category Command
       * @returns {Function} Command function
       * @example
       * editor.commands.addTotalPageCount()
       * @note Only works in header/footer contexts
       */
      addTotalPageCount:
        () =>
        ({ tr, dispatch, state, editor }) => {
          const { options } = editor;
          if (!options.isHeaderOrFooter) return false;
          const { schema } = state;
          const pageNumberType = schema.nodes?.['total-page-number'];
          if (!pageNumberType) return false;
          const currentPages = editor?.options?.parentEditor?.currentTotalPages || 1;
          const pageNumberNode = {
            type: 'total-page-number',
            content: [{ type: 'text', text: String(currentPages) }],
          };
          const pageNode = schema.nodeFromJSON(pageNumberNode);
          if (dispatch) {
            tr.replaceSelectionWith(pageNode, false);
          }
          return true;
        },
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-alt-c': () => this.editor.commands.addTotalPageCount(),
    };
  },
});
const getNodeAttributes = (nodeName, editor) => {
  switch (nodeName) {
    case 'page-number':
      return {
        text: editor.options.currentPageNumber || '1',
        className: 'sd-editor-auto-page-number',
        dataId: 'auto-page-number',
        ariaLabel: 'Page number node',
      };
    case 'total-page-number':
      return {
        text: editor.options.parentEditor?.currentTotalPages || '1',
        className: 'sd-editor-auto-total-pages',
        dataId: 'auto-total-pages',
        ariaLabel: 'Total page count node',
      };
    default:
      return {};
  }
};
class AutoPageNumberNodeView {
  constructor(node, getPos, decorations, editor, htmlAttributes = {}) {
    __privateAdd(this, _AutoPageNumberNodeView_instances);
    this.node = node;
    this.editor = editor;
    this.view = editor.view;
    this.getPos = getPos;
    this.editor = editor;
    this.dom = __privateMethod(this, _AutoPageNumberNodeView_instances, renderDom_fn).call(this, node, htmlAttributes);
  }
  update(node) {
    const incomingType = node?.type?.name;
    const currentType = this.node?.type?.name;
    if (!incomingType || incomingType !== currentType) return false;
    this.node = node;
    return true;
  }
}
_AutoPageNumberNodeView_instances = new WeakSet();
renderDom_fn = function (node, htmlAttributes) {
  const attrs = getNodeAttributes(this.node.type.name, this.editor);
  const content = document.createTextNode(String(attrs.text));
  const nodeContent = document.createElement('span');
  nodeContent.className = attrs.className;
  nodeContent.setAttribute('data-id', attrs.dataId);
  nodeContent.setAttribute('aria-label', attrs.ariaLabel);
  const currentPos = this.getPos();
  const { styles, marks } = getMarksFromNeighbors(currentPos, this.view);
  __privateMethod(this, _AutoPageNumberNodeView_instances, scheduleUpdateNodeStyle_fn).call(this, currentPos, marks);
  Object.assign(nodeContent.style, styles);
  nodeContent.appendChild(content);
  Object.entries(htmlAttributes).forEach(([key2, value]) => {
    if (value) nodeContent.setAttribute(key2, value);
  });
  return nodeContent;
};
scheduleUpdateNodeStyle_fn = function (pos, marks) {
  setTimeout(() => {
    const { state } = this.editor;
    const { dispatch } = this.view;
    const node = state.doc.nodeAt(pos);
    if (!node || node.isText) return;
    const currentMarks = node.attrs.marksAsAttrs || [];
    const newMarks = marks.map((m) => ({ type: m.type.name, attrs: m.attrs }));
    const isEqual = JSON.stringify(currentMarks) === JSON.stringify(newMarks);
    if (isEqual) return;
    const newAttrs = {
      ...node.attrs,
      marksAsAttrs: newMarks,
    };
    const tr = state.tr.setNodeMarkup(pos, void 0, newAttrs);
    dispatch(tr);
  }, 0);
};
const getMarksFromNeighbors = (currentPos, view) => {
  const $pos = view.state.doc.resolve(currentPos);
  const styles = {};
  const marks = [];
  const before = $pos.nodeBefore;
  if (before) {
    Object.assign(styles, processMarks(before.marks));
    marks.push(...before.marks);
  }
  const after = $pos.nodeAfter;
  if (after) {
    Object.assign(styles, { ...styles, ...processMarks(after.marks) });
    marks.push(...after.marks);
  }
  return {
    styles,
    marks,
  };
};
const processMarks = (marks) => {
  const styles = {};
  marks.forEach((mark) => {
    const { type, attrs } = mark;
    switch (type.name) {
      case 'textStyle':
        if (attrs.fontFamily) styles['font-family'] = attrs.fontFamily;
        if (attrs.fontSize) styles['font-size'] = attrs.fontSize;
        if (attrs.color) styles['color'] = attrs.color;
        if (attrs.backgroundColor) styles['background-color'] = attrs.backgroundColor;
        break;
      case 'bold':
        styles['font-weight'] = 'bold';
        break;
      case 'italic':
        styles['font-style'] = 'italic';
        break;
      case 'underline':
        styles['text-decoration'] = (styles['text-decoration'] || '') + ' underline';
        break;
      case 'strike':
        styles['text-decoration'] = (styles['text-decoration'] || '') + ' line-through';
        break;
      default:
        if (attrs?.style) {
          Object.entries(attrs.style).forEach(([key2, value]) => {
            styles[key2] = value;
          });
        }
        break;
    }
  });
  return styles;
};
const PageReference = Node$1.create({
  name: 'pageReference',
  group: 'inline',
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: 'inline*',
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        'data-id': 'auto-page-reference',
        'aria-label': 'Page reference node',
        class: 'sd-editor-page-reference',
      },
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false,
      },
      instruction: {
        default: '',
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-page-reference"]' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
const ShapeContainer = Node$1.create({
  name: 'shapeContainer',
  group: 'block',
  content: 'block+',
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-editor-shape-container',
        'aria-label': 'Shape container node',
      },
    };
  },
  addAttributes() {
    return {
      fillcolor: {
        renderDOM: (attrs) => {
          if (!attrs.fillcolor) return {};
          return {
            style: `background-color: ${attrs.fillcolor}`,
          };
        },
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      style: {
        renderDOM: (attrs) => {
          if (!attrs.style) return {};
          return {
            style: attrs.style,
          };
        },
      },
      wrapAttributes: {
        rendered: false,
      },
      attributes: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`,
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      'div',
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { 'data-type': this.name }),
      0,
    ];
  },
});
const ShapeTextbox = Node$1.create({
  name: 'shapeTextbox',
  group: 'block',
  content: 'paragraph* block*',
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: 'sd-editor-shape-textbox',
        'aria-label': 'Shape textbox node',
      },
    };
  },
  addAttributes() {
    return {
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
      attributes: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`,
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      'div',
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { 'data-type': this.name }),
      0,
    ];
  },
});
const ContentBlock = Node$1.create({
  name: 'contentBlock',
  group: 'inline',
  content: '',
  isolating: true,
  atom: true,
  inline: true,
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
      },
    };
  },
  addAttributes() {
    return {
      horizontalRule: {
        default: false,
        renderDOM: ({ horizontalRule }) => {
          if (!horizontalRule) return {};
          return { 'data-horizontal-rule': 'true' };
        },
      },
      size: {
        default: null,
        renderDOM: ({ size }) => {
          if (!size) return {};
          let style = '';
          if (size.top) style += `top: ${size.top}px; `;
          if (size.left) style += `left: ${size.left}px; `;
          if (size.width) style += `width: ${size.width.toString().endsWith('%') ? size.width : `${size.width}px`}; `;
          if (size.height)
            style += `height: ${size.height.toString().endsWith('%') ? size.height : `${size.height}px`}; `;
          return { style };
        },
      },
      background: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.background) return {};
          return {
            style: `background-color: ${attrs.background}`,
          };
        },
      },
      drawingContent: {
        rendered: false,
      },
      attributes: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`,
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['div', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { 'data-type': this.name })];
  },
  addCommands() {
    return {
      /**
       * Insert a horizontal rule
       * @category Command
       * @example
       * editor.commands.insertHorizontalRule()
       * @note Creates a visual separator between content sections
       */
      insertHorizontalRule:
        () =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: this.name,
            attrs: {
              horizontalRule: true,
              size: { width: '100%', height: 2 },
              background: '#e5e7eb',
            },
          });
        },
      /**
       * Insert a content block
       * @category Command
       * @param {ContentBlockConfig} config - Block configuration
       * @example
       * // Insert a spacer block
       * editor.commands.insertContentBlock({ size: { height: 20 } })
       *
       * @example
       * // Insert a colored divider
       * editor.commands.insertContentBlock({
       *   size: { width: '50%', height: 3 },
       *   background: '#3b82f6'
       * })
       * @note Used for spacing, dividers, and special inline content
       */
      insertContentBlock:
        (config2) =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: this.name,
            attrs: config2,
          });
        },
    };
  },
});
const { findChildren } = helpers;
const SD_BLOCK_ID_ATTRIBUTE_NAME = 'sdBlockId';
const BlockNodePluginKey = new PluginKey('blockNodePlugin');
const BlockNode = Extension.create({
  name: 'blockNode',
  addCommands() {
    return {
      /**
       * Replace a block node by its ID with new content
       * @category Command
       * @param {string} id - The sdBlockId of the node to replace
       * @param {ProseMirrorNode} contentNode - The replacement ProseMirror node
       * @example
       * const newParagraph = editor.schema.nodes.paragraph.create({}, editor.schema.text('New content'))
       * editor.commands.replaceBlockNodeById('block-123', newParagraph)
       * @note The replacement node should have the same type as the original
       */
      replaceBlockNodeById:
        (id, contentNode) =>
        ({ dispatch, tr }) => {
          const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
          if (!blockNode || blockNode.length > 1) {
            return false;
          }
          if (dispatch) {
            let { pos, node } = blockNode[0];
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.replaceWith(newPosFrom, newPosTo, contentNode);
            }
          }
          return true;
        },
      /**
       * Delete a block node by its ID
       * @category Command
       * @param {string} id - The sdBlockId of the node to delete
       * @example
       * editor.commands.deleteBlockNodeById('block-123')
       * @note Completely removes the node from the document
       */
      deleteBlockNodeById:
        (id) =>
        ({ dispatch, tr }) => {
          const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
          if (!blockNode || blockNode.length > 1) {
            return false;
          }
          if (dispatch) {
            let { pos, node } = blockNode[0];
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          }
          return true;
        },
      /**
       * Update attributes of a block node by its ID
       * @category Command
       * @param {string} id - The sdBlockId of the node to update
       * @param {Object} attrs - Attributes to update
       * @example
       * editor.commands.updateBlockNodeAttributes('block-123', { textAlign: 'center' })
       * @example
       * editor.commands.updateBlockNodeAttributes('block-123', { indent: { left: 20 } })
       * @note Merges new attributes with existing ones
       */
      updateBlockNodeAttributes:
        (id, attrs = {}) =>
        ({ dispatch, tr }) => {
          const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
          if (!blockNode || blockNode.length > 1) {
            return false;
          }
          if (dispatch) {
            let { pos, node } = blockNode[0];
            let newPos = tr.mapping.map(pos);
            let currentNode = tr.doc.nodeAt(newPos);
            if (node.eq(currentNode)) {
              tr.setNodeMarkup(newPos, void 0, {
                ...node.attrs,
                ...attrs,
              });
            }
            return true;
          }
        },
    };
  },
  addHelpers() {
    return {
      /**
       * Get all block nodes in the document
       * @category Helper
       * @returns {Array<BlockNodeInfo>} Array of block node info objects
       * @example
       * const blocks = editor.helpers.blockNode.getBlockNodes()
       * console.log(`Found ${blocks.length} block nodes`)
       */
      getBlockNodes: () => {
        return findChildren(this.editor.state.doc, (node) => nodeAllowsSdBlockIdAttr(node));
      },
      /**
       * Get a specific block node by its ID
       * @category Helper
       * @param {string} id - The sdBlockId to search for
       * @returns {Array<BlockNodeInfo>} Array containing the matching node (or empty)
       * @example
       * const block = editor.helpers.blockNode.getBlockNodeById('block-123')
       * if (block.length) console.log('Found:', block[0].node.type.name)
       */
      getBlockNodeById: (id) => {
        return findChildren(this.editor.state.doc, (node) => node.attrs.sdBlockId === id);
      },
      /**
       * Get all block nodes of a specific type
       * @category Helper
       * @param {string} type - The node type name (e.g., 'paragraph', 'heading')
       * @returns {Array<BlockNodeInfo>} Array of matching block nodes
       * @example
       * const paragraphs = editor.helpers.blockNode.getBlockNodesByType('paragraph')
       * const headings = editor.helpers.blockNode.getBlockNodesByType('heading')
       */
      getBlockNodesByType: (type) => {
        return findChildren(this.editor.state.doc, (node) => node.type.name === type);
      },
      /**
       * Get all block nodes within a position range
       * @category Helper
       * @param {number} from - Start position
       * @param {number} to - End position
       * @returns {Array<BlockNodeInfo>} Array of block nodes in the range
       * @example
       * const selection = editor.state.selection
       * const blocksInSelection = editor.helpers.blockNode.getBlockNodesInRange(
       *   selection.from,
       *   selection.to
       * )
       */
      getBlockNodesInRange: (from, to) => {
        let blockNodes = [];
        this.editor.state.doc.nodesBetween(from, to, (node, pos) => {
          if (nodeAllowsSdBlockIdAttr(node)) {
            blockNodes.push({
              node,
              pos,
            });
          }
        });
        return blockNodes;
      },
    };
  },
  addPmPlugins() {
    let hasInitialized = false;
    const assignBlockId = (tr, node, pos) => {
      tr.setNodeMarkup(
        pos,
        void 0,
        {
          ...node.attrs,
          sdBlockId: v4(),
        },
        node.marks,
      );
    };
    return [
      new Plugin({
        key: BlockNodePluginKey,
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
          if (hasInitialized && !docChanges) {
            return;
          }
          if (hasInitialized && !checkForNewBlockNodesInTrs([...transactions])) {
            return;
          }
          const { tr } = newState;
          let changed = false;
          if (!hasInitialized) {
            newState.doc.descendants((node, pos) => {
              if (nodeAllowsSdBlockIdAttr(node) && nodeNeedsSdBlockId(node)) {
                assignBlockId(tr, node, pos);
                changed = true;
              }
            });
          } else {
            const rangesToCheck = [];
            let shouldFallbackToFullTraversal = false;
            transactions.forEach((transaction, txIndex) => {
              transaction.steps.forEach((step, stepIndex) => {
                if (!(step instanceof ReplaceStep)) return;
                const hasNewBlockNodes = step.slice?.content?.content?.some((node) => nodeAllowsSdBlockIdAttr(node));
                if (!hasNewBlockNodes) return;
                const stepMap = step.getMap();
                stepMap.forEach((_oldStart, _oldEnd, newStart, newEnd) => {
                  if (newEnd <= newStart) {
                    if (process.env.NODE_ENV === 'development') {
                      console.debug('Block node: invalid range in step map, falling back to full traversal');
                    }
                    shouldFallbackToFullTraversal = true;
                    return;
                  }
                  let rangeStart = newStart;
                  let rangeEnd = newEnd;
                  for (let i = stepIndex + 1; i < transaction.steps.length; i++) {
                    const laterStepMap = transaction.steps[i].getMap();
                    rangeStart = laterStepMap.map(rangeStart, -1);
                    rangeEnd = laterStepMap.map(rangeEnd, 1);
                  }
                  for (let i = txIndex + 1; i < transactions.length; i++) {
                    const laterTx = transactions[i];
                    rangeStart = laterTx.mapping.map(rangeStart, -1);
                    rangeEnd = laterTx.mapping.map(rangeEnd, 1);
                  }
                  if (rangeEnd <= rangeStart) {
                    if (process.env.NODE_ENV === 'development') {
                      console.debug('Block node: invalid range after mapping, falling back to full traversal');
                    }
                    shouldFallbackToFullTraversal = true;
                    return;
                  }
                  rangesToCheck.push([rangeStart, rangeEnd]);
                });
              });
            });
            const mergedRanges = mergeRanges(rangesToCheck);
            for (const [start, end] of mergedRanges) {
              const docSize = newState.doc.content.size;
              const clampedRange = clampRange(start, end, docSize);
              if (!clampedRange) {
                if (process.env.NODE_ENV === 'development') {
                  console.debug('Block node: invalid range after clamping, falling back to full traversal');
                }
                shouldFallbackToFullTraversal = true;
                break;
              }
              const [safeStart, safeEnd] = clampedRange;
              try {
                newState.doc.nodesBetween(safeStart, safeEnd, (node, pos) => {
                  if (nodeAllowsSdBlockIdAttr(node) && nodeNeedsSdBlockId(node)) {
                    assignBlockId(tr, node, pos);
                    changed = true;
                  }
                });
              } catch (error) {
                console.warn('Block node plugin: nodesBetween failed, falling back to full traversal', error);
                shouldFallbackToFullTraversal = true;
                break;
              }
            }
            if (shouldFallbackToFullTraversal) {
              newState.doc.descendants((node, pos) => {
                if (nodeAllowsSdBlockIdAttr(node) && nodeNeedsSdBlockId(node)) {
                  assignBlockId(tr, node, pos);
                  changed = true;
                }
              });
            }
          }
          if (changed && !hasInitialized) {
            hasInitialized = true;
            tr.setMeta('blockNodeInitialUpdate', true);
          }
          tr.setStoredMarks(newState.tr.storedMarks);
          return changed ? tr : null;
        },
      }),
    ];
  },
});
const nodeAllowsSdBlockIdAttr = (node) => {
  return !!(node?.isBlock && node?.type?.spec?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME]);
};
const nodeNeedsSdBlockId = (node) => {
  const currentId = node?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME];
  return !currentId;
};
const checkForNewBlockNodesInTrs = (transactions) => {
  return Array.from(transactions).some((tr) => {
    return tr.steps.some((step) => {
      if (!(step instanceof ReplaceStep)) return false;
      const hasValidSdBlockNodes = step.slice?.content?.content?.some((node) => nodeAllowsSdBlockIdAttr(node));
      return hasValidSdBlockNodes;
    });
  });
};
const TableOfContents = Node$1.create({
  name: 'tableOfContents',
  group: 'block',
  content: 'paragraph+',
  inline: false,
  addOptions() {
    return {
      htmlAttributes: {
        'data-id': 'table-of-contents',
        'aria-label': 'Table of Contents',
      },
    };
  },
  parseDOM() {
    return [
      {
        tag: 'div[data-id="table-of-contents"]',
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['div', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      instruction: {
        default: null,
        rendered: false,
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute('data-sd-block-id'),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { 'data-sd-block-id': attrs.sdBlockId } : {};
        },
      },
    };
  },
});
var s = {
  accentBorderCallout1: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M -8.333 0 Z L -8.333 100', fill: 'none', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -38.333 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  accentBorderCallout2: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M -8.333 0 Z L -8.333 100', fill: 'none', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -46.667 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  accentBorderCallout3: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M -8.333 0 Z L -8.333 100', fill: 'none', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963', fill: 'none', stroke: '#000000' },
    ],
  },
  accentCallout1: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M -8.333 0 Z L -8.333 100', fill: 'none', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -38.333 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  accentCallout2: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M -8.333 0 Z L -8.333 100', fill: 'none', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -46.667 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  accentCallout3: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M -8.333 0 Z L -8.333 100', fill: 'none', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonBackPrevious: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 50 L 87.5 12.5 L 87.5 87.5 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      { d: 'M 12.5 50 L 87.5 12.5 L 87.5 87.5 Z', fill: 'color-mix(in srgb, currentColor 60%, black)', stroke: 'none' },
      { d: 'M 12.5 50 L 87.5 12.5 L 87.5 87.5 Z', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonBeginning: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 31.25 50 L 87.5 12.5 L 87.5 87.5 Z M 21.875 12.5 L 12.5 12.5 L 12.5 87.5 L 21.875 87.5 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 31.25 50 L 87.5 12.5 L 87.5 87.5 Z M 21.875 12.5 L 12.5 12.5 L 12.5 87.5 L 21.875 87.5 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 31.25 50 L 87.5 12.5 L 87.5 87.5 Z M 21.875 12.5 L 21.875 87.5 L 12.5 87.5 L 12.5 12.5 Z',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonBlank: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  actionButtonDocument: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 21.875 12.5 L 59.375 12.5 L 78.125 31.25 L 78.125 87.5 L 21.875 87.5 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 21.875 12.5 L 59.375 12.5 L 59.375 31.25 L 78.125 31.25 L 78.125 87.5 L 21.875 87.5 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 59.375 12.5 L 59.375 31.25 L 78.125 31.25 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
      },
      {
        d: 'M 21.875 12.5 L 59.375 12.5 L 78.125 31.25 L 78.125 87.5 L 21.875 87.5 Z M 78.125 31.25 L 59.375 31.25 L 59.375 12.5',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonEnd: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 68.75 50 L 12.5 12.5 L 12.5 87.5 Z M 78.125 12.5 L 87.5 12.5 L 87.5 87.5 L 78.125 87.5 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 68.75 50 L 12.5 12.5 L 12.5 87.5 Z M 78.125 12.5 L 87.5 12.5 L 87.5 87.5 L 78.125 87.5 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 68.75 50 L 12.5 87.5 L 12.5 12.5 Z M 78.125 12.5 L 87.5 12.5 L 87.5 87.5 L 78.125 87.5 Z',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonForwardNext: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 87.5 50 L 12.5 12.5 L 12.5 87.5 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      { d: 'M 87.5 50 L 12.5 12.5 L 12.5 87.5 Z', fill: 'color-mix(in srgb, currentColor 60%, black)', stroke: 'none' },
      { d: 'M 87.5 50 L 12.5 87.5 L 12.5 12.5 Z', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonHelp: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 28.571428571428573 33.92857142857143 A 21.428571428571427 21.428571428571427 0 0 1 71.42857142857143 33.92857142857142 A 10.714285714285714 16.071428571428573 0 0 1 60.714285714285715 50 A 5.357142857142857 8.035714285714286 0 0 0 55.35714285714286 58.035714285714285 L 55.357142857142854 68.75 L 44.642857142857146 68.75 L 44.642857142857146 58.035714285714285 A 10.714285714285714 16.071428571428573 0 0 1 55.35714285714286 41.96428571428571 A 5.357142857142857 8.035714285714286 0 0 0 60.714285714285715 33.92857142857142 A 10.714285714285714 10.714285714285714 0 0 0 39.285714285714285 33.92857142857142 Z M 50 71.42857142857143 A 8.035714285714286 8.035714285714286 0 0 1 50 87.50000000000001 A 8.035714285714286 8.035714285714286 0 0 1 50 71.42857142857143 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 28.571428571428573 33.92857142857143 A 21.428571428571427 21.428571428571427 0 0 1 71.42857142857143 33.92857142857142 A 10.714285714285714 16.071428571428573 0 0 1 60.714285714285715 50 A 5.357142857142857 8.035714285714286 0 0 0 55.35714285714286 58.035714285714285 L 55.357142857142854 68.75 L 44.642857142857146 68.75 L 44.642857142857146 58.035714285714285 A 10.714285714285714 16.071428571428573 0 0 1 55.35714285714286 41.96428571428571 A 5.357142857142857 8.035714285714286 0 0 0 60.714285714285715 33.92857142857142 A 10.714285714285714 10.714285714285714 0 0 0 39.285714285714285 33.92857142857142 Z M 50 71.42857142857143 A 8.035714285714286 8.035714285714286 0 0 1 50 87.50000000000001 A 8.035714285714286 8.035714285714286 0 0 1 50 71.42857142857143 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 28.571428571428573 33.92857142857143 A 21.428571428571427 21.428571428571427 0 0 1 71.42857142857143 33.92857142857142 A 10.714285714285714 16.071428571428573 0 0 1 60.714285714285715 50 A 5.357142857142857 8.035714285714286 0 0 0 55.35714285714286 58.035714285714285 L 55.357142857142854 68.75 L 44.642857142857146 68.75 L 44.642857142857146 58.035714285714285 A 10.714285714285714 16.071428571428573 0 0 1 55.35714285714286 41.96428571428571 A 5.357142857142857 8.035714285714286 0 0 0 60.714285714285715 33.92857142857142 A 10.714285714285714 10.714285714285714 0 0 0 39.285714285714285 33.92857142857142 Z M 50 71.42857142857143 A 8.035714285714286 8.035714285714286 0 0 1 50 87.50000000000001 A 8.035714285714286 8.035714285714286 0 0 1 50 71.42857142857143 Z',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonHome: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 50 12.5 L 12.5 50 L 21.875 50 L 21.875 87.5 L 78.125 87.5 L 78.125 50 L 87.5 50 L 73.4375 35.9375 L 73.4375 17.1875 L 64.0625 17.1875 L 64.0625 26.5625 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 73.4375 35.9375 L 73.4375 17.1875 L 64.0625 17.1875 L 64.0625 26.5625 Z M 21.875 50 L 21.875 87.5 L 45.3125 87.5 L 45.3125 68.75 L 54.6875 68.75 L 54.6875 87.5 L 78.125 87.5 L 78.125 50 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 50 12.5 L 12.5 50 L 87.5 50 Z M 45.3125 68.75 L 54.6875 68.75 L 54.6875 87.5 L 45.3125 87.5 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 50 12.5 L 64.0625 26.5625 L 64.0625 17.1875 L 73.4375 17.1875 L 73.4375 35.9375 L 87.5 50 L 78.125 50 L 78.125 87.5 L 21.875 87.5 L 21.875 50 L 12.5 50 Z M 64.0625 26.5625 L 73.4375 35.9375 M 78.125 50 L 21.875 50 M 45.3125 87.5 L 45.3125 68.75 L 54.6875 68.75 L 54.6875 87.5',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonInformation: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 50 12.5 A 37.5 37.5 0 0 1 50.00000000000002 87.5 A 37.5 37.5 0 0 1 49.99999999999999 12.5 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 50 12.5 A 37.5 37.5 0 0 1 50.00000000000002 87.5 A 37.5 37.5 0 0 1 49.99999999999999 12.5 Z M 50 14.84375 A 7.03125 7.03125 0 0 1 50 28.90625 A 7.03125 7.03125 0 0 1 50 14.84375 M 35.9375 35.9375 L 35.9375 40.625 L 42.96875 40.625 L 42.96875 73.4375 L 35.9375 73.4375 L 35.9375 78.125 L 64.0625 78.125 L 64.0625 73.4375 L 57.03125 73.4375 L 57.03125 35.9375 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 50 14.84375 A 7.03125 7.03125 0 0 1 50 28.90625 A 7.03125 7.03125 0 0 1 50 14.84375 M 35.9375 35.9375 L 57.03125 35.9375 L 57.03125 73.4375 L 64.0625 73.4375 L 64.0625 78.125 L 35.9375 78.125 L 35.9375 73.4375 L 42.96875 73.4375 L 42.96875 40.625 L 35.9375 40.625 Z',
        fill: 'color-mix(in srgb, currentColor 60%, white)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 50 12.5 A 37.5 37.5 0 0 1 50.00000000000002 87.5 A 37.5 37.5 0 0 1 49.99999999999999 12.5 Z M 50 14.84375 A 7.03125 7.03125 0 0 1 50 28.90625 A 7.03125 7.03125 0 0 1 50 14.84375 M 35.9375 35.9375 L 57.03125 35.9375 L 57.03125 73.4375 L 64.0625 73.4375 L 64.0625 78.125 L 35.9375 78.125 L 35.9375 73.4375 L 42.96875 73.4375 L 42.96875 40.625 L 35.9375 40.625 Z',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonMovie: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 30.833333333333332 L 12.5 45.677083333333336 L 17.552083333333332 45.677083333333336 L 19.114583333333332 43.982638888888886 L 20.572916666666664 43.982638888888886 L 20.572916666666664 66.63888888888889 L 71.5625 66.63888888888889 L 71.5625 58.826388888888886 L 79.63541666666667 58.826388888888886 L 84.01041666666667 63.125 L 87.5 63.125 L 87.5 35.52083333333333 L 84.01041666666667 35.52083333333333 L 80.98958333333333 38.513888888888886 L 71.5625 38.513888888888886 L 71.5625 35.52083333333333 L 68.59375 32.39583333333333 L 19.114583333333332 32.39583333333333 L 17.552083333333332 30.833333333333332 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 12.5 30.833333333333332 L 12.5 45.677083333333336 L 17.552083333333332 45.677083333333336 L 19.114583333333332 43.982638888888886 L 20.572916666666664 43.982638888888886 L 20.572916666666664 66.63888888888889 L 71.5625 66.63888888888889 L 71.5625 58.826388888888886 L 79.63541666666667 58.826388888888886 L 84.01041666666667 63.125 L 87.5 63.125 L 87.5 35.52083333333333 L 84.01041666666667 35.52083333333333 L 80.98958333333333 38.513888888888886 L 71.5625 38.513888888888886 L 71.5625 35.52083333333333 L 68.59375 32.39583333333333 L 19.114583333333332 32.39583333333333 L 17.552083333333332 30.833333333333332 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
      },
      {
        d: 'M 12.5 30.833333333333332 L 17.552083333333332 30.833333333333332 L 19.114583333333332 32.39583333333333 L 68.59375 32.39583333333333 L 71.5625 35.52083333333333 L 71.5625 38.513888888888886 L 80.98958333333333 38.513888888888886 L 84.01041666666667 35.52083333333333 L 87.5 35.52083333333333 L 87.5 63.125 L 84.01041666666667 63.125 L 79.63541666666667 58.826388888888886 L 71.5625 58.826388888888886 L 71.5625 66.63888888888889 L 20.572916666666664 66.63888888888889 L 20.572916666666664 43.982638888888886 L 19.114583333333332 43.982638888888886 L 17.552083333333332 45.677083333333336 L 12.5 45.677083333333336 Z',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonReturn: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 87.5 31.25 L 68.75 12.5 L 50 31.25 L 59.375 31.25 L 59.375 59.375 A 9.375 9.375 0 0 1 50 68.75 L 40.625 68.75 A 9.375 9.375 0 0 1 31.25 59.375 L 31.25 31.25 L 12.5 31.25 L 12.5 59.375 A 28.125 28.125 0 0 0 40.625 87.5 L 50 87.5 A 28.125 28.125 0 0 0 78.125 59.375 L 78.125 31.25 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 87.5 31.25 L 68.75 12.5 L 50 31.25 L 59.375 31.25 L 59.375 59.375 A 9.375 9.375 0 0 1 50 68.75 L 40.625 68.75 A 9.375 9.375 0 0 1 31.25 59.375 L 31.25 31.25 L 12.5 31.25 L 12.5 59.375 A 28.125 28.125 0 0 0 40.625 87.5 L 50 87.5 A 28.125 28.125 0 0 0 78.125 59.375 L 78.125 31.25 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
      },
      {
        d: 'M 87.5 31.25 L 78.125 31.25 L 78.125 59.375 A 28.125 28.125 0 0 1 50 87.5 L 40.625 87.5 A 28.125 28.125 0 0 1 12.5 59.375 L 12.5 31.25 L 31.25 31.25 L 31.25 59.375 A 9.375 9.375 0 0 0 40.625 68.75 L 50 68.75 A 9.375 9.375 0 0 0 59.375 59.375 L 59.375 31.25 L 50 31.25 L 68.75 12.5 Z',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  actionButtonSound: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 35.9375 L 12.5 64.0625 L 35.9375 64.0625 L 59.375 87.5 L 59.375 12.5 L 35.9375 35.9375 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 12.5 35.9375 L 12.5 64.0625 L 35.9375 64.0625 L 59.375 87.5 L 59.375 12.5 L 35.9375 35.9375 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
      },
      {
        d: 'M 12.5 35.9375 L 35.9375 35.9375 L 59.375 12.5 L 59.375 87.5 L 35.9375 64.0625 L 12.5 64.0625 Z M 68.75 35.9375 L 87.5 21.875 M 68.75 50 L 87.5 50 M 68.75 64.0625 L 87.5 78.125',
        fill: 'none',
        stroke: '#000000',
      },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  arc: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 49.99999999999999 0 A 50 50 0 0 1 100 49.999999999999986', fill: 'none', stroke: '#000000' }],
  },
  bentArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 100 L 0 56.25 A 43.75 43.75 0 0 1 43.74999999999999 12.499999999999993 L 75 12.5 L 75 0 L 100 25 L 75 50 L 75 37.5 L 43.75 37.5 A 18.75 18.75 0 0 0 25 56.25 L 25 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  bentConnector2: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 100 100', fill: 'none', stroke: '#000000' }],
  },
  bentConnector3: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 L 50 100 L 100 100', fill: 'none', stroke: '#000000' }],
  },
  bentConnector4: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 L 50 50 L 100 50 L 100 100', fill: 'none', stroke: '#000000' }],
  },
  bentConnector5: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 L 50 50 L 50 50 L 50 100 L 100 100', fill: 'none', stroke: '#000000' }],
  },
  bentUpArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 75 L 62.5 75 L 62.5 25 L 50 25 L 75 0 L 100 25 L 87.5 25 L 87.5 100 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  bevel: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 12.5 12.5 L 87.5 12.5 L 87.5 87.5 L 12.5 87.5 Z', fill: '#000000', stroke: 'none' },
      {
        d: 'M 0 0 L 100 0 L 87.5 12.5 L 12.5 12.5 Z',
        fill: 'color-mix(in srgb, currentColor 80%, white)',
        stroke: 'none',
      },
      {
        d: 'M 0 100 L 12.5 87.5 L 87.5 87.5 L 100 100 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 0 0 L 12.5 12.5 L 12.5 87.5 L 0 100 Z',
        fill: 'color-mix(in srgb, currentColor 60%, white)',
        stroke: 'none',
      },
      {
        d: 'M 100 0 L 100 100 L 87.5 87.5 L 87.5 12.5 Z',
        fill: 'color-mix(in srgb, currentColor 60%, black)',
        stroke: 'none',
      },
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 12.5 L 87.5 12.5 L 87.5 87.5 L 12.5 87.5 Z M 0 0 L 12.5 12.5 M 0 100 L 12.5 87.5 M 100 0 L 87.5 12.5 M 100 100 L 87.5 87.5',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  blockArc: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50.00000000000001 A 50 50 0 0 1 100 49.999999999999986 L 75 50 A 25 25 0 0 0 25 50 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  borderCallout1: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -38.333 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  borderCallout2: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -46.667 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  borderCallout3: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963', fill: 'none', stroke: '#000000' },
    ],
  },
  bracePair: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.666 100 A 8.333 8.333 0 0 1 8.333 91.667 L 8.333 58.333 A 8.333 8.333 0 0 0 5.102490888647448e-16 50 A 8.333 8.333 0 0 0 8.333 41.667 L 8.333 8.333 A 8.333 8.333 0 0 1 16.666 -1.7763568394002505e-15 L 83.334 0 A 8.333 8.333 0 0 1 91.667 8.332999999999998 L 91.667 41.667 A 8.333 8.333 0 0 0 100 50 A 8.333 8.333 0 0 0 91.667 58.333 L 91.667 91.667 A 8.333 8.333 0 0 1 83.334 100 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 16.666 100 A 8.333 8.333 0 0 1 8.333 91.667 L 8.333 58.333 A 8.333 8.333 0 0 0 5.102490888647448e-16 50 A 8.333 8.333 0 0 0 8.333 41.667 L 8.333 8.333 A 8.333 8.333 0 0 1 16.666 -1.7763568394002505e-15 M 83.334 0 A 8.333 8.333 0 0 1 91.667 8.332999999999998 L 91.667 41.667 A 8.333 8.333 0 0 0 100 50 A 8.333 8.333 0 0 0 91.667 58.333 L 91.667 91.667 A 8.333 8.333 0 0 1 83.334 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  bracketPair: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 16.667 100 A 16.667 16.667 0 0 1 0 83.333 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 16.667 100 A 16.667 16.667 0 0 1 0 83.333 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 M 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  callout1: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M -8.333 18.75 L -38.333 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  callout2: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -46.667 112.5', fill: 'none', stroke: '#000000' },
    ],
  },
  callout3: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963', fill: 'none', stroke: '#000000' },
    ],
  },
  can: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 12.5 A 50 12.5 0 0 0 100 12.499999999999998 L 100 87.5 A 50 12.5 0 0 1 0 87.5 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 0 12.5 A 50 12.5 0 0 1 100 12.499999999999995 A 50 12.5 0 0 1 0 12.499999999999996 Z',
        fill: 'color-mix(in srgb, currentColor 60%, white)',
        stroke: 'none',
      },
      {
        d: 'M 100 12.5 A 50 12.5 0 0 1 0 12.500000000000002 A 50 12.5 0 0 1 100 12.499999999999996 L 100 87.5 A 50 12.5 0 0 1 0 87.5 L 0 12.5',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  chartPlus: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 50 0 L 50 100 M 0 50 L 100 50', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 0 100 L 100 100 L 100 0 Z', fill: '#000000', stroke: 'none' },
    ],
  },
  chartStar: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 100 M 0 100 L 100 0 M 50 0 L 50 100', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 0 100 L 100 100 L 100 0 Z', fill: '#000000', stroke: 'none' },
    ],
  },
  chartX: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 100 M 0 100 L 100 0', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 0 100 L 100 100 L 100 0 Z', fill: '#000000', stroke: 'none' },
    ],
  },
  chevron: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 L 100 50 L 50 100 L 0 100 L 50 50 Z', fill: '#000000', stroke: '#000000' }],
  },
  chord: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 85.35533905932738 85.35533905932738 A 50 50 0 0 1 3.806023374435661 69.1341716182545 A 50 50 0 0 1 49.99999999999999 7.105427357601002e-15 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  circularArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 6.25 50.00000000000001 A 43.75 43.75 0 0 1 92.00503607239835 37.76727975646819 L 97.94870282721459 37.767278803641936 L 87.5 49.99999999999999 L 72.94870282721459 37.767278803641936 L 78.75626944045719 37.767278803641936 A 31.25 31.25 0 0 0 18.74999910786014 49.999997902787435 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  cloud: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 9.027777777777777 33.263888888888886 A 15.631944444444443 21.273148148148145 0 0 1 30.57998957216487 9.85246862529543 A 12.344907407407407 16.82175925925926 0 0 1 47.80891412463702 6.079559020422696 A 10.104166666666666 13.761574074074073 0 0 1 63.17482489729218 3.8997359934452227 A 11.243055555555555 15.266203703703702 0 0 1 81.4699864255032 11.79662680033136 A 12.344907407407407 16.83564814814815 0 0 1 89.70950362413667 36.805045586854234 A 15.68287037037037 21.34259259259259 0 0 1 80.50683519493268 73.45235178627696 A 13.391203703703702 18.21064814814815 0 0 1 61.5295304537904 89.80375312777574 A 15.629629629629628 21.33101851851852 0 0 1 35.53836349121606 96.03429219674027 A 17.87037037037037 24.40509259259259 0 0 1 14.265888824303735 88.73812262075411 A 10.092592592592592 13.699074074074073 0 0 1 7.154178969814962 64.32542955825295 A 10.05787037037037 13.761574074074073 0 0 1 10.355981204179617 37.95132232917963 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 10.863425925925926 60.594907407407405 A 10.05787037037037 13.761574074074073 0 0 1 6.3341973784947445 59.507019673542544 M 16.037037037037035 80.78472222222221 A 10.092592592592592 13.699074074074073 0 0 1 14.058709360103522 81.29044790335425 M 38.14351851851852 90.4861111111111 A 15.629629629629628 21.33101851851852 0 0 1 35.927529327520006 86.22025847613271 M 66.72916666666666 80.44212962962962 A 15.629629629629628 21.33101851851852 0 0 1 65.64350914942649 86.19106007926317 M 79.00231481481481 53.13425925925926 A 13.391203703703702 18.21064814814815 0 0 1 87.87692721942935 70.4768770248552 M 96.75462962962962 35.541666666666664 A 12.344907407407407 16.83564814814815 0 0 1 92.62714666279902 41.3312984002895 M 88.71296296296296 12.560185185185185 A 11.243055555555555 15.266203703703702 0 0 1 89.03277422425806 16.48423239319878 M 67.31018518518518 9.148148148148147 A 11.243055555555555 15.266203703703702 0 0 1 69.59160776727714 5.445361345350392 M 51.25231481481481 10.925925925925926 A 10.104166666666666 13.761574074074073 0 0 1 52.582357388029564 7.102165159074247 M 32.407407407407405 12.018518518518517 A 15.631944444444443 21.273148148148145 0 0 1 35.32846815343311 14.263252515392796 M 9.55324074074074 36.54861111111111 A 15.631944444444443 21.273148148148145 0 0 1 8.640529037810998 32.332858776375595',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  cloudCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 9.027777777777777 33.263888888888886 A 15.631944444444443 21.273148148148145 0 0 1 30.57998957216487 9.85246862529543 A 12.344907407407407 16.82175925925926 0 0 1 47.80891412463702 6.079559020422696 A 10.104166666666666 13.761574074074073 0 0 1 63.17482489729218 3.8997359934452227 A 11.243055555555555 15.266203703703702 0 0 1 81.4699864255032 11.79662680033136 A 12.344907407407407 16.83564814814815 0 0 1 89.70950362413667 36.805045586854234 A 15.68287037037037 21.34259259259259 0 0 1 80.50683519493268 73.45235178627696 A 13.391203703703702 18.21064814814815 0 0 1 61.5295304537904 89.80375312777574 A 15.629629629629628 21.33101851851852 0 0 1 35.53836349121606 96.03429219674027 A 17.87037037037037 24.40509259259259 0 0 1 14.265888824303735 88.73812262075411 A 10.092592592592592 13.699074074074073 0 0 1 7.154178969814962 64.32542955825295 A 10.05787037037037 13.761574074074073 0 0 1 10.355981204179617 37.95132232917963 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 31.94477777777778 112.5 A 2.7777777777777777 2.7777777777777777 0 0 1 26.389222222222223 112.5 A 2.7777777777777777 2.7777777777777777 0 0 1 31.94477777777778 112.5 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 35.81090347544299 109.23490399880167 A 5.555555555555555 5.555555555555555 0 0 1 24.699792364331877 109.23490399880167 A 5.555555555555555 5.555555555555555 0 0 1 35.81090347544299 109.23490399880167 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 41.43382479714197 100.69933679796284 A 8.333333333333334 8.333333333333334 0 0 1 24.767158130475302 100.69933679796284 A 8.333333333333334 8.333333333333334 0 0 1 41.43382479714197 100.69933679796284 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 10.863425925925926 60.594907407407405 A 10.05787037037037 13.761574074074073 0 0 1 6.3341973784947445 59.507019673542544 M 16.037037037037035 80.78472222222221 A 10.092592592592592 13.699074074074073 0 0 1 14.058709360103522 81.29044790335425 M 38.14351851851852 90.4861111111111 A 15.629629629629628 21.33101851851852 0 0 1 35.927529327520006 86.22025847613271 M 66.72916666666666 80.44212962962962 A 15.629629629629628 21.33101851851852 0 0 1 65.64350914942649 86.19106007926317 M 79.00231481481481 53.13425925925926 A 13.391203703703702 18.21064814814815 0 0 1 87.87692721942935 70.4768770248552 M 96.75462962962962 35.541666666666664 A 12.344907407407407 16.83564814814815 0 0 1 92.62714666279902 41.3312984002895 M 88.71296296296296 12.560185185185185 A 11.243055555555555 15.266203703703702 0 0 1 89.03277422425806 16.48423239319878 M 67.31018518518518 9.148148148148147 A 11.243055555555555 15.266203703703702 0 0 1 69.59160776727714 5.445361345350392 M 51.25231481481481 10.925925925925926 A 10.104166666666666 13.761574074074073 0 0 1 52.582357388029564 7.102165159074247 M 32.407407407407405 12.018518518518517 A 15.631944444444443 21.273148148148145 0 0 1 35.32846815343311 14.263252515392796 M 9.55324074074074 36.54861111111111 A 15.631944444444443 21.273148148148145 0 0 1 8.640529037810998 32.332858776375595',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  corner: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 L 50 50 L 100 50 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  cornerTabs: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 7.0710678118654755 0 L 0 7.0710678118654755 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M 0 92.92893218813452 L 7.0710678118654755 100 L 0 100 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M 92.92893218813452 0 L 100 0 L 100 7.0710678118654755 Z', fill: '#000000', stroke: '#000000' },
      { d: 'M 100 92.92893218813452 L 100 100 L 92.92893218813452 100 Z', fill: '#000000', stroke: '#000000' },
    ],
  },
  cube: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 25 L 75 25 L 75 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M 75 25 L 100 0 L 100 75 L 75 100 Z', fill: 'color-mix(in srgb, currentColor 80%, black)', stroke: 'none' },
      { d: 'M 0 25 L 25 0 L 100 0 L 75 25 Z', fill: 'color-mix(in srgb, currentColor 80%, white)', stroke: 'none' },
      {
        d: 'M 0 25 L 25 0 L 100 0 L 100 75 L 75 100 L 0 100 Z M 0 25 L 75 25 L 100 0 M 75 25 L 75 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  curvedConnector2: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 C 50 0 100 50 100 100', fill: 'none', stroke: '#000000' }],
  },
  curvedConnector3: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 C 25 0 50 25 50 50 C 50 75 75 100 100 100', fill: 'none', stroke: '#000000' }],
  },
  curvedConnector4: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 C 25 0 50 12.5 50 25 C 50 37.5 62.5 50 75 50 C 87.5 50 100 75 100 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  curvedConnector5: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 C 25 0 50 12.5 50 25 C 50 37.5 50 50 50 50 C 50 50 50 62.5 50 75 C 50 87.5 75 100 100 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  curvedDownArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 75 100 L 49.00768239224544 75 L 61.50768239224544 75 A 31.25 100 0 0 0 37.416898858120966 38.6950051637524 L 56.25 0 A 31.25 100 0 0 1 80.34078353412448 36.304994836247616 L 99.00768239224544 75 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 43.75 8.348486100883193 A 31.25 100 0 0 0 16.722972521631938 107.43120402663949 L 0 100 A 31.25 100 0 0 1 35.47297252163195 0.9172820742437011 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 43.75 8.348486100883193 A 31.25 100 0 0 0 16.722972521631938 107.43120402663949 L 0 100 A 31.25 100 0 0 1 31.249999999999993 -1.4210854715202004e-14 L 56.25 0 A 31.25 100 0 0 1 80.34078353412448 36.304994836247616 L 99.00768239224544 75 L 75 100 L 49.00768239224544 75 L 61.50768239224544 75 A 31.25 100 0 0 0 37.416898858120966 38.6950051637524',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  curvedLeftArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 75 L 25 49.00768239224544 L 25 61.50768239224544 A 100 31.25 0 0 0 60.38771276200397 41.63987137975289 A 100 31.25 0 0 1 25.00000000000007 69.9536274355093 L 25 99.00768239224544 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 100 56.25 A 100 31.25 0 0 0 6.123233995736766e-15 25 L 0 0 A 100 31.25 0 0 1 100.00000000000001 31.249999999999993 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 100 56.25 A 100 31.25 0 0 0 6.123233995736766e-15 25 L 0 0 A 100 31.25 0 0 1 100.00000000000001 31.249999999999993 L 100 56.25 A 100 31.25 0 0 1 63.69500516375231 80.34078353412448 L 25 99.00768239224544 L 0 75 L 25 49.00768239224544 L 25 61.50768239224544 A 100 31.25 0 0 0 60.38771276200397 41.63987137975289',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  curvedRightArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 31.25 A 100 31.25 0 0 0 36.30499483624771 55.34078353412449 L 75 49.00768239224544 L 100 75 L 75 99.00768239224544 L 75 86.50768239224544 A 100 31.25 0 0 1 38.695005163752285 62.41689885812095 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 100 25 A 100 31.25 0 0 0 0.9172820742437295 52.02702747836806 A 100 31.25 0 0 1 100 16.55405495673611 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 0 31.25 A 100 31.25 0 0 0 36.30499483624771 55.34078353412449 L 75 49.00768239224544 L 100 75 L 75 99.00768239224544 L 75 86.50768239224544 A 100 31.25 0 0 1 38.695005163752285 62.41689885812095 L 0 31.25 A 100 31.25 0 0 1 99.99999999999999 -3.552713678800501e-15 L 100 25 A 100 31.25 0 0 0 0.9172820742437295 52.02702747836806',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  curvedUpArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 75 0 L 99.00768239224544 25 L 86.50768239224544 25 A 31.25 100 0 0 1 58.19392633648901 60.38771276200398 A 31.25 100 0 0 0 78.06173734898155 25 L 49.00768239224544 25 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 31.25 100 A 31.25 100 0 0 1 -3.552713678800501e-15 1.2246467991473532e-14 L 25 0 A 31.25 100 0 0 0 56.25 99.99999999999999 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 43.75 91.65151389911681 A 31.25 100 0 0 0 63.61781101249255 56.26380113711283 L 49.00768239224544 25 L 75 0 L 99.00768239224544 25 L 86.50768239224544 25 A 31.25 100 0 0 1 62.41689885812095 61.304994836247694 L 31.25 100 A 31.25 100 0 0 1 -3.552713678800501e-15 1.2246467991473532e-14 L 25 0 A 31.25 100 0 0 0 56.25 99.99999999999999',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  decagon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 9.54915028125263 19.09836593122781 L 34.54915028125263 0.00010576881489043899 L 65.45084971874738 0.00010576881489043899 L 90.45084971874738 19.09836593122781 L 100 50 L 90.45084971874738 80.90163406877218 L 65.45084971874738 99.99989423118511 L 34.54915028125263 99.99989423118511 L 9.54915028125263 80.90163406877218 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  diagStripe: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 50 L 50 0 L 100 0 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  diamond: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 50 L 50 0 L 100 50 L 50 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  dodecagon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 36.601851851851855 L 13.398148148148149 13.398148148148149 L 36.601851851851855 0 L 63.398148148148145 0 L 86.60185185185185 13.398148148148149 L 100 36.601851851851855 L 100 63.398148148148145 L 86.60185185185185 86.60185185185185 L 63.398148148148145 100 L 36.601851851851855 100 L 13.398148148148149 86.60185185185185 L 0 63.398148148148145 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  donut: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z M 25 50 A 25 25 0 0 0 50 75 A 25 25 0 0 0 75 50 A 25 25 0 0 0 50 25 A 25 25 0 0 0 25.000000000000007 50 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  doubleWave: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 6.25 C 16.666666666666668 -14.583333333333332 33.333333333333336 27.083333333333332 50 6.25 C 66.66666666666667 -14.583333333333332 83.33333333333334 27.083333333333332 100 6.25 L 100 93.75 C 83.33333333333334 114.58333333333333 66.66666666666667 72.91666666666667 50 93.75 C 33.333333333333336 114.58333333333333 16.666666666666668 72.91666666666667 0 93.75 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  downArrow: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 50 L 25 50 L 25 0 L 75 0 L 75 50 L 100 50 L 50 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  downArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 64.977 L 62.5 64.977 L 62.5 75 L 75 75 L 50 100 L 25 75 L 37.5 75 L 37.5 64.977 L 0 64.977 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  ellipse: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  ellipseRibbon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 Q 18.75 9.375 37.5 11.71875 L 25 21.875 Q 50 28.125 75 21.875 L 62.5 11.71875 Q 81.25 9.375 100 0 L 87.5 42.96875 L 100 75 Q 87.5 81.25 75 84.375 L 75 96.875 Q 50 103.125 25 96.875 L 25 84.375 Q 12.5 81.25 0 75 L 12.5 42.96875 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 37.5 24.21875 L 37.5 11.71875 L 25 21.875 Q 50 28.125 75 21.875 L 62.5 11.71875 L 62.5 24.21875 Q 50 25.78125 37.5 24.21875 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 0 0 Q 18.75 9.375 37.5 11.71875 L 25 21.875 Q 50 28.125 75 21.875 L 62.5 11.71875 Q 81.25 9.375 100 0 L 87.5 42.96875 L 100 75 Q 87.5 81.25 75 84.375 L 75 96.875 Q 50 103.125 25 96.875 L 25 84.375 Q 12.5 81.25 0 75 L 12.5 42.96875 Z M 25 84.375 L 25 21.875 M 75 21.875 L 75 84.375 M 37.5 11.71875 L 37.5 24.21875 M 62.5 24.21875 L 62.5 11.71875',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  ellipseRibbon2: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 100 Q 18.75 90.625 37.5 88.28125 L 25 78.125 Q 50 71.875 75 78.125 L 62.5 88.28125 Q 81.25 90.625 100 100 L 87.5 57.03125 L 100 25 Q 87.5 18.75 75 15.625 L 75 3.125 Q 50 -3.125 25 3.125 L 25 15.625 Q 12.5 18.75 0 25 L 12.5 57.03125 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 37.5 75.78125 L 37.5 88.28125 L 25 78.125 Q 50 71.875 75 78.125 L 62.5 88.28125 L 62.5 75.78125 Q 50 74.21875 37.5 75.78125 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 0 100 L 12.5 57.03125 L 0 25 Q 12.5 18.75 25 15.625 L 25 3.125 Q 50 -3.125 75 3.125 L 75 15.625 Q 87.5 18.75 100 25 L 87.5 57.03125 L 100 100 Q 81.25 90.625 62.5 88.28125 L 75 78.125 Q 50 71.875 25 78.125 L 37.5 88.28125 Q 18.75 90.625 0 100 Z M 25 78.125 L 25 15.625 M 75 15.625 L 75 78.125 M 37.5 75.78125 L 37.5 88.28125 M 62.5 88.28125 L 62.5 75.78125',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  flowChartAlternateProcess: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 A 0 0 0 0 1 0 0 L 100 0 A 0 0 0 0 1 100 0 L 100 100 A 0 0 0 0 1 100 100 L 0 100 A 0 0 0 0 1 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartCollate: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 50 50 L 100 100 L 0 100 L 50 50 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartConnector: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartDecision: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 50 L 50 0 L 100 50 L 50 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartDelay: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 A 50 50 0 0 1 50.00000000000002 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartDisplay: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 16.666666666666668 0 L 83.33333333333334 0 A 16.666666666666668 50 0 0 1 83.33333333333334 100 L 16.666666666666668 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartDocument: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 80.19444444444444 C 50 80.19444444444444 50 110.75 0 93.38888888888889 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartExtract: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 50 0 L 100 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartInputOutput: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 20 0 L 100 0 L 80 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartInternalStorage: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M 12.5 0 L 12.5 100 M 0 12.5 L 100 12.5', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  flowChartMagneticDisk: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 16.666666666666668 A 50 16.666666666666668 0 0 1 100 16.66666666666666 L 100 83.33333333333334 A 50 16.666666666666668 0 0 1 0 83.33333333333334 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 100 16.666666666666668 A 50 16.666666666666668 0 0 1 0 16.66666666666667',
        fill: 'none',
        stroke: '#000000',
      },
      {
        d: 'M 0 16.666666666666668 A 50 16.666666666666668 0 0 1 100 16.66666666666666 L 100 83.33333333333334 A 50 16.666666666666668 0 0 1 0 83.33333333333334 Z',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  flowChartMagneticDrum: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.666666666666668 0 L 83.33333333333334 0 A 16.666666666666668 50 0 0 1 83.33333333333334 100 L 16.666666666666668 100 A 16.666666666666668 50 0 0 1 16.666666666666664 0 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 83.33333333333334 100 A 16.666666666666668 50 0 0 1 83.33333333333334 0',
        fill: 'none',
        stroke: '#000000',
      },
      {
        d: 'M 16.666666666666668 0 L 83.33333333333334 0 A 16.666666666666668 50 0 0 1 83.33333333333334 100 L 16.666666666666668 100 A 16.666666666666668 50 0 0 1 16.666666666666664 0 Z',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  flowChartMagneticTape: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 50 100 A 50 50 0 0 1 0 50.00000000000001 A 50 50 0 0 1 49.99999999999999 0 A 50 50 0 0 1 100 49.999999999999986 A 50 50 0 0 1 85.35533905932738 85.35533905932735 L 100 85.35533905932738 L 100 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartManualInput: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 20 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartManualOperation: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 80 100 L 20 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartMerge: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 50 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartMultidocument: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 96.21296296296296 C 43.04629629629629 108.99074074074073 43.04629629629629 83.43518518518518 86.08796296296296 83.43518518518518 L 86.08796296296296 17.01388888888889 L 0 17.01388888888889 Z M 7.092592592592593 17.01388888888889 L 7.092592592592593 8.402777777777777 L 92.59259259259258 8.402777777777777 L 92.59259259259258 75.24074074074073 C 89.34259259259258 75.24074074074073 86.08796296296296 75.7037037037037 86.08796296296296 75.7037037037037 L 86.08796296296296 17.01388888888889 Z M 13.759259259259258 8.402777777777777 L 13.759259259259258 0 L 100 0 L 100 66.62962962962962 C 96.29629629629629 66.62962962962962 92.59259259259258 66.97685185185185 92.59259259259258 66.97685185185185 L 92.59259259259258 8.402777777777777 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 0 17.01388888888889 L 86.08796296296296 17.01388888888889 L 86.08796296296296 83.43518518518518 C 43.04629629629629 83.43518518518518 43.04629629629629 108.99074074074073 0 96.21296296296296 Z M 7.092592592592593 17.01388888888889 L 7.092592592592593 8.402777777777777 L 92.59259259259258 8.402777777777777 L 92.59259259259258 75.24074074074073 C 89.34259259259258 75.24074074074073 86.08796296296296 75.7037037037037 86.08796296296296 75.7037037037037 M 13.759259259259258 8.402777777777777 L 13.759259259259258 0 L 100 0 L 100 66.62962962962962 C 96.29629629629629 66.62962962962962 92.59259259259258 66.97685185185185 92.59259259259258 66.97685185185185',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  flowChartOfflineStorage: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 50 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M 40 80 L 60 80', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 100 0 L 50 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  flowChartOffpageConnector: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 100 80 L 50 100 L 0 80 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartOnlineStorage: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.666666666666668 0 L 100 0 A 16.666666666666668 50 0 0 0 100 100 L 16.666666666666668 100 A 16.666666666666668 50 0 0 1 16.666666666666664 0 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartOr: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z',
        fill: '#000000',
        stroke: 'none',
      },
      { d: 'M 50 0 L 50 100 M 0 50 L 100 50', fill: 'none', stroke: '#000000' },
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  flowChartPredefinedProcess: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M 12.5 0 L 12.5 100 M 87.5 0 L 87.5 100', fill: 'none', stroke: '#000000' },
      { d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  flowChartPreparation: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 50 L 20 0 L 80 0 L 100 50 L 80 100 L 20 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartProcess: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartPunchedCard: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 20 L 20 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  flowChartPunchedTape: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 10 A 25 10 0 0 0 50 9.999999999999998 A 25 10 0 0 1 100 9.999999999999995 L 100 90 A 25 10 0 0 0 50 90 A 25 10 0 0 1 0 90 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  flowChartSort: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 50 L 50 0 L 100 50 L 50 100 Z', fill: '#000000', stroke: 'none' },
      { d: 'M 0 50 L 100 50', fill: 'none', stroke: '#000000' },
      { d: 'M 0 50 L 50 0 L 100 50 L 50 100 Z', fill: 'none', stroke: '#000000' },
    ],
  },
  flowChartSummingJunction: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 14.644660940672622 14.64466094067263 L 85.35533905932738 85.35533905932738 M 85.35533905932738 14.64466094067263 L 14.644660940672622 85.35533905932738',
        fill: 'none',
        stroke: '#000000',
      },
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  flowChartTerminator: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.087962962962962 0 L 83.91203703703704 0 A 16.087962962962962 50 0 0 1 83.91203703703704 100 L 16.087962962962962 100 A 16.087962962962962 50 0 0 1 16.08796296296296 0 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  foldedCorner: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 0 L 100 0 L 100 83.333 L 83.333 100 L 0 100 Z', fill: '#000000', stroke: 'none' },
      {
        d: 'M 83.333 100 L 86.6664 86.6664 L 100 83.333 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 83.333 100 L 86.6664 86.6664 L 100 83.333 L 83.333 100 L 0 100 L 0 0 L 100 0 L 100 83.333',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  frame: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 12.5 L 12.5 87.5 L 87.5 87.5 L 87.5 12.5 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  funnel: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0.4865947579902823 28.47932110261916 A 50 25 0 0 1 50.363602241574895 1.7268853347203788 A 50 25 0 0 1 100.24060972515952 28.47932110261915 L 62.37835131050243 94.61983027565479 A 12.5 6.25 0 0 1 37.43984756871012 94.61983027565479 Z M 5 25 A 45 20 0 0 0 95 24.999999999999996 A 45 20 0 0 0 5 24.999999999999993 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  gear6: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 74.82470053891974 25.327459734495154 L 89.57808159568633 20.881065308239084 L 95.0067779720481 30.283843250962747 L 83.77939691528152 40.83744882470668 A 35 35 0 0 1 83.77939691528152 59.16255117529331 L 95.0067779720481 69.71615674903725 L 89.57808159568633 79.11893469176091 L 74.82470053891974 74.67254026550485 A 35 35 0 0 1 58.954696376361774 83.83509144079817 L 55.42869637636177 98.83509144079817 L 44.57130362363823 98.83509144079817 L 41.045303623638226 83.83509144079817 A 35 35 0 0 1 25.175299461080265 74.67254026550485 L 10.421918404313672 79.11893469176091 L 4.9932220279519015 69.71615674903725 L 16.220603084718476 59.16255117529332 A 35 35 0 0 1 16.22060308471847 40.837448824706684 L 4.9932220279519015 30.283843250962747 L 10.421918404313672 20.881065308239084 L 25.175299461080257 25.327459734495154 A 35 35 0 0 1 41.04530362363821 16.16490855920184 L 44.57130362363823 1.1649085592018338 L 55.42869637636177 1.1649085592018338 L 58.954696376361774 16.164908559201834 A 35 35 0 0 1 74.82470053891973 25.327459734495143 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  gear9: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 70.98043216644243 15.943848336764354 L 78.75884461652657 9.416638461451942 L 84.97288812699333 14.630840079204173 L 79.89554838334669 23.424519066271323 A 40 40 0 0 1 87.96281579807138 37.3974361068193 L 98.11703506542025 37.397170398710514 L 99.52564437161423 45.38579074787268 L 89.98370857871895 48.85848859310251 A 40 40 0 0 1 87.18197600808145 64.74790358438975 L 94.96073004592583 71.27470637126171 L 90.90480119853021 78.2997812068352 L 81.36304716068582 74.82658399370717 A 40 40 0 0 1 69.00327641227653 85.19766307013315 L 70.76679975508767 95.19757079067537 L 63.14414693842693 97.97198952208531 L 58.06726741472468 89.17804482690939 A 40 40 0 0 1 41.93273258527532 89.17804482690939 L 36.85585306157307 97.97198952208531 L 29.233200244912325 95.19757079067537 L 30.996723587723466 85.19766307013313 A 40 40 0 0 1 18.636952839314183 74.82658399370717 L 9.095198801469792 78.2997812068352 L 5.039269954074172 71.27470637126171 L 12.818023991918551 64.74790358438975 A 40 40 0 0 1 10.016291421281053 48.85848859310253 L 0.4743556283857657 45.38579074787268 L 1.8829649345797463 37.397170398710514 L 12.037184201928625 37.39743610681929 A 40 40 0 0 1 20.104451616653293 23.42451906627133 L 15.027111873006675 14.630840079204173 L 21.241155383473426 9.416638461451942 L 29.019567833557574 15.943848336764354 A 40 40 0 0 1 44.18107115260436 10.425512421903086 L 45.944071152604366 0.42551242190308614 L 54.055928847395634 0.42551242190308614 L 55.81892884739563 10.425512421903086 A 40 40 0 0 1 70.98043216644243 15.943848336764354 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  halfFrame: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 100 0 L 66.667 33.333 L 33.333 33.333 L 33.333 66.667 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  heart: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 50 25 C 70.83333333333333 -33.333333333333336 152.08333333333331 25 50 100 C -52.08333333333333 25 29.166666666666668 -33.333333333333336 50 25 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  heptagon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M -0.0002599799999956076 64.3106646 L 9.903066619999997 19.806308549999997 L 50 0 L 90.09693338 19.806308549999997 L 100.00025998 64.3106646 L 72.25196968 100.00052685 L 27.74803032 100.00052685 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  hexagon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 25 0.00002331250544074237 L 75 0.00002331250544074237 L 100 50 L 75 99.99997668749455 L 25 99.99997668749455 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  homePlate: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 50 0 L 100 50 L 50 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  horizontalScroll: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 100 6.25 A 6.25 6.25 0 0 1 93.75 12.5 L 93.75 6.25 A 3.125 3.125 0 0 1 87.5 6.25 L 87.5 12.5 L 6.25 12.5 A 6.25 6.25 0 0 0 8.881784197001252e-16 18.75 L 0 93.75 A 6.25 6.25 0 0 0 12.5 93.75 L 12.5 87.5 L 93.75 87.5 A 6.25 6.25 0 0 0 100 81.25 Z M 6.25 25 A 6.25 6.25 0 0 0 12.5 18.75 A 3.125 3.125 0 0 0 6.25 18.75 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 6.25 25 A 6.25 6.25 0 0 0 12.5 18.75 A 3.125 3.125 0 0 0 6.25 18.75 Z M 93.75 12.5 A 6.25 6.25 0 0 0 98.16941738241593 1.8305826175840787 A 6.25 6.25 0 0 0 87.5 6.249999999999999 A 3.125 3.125 0 0 0 93.75 6.249999999999999 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 0 18.75 A 6.25 6.25 0 0 1 6.249999999999999 12.5 L 87.5 12.5 L 87.5 6.25 A 6.25 6.25 0 0 1 100 6.249999999999997 L 100 81.25 A 6.25 6.25 0 0 1 93.75 87.5 L 12.5 87.5 L 12.5 93.75 A 6.25 6.25 0 0 1 0 93.75 Z M 87.5 12.5 L 93.75 12.5 A 6.25 6.25 0 0 0 100 6.25 M 93.75 12.5 L 93.75 6.25 A 3.125 3.125 0 0 1 87.5 6.25 M 6.25 25 L 6.25 18.75 A 3.125 3.125 0 0 1 12.5 18.75 A 6.25 6.25 0 0 1 0 18.75 M 12.5 18.75 L 12.5 87.5',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  irregularSeal1: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 50 26.85185185185185 L 67.23148148148148 0 L 65.5324074074074 24.652777777777775 L 85.09259259259258 20.63425925925926 L 77.32407407407408 33.86574074074074 L 97.67129629629629 37.6712962962963 L 81.51388888888889 48.49537037037037 L 100 61.52777777777777 L 77.94907407407408 59.916666666666664 L 84.00462962962962 83.77314814814814 L 64.9074074074074 66.93055555555556 L 61.3287037037037 91.375 L 48.75925925925926 69.14351851851852 L 39.282407407407405 100 L 35.71759259259259 72.34722222222221 L 22.046296296296294 81.56018518518518 L 26.23611111111111 64.52314814814814 L 0.625 67.5324074074074 L 17.23148148148148 54.513888888888886 L 0 39.88425925925926 L 21.421296296296294 35.263888888888886 L 1.7129629629629628 10.625 L 33.85185185185185 29.259259259259256 L 38.666666666666664 10.625 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  irregularSeal2: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 53.06481481481481 20.10185185185185 L 68.47222222222221 0 L 67.24537037037037 26.74537037037037 L 83.36574074074073 14.685185185185185 L 75.83333333333333 30.24074074074074 L 100 30.763888888888886 L 78.63425925925925 43.52777777777778 L 84.58333333333333 52.26851851851852 L 75.83333333333333 56.99074074074074 L 87.39351851851852 72.37037037037037 L 67.77777777777777 66.43518518518518 L 69.17592592592592 80.41666666666666 L 56.388888888888886 73.77314814814814 L 53.75925925925926 87.23148148148148 L 45.7037037037037 80.41666666666666 L 40.27777777777778 91.25925925925925 L 34.84722222222222 83.91203703703704 L 22.76388888888889 100 L 22.24537037037037 84.44444444444444 L 5.9490740740740735 82.52314814814814 L 15.416666666666666 71.1574074074074 L 0 59.61574074074074 L 18.21759259259259 53.666666666666664 L 5.425925925925926 38.28703703703704 L 24.87037037037037 36.18981481481481 L 20.84259259259259 16.782407407407405 L 39.58333333333333 29.546296296296294 L 45.00925925925926 8.73611111111111 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftArrow: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 50 L 50 0 L 50 25 L 100 25 L 100 75 L 50 75 L 50 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  leftArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 25 25 L 25 37.5 L 35.022999999999996 37.5 L 35.022999999999996 0 L 100 0 L 100 100 L 35.022999999999996 100 L 35.022999999999996 62.5 L 25 62.5 L 25 75 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftBrace: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 100 100 A 50 8.333 0 0 1 50 91.667 L 50 58.333 A 50 8.333 0 0 0 3.061616997868383e-15 50 A 50 8.333 0 0 0 50 41.667 L 50 8.333 A 50 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 100 100 A 50 8.333 0 0 1 50 91.667 L 50 58.333 A 50 8.333 0 0 0 3.061616997868383e-15 50 A 50 8.333 0 0 0 50 41.667 L 50 8.333 A 50 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  leftBracket: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 100 100 A 100 8.333 0 0 1 0 91.667 L 0 8.333 A 100 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 100 100 A 100 8.333 0 0 1 0 91.667 L 0 8.333 A 100 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  leftCircularArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 6.25 50.00000000000001 L 18.75 50.00000000000001 A 31.25 31.25 0 0 0 78.75627033259704 62.2327190991455 L 72.94870282721459 62.232721196358064 L 87.5 50 L 97.94870282721459 62.232721196358064 L 92.00503579491598 62.232721196358064 A 43.75 43.75 0 0 1 6.249999722517629 50.00000095282626 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftRightArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 50 0 L 50 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 50 75 L 50 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftRightArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 25 25 L 25 37.5 L 25.9385 37.5 L 25.9385 0 L 74.0615 0 L 74.0615 37.5 L 75 37.5 L 75 25 L 100 50 L 75 75 L 75 62.5 L 74.0615 62.5 L 74.0615 100 L 25.9385 100 L 25.9385 62.5 L 25 62.5 L 25 75 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftRightCircularArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 12.5 50.00000000000001 L 2.0512971727853966 37.76727880364194 L 7.9949639276016455 37.767279756468184 A 43.75 43.75 0 0 1 92.00503607239835 37.76727975646819 L 97.94870282721459 37.767278803641936 L 87.5 49.99999999999999 L 72.94870282721459 37.767278803641936 L 78.75626944045719 37.767278803641936 A 31.25 31.25 0 0 0 21.243728775263097 37.76727880364193 L 27.051297172785397 37.76727880364194 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftRightRibbon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 41.6665 L 46.875 0 L 46.875 16.6665 L 50 16.6665 A 3.125 4.16675 0 0 1 50 25 A 3.125 4.16675 0 0 0 50 33.3335 L 53.125 33.3335 L 53.125 16.667 L 100 58.3335 L 53.125 100 L 53.125 83.3335 L 50 83.3335 A 3.125 4.16675 0 0 1 46.875 79.16675000000001 L 46.875 66.6665 L 46.875 66.6665 L 46.875 83.333 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 53.125 20.83325 A 3.125 4.16675 0 0 1 50 25 A 3.125 4.16675 0 0 0 50 33.3335 L 53.125 33.3335 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
      },
      {
        d: 'M 0 41.6665 L 46.875 0 L 46.875 16.6665 L 50 16.6665 A 3.125 4.16675 0 0 1 50 25 A 3.125 4.16675 0 0 0 50 33.3335 L 53.125 33.3335 L 53.125 16.667 L 100 58.3335 L 53.125 100 L 53.125 83.3335 L 50 83.3335 A 3.125 4.16675 0 0 1 46.875 79.16675000000001 L 46.875 66.6665 L 46.875 66.6665 L 46.875 83.333 Z M 53.125 20.83325 L 53.125 33.3335 M 46.875 29.16675 L 46.875 66.6665',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  leftRightUpArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 75 L 25 50 L 25 62.5 L 37.5 62.5 L 37.5 25 L 25 25 L 50 0 L 75 25 L 62.5 25 L 62.5 62.5 L 75 62.5 L 75 50 L 100 75 L 75 100 L 75 87.5 L 25 87.5 L 25 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  leftUpArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 75 L 25 50 L 25 62.5 L 62.5 62.5 L 62.5 25 L 50 25 L 75 0 L 100 25 L 87.5 25 L 87.5 87.5 L 25 87.5 L 25 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  lightningBolt: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 39.22222222222222 0 L 59.53703703703703 28.148148148148145 L 51.157407407407405 31.46759259259259 L 76.74537037037037 55.58796296296296 L 68.36574074074073 59.61574074074074 L 100 100 L 46.35185185185185 69.05092592592592 L 56.58333333333333 64.75462962962962 L 23.25 44.93055555555555 L 35.19444444444444 38.80555555555555 L 0 18.00925925925926 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  line: { viewBox: '0 0 100 100', paths: [{ d: 'M 0 0 L 100 100', fill: 'none', stroke: '#000000' }] },
  lineInv: { viewBox: '0 0 100 100', paths: [{ d: 'M 0 100 L 100 0', fill: 'none', stroke: '#000000' }] },
  mathDivide: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 50 11.790000000000004 A 11.76 11.76 0 0 1 50.00000000000001 35.31 A 11.76 11.76 0 0 1 49.99999999999999 11.790000000000004 Z M 50 88.21 A 11.76 11.76 0 0 1 50 64.68999999999998 A 11.76 11.76 0 0 1 50.00000000000001 88.21 Z M 13.255000000000003 38.24 L 86.745 38.24 L 86.745 61.76 L 13.255000000000003 61.76 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  mathEqual: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 13.255000000000003 20.599999999999998 L 86.745 20.599999999999998 L 86.745 44.12 L 13.255000000000003 44.12 Z M 13.255000000000003 55.88 L 86.745 55.88 L 86.745 79.4 L 13.255000000000003 79.4 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  mathMinus: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 13.255000000000003 38.24 L 86.745 38.24 L 86.745 61.76 L 13.255000000000003 61.76 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  mathMultiply: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 15.701924253246204 32.3330757467538 L 32.3330757467538 15.7019242532462 L 50 33.3688485064924 L 67.66692425324621 15.7019242532462 L 84.2980757467538 32.3330757467538 L 66.63115149350759 50 L 84.2980757467538 67.66692425324621 L 67.66692425324621 84.2980757467538 L 50 66.6311514935076 L 32.3330757467538 84.2980757467538 L 15.701924253246204 67.66692425324621 L 33.36884850649241 50 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  mathNotEqual: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 13.255000000000003 20.599999999999998 L 48.185994283109636 20.599999999999998 L 55.6837811089934 0 L 77.78535154987797 8.044313771019729 L 73.21545549174309 20.599999999999998 L 86.745 20.599999999999998 L 86.745 44.12 L 64.654875581802 44.12 L 60.37458562683146 55.88 L 86.745 55.88 L 86.745 79.4 L 51.81400571689038 79.4 L 44.3162188910066 100 L 22.214648450122027 91.95568622898027 L 26.78454450825693 79.4 L 13.255000000000003 79.4 L 13.255000000000003 55.88 L 35.34512441819801 55.88 L 39.62541437316855 44.12 L 13.255000000000003 44.12 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  mathPlus: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 13.255000000000003 38.24 L 38.24 38.24 L 38.24 13.255000000000003 L 61.76 13.255000000000003 L 61.76 38.24 L 86.745 38.24 L 86.745 61.76 L 61.76 61.76 L 61.76 86.745 L 38.24 86.745 L 38.24 61.76 L 13.255000000000003 61.76 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  moon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 100 100 A 100 50 0 0 1 99.99999999999999 0 A 125 62.5 0 0 0 100 69.33752296828366 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  nonIsoscelesTrapezoid: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 25 0 L 75 0 L 100 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  noSmoking: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z M 77.5147233635495 64.81561670087828 A 31.25 31.25 0 0 0 35.18438329912174 22.4852766364505 Z M 22.4852766364505 35.18438329912172 A 31.25 31.25 0 0 0 64.81561670087828 77.51472336354949 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  notchedRightArrow: {
    viewBox: '0 0 100 100',
    paths: [
      { d: 'M 0 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 0 75 L 25 50 Z', fill: '#000000', stroke: '#000000' },
    ],
  },
  octagon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 29.289 L 29.289 0 L 70.711 0 L 100 29.289 L 100 70.711 L 70.711 100 L 29.289 100 L 0 70.711 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  parallelogram: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 25 0 L 100 0 L 75 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  pentagon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0.00010576881489043899 38.19650407644447 L 50 0 L 99.99989423118511 38.19650407644447 L 80.90163406877218 99.99974592355554 L 19.09836593122782 99.99974592355554 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  pie: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 100 50 A 50 50 0 0 1 14.64466094067263 85.35533905932738 A 50 50 0 0 1 49.99999999999999 0 L 50 50 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  pieWedge: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 100 A 100 100 0 0 1 99.99999999999999 -1.4210854715202004e-14 L 100 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  plaque: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 16.667 A 16.667 16.667 0 0 0 16.667 0 L 83.333 0 A 16.667 16.667 0 0 0 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 0 83.333 100 L 16.667 100 A 16.667 16.667 0 0 0 1.0205594100694468e-15 83.333 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  plaqueTabs: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 7.0710678118654755 0 A 7.0710678118654755 7.0710678118654755 0 0 1 4.3297802811774667e-16 7.0710678118654755 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 0 92.92893218813452 A 7.0710678118654755 7.0710678118654755 0 0 1 7.071067811865476 100 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 100 0 L 100 7.0710678118654755 A 7.0710678118654755 7.0710678118654755 0 0 1 92.92893218813452 8.659560562354933e-16 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 92.92893218813452 100 A 7.0710678118654755 7.0710678118654755 0 0 1 100 92.92893218813452 L 100 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  plus: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 25 L 25 25 L 25 0 L 75 0 L 75 25 L 100 25 L 100 75 L 75 75 L 75 100 L 25 100 L 25 75 L 0 75 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  quadArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 22.5 27.5 L 22.5 38.75 L 38.75 38.75 L 38.75 22.5 L 27.5 22.5 L 50 0 L 72.5 22.5 L 61.25 22.5 L 61.25 38.75 L 77.5 38.75 L 77.5 27.5 L 100 50 L 77.5 72.5 L 77.5 61.25 L 61.25 61.25 L 61.25 77.5 L 72.5 77.5 L 50 100 L 27.5 77.5 L 38.75 77.5 L 38.75 61.25 L 22.5 61.25 L 22.5 72.5 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  quadArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 18.515 31.485 L 18.515 40.7425 L 25.9385 40.7425 L 25.9385 25.9385 L 40.7425 25.9385 L 40.7425 18.515 L 31.485 18.515 L 50 0 L 68.515 18.515 L 59.2575 18.515 L 59.2575 25.9385 L 74.0615 25.9385 L 74.0615 40.7425 L 81.485 40.7425 L 81.485 31.485 L 100 50 L 81.485 68.515 L 81.485 59.2575 L 74.0615 59.2575 L 74.0615 74.0615 L 59.2575 74.0615 L 59.2575 81.485 L 68.515 81.485 L 50 100 L 31.485 81.485 L 40.7425 81.485 L 40.7425 74.0615 L 25.9385 74.0615 L 25.9385 59.2575 L 18.515 59.2575 L 18.515 68.515 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  rect: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 100 0 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  ribbon: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 34.375 0 A 3.125 4.16675 0 0 1 34.375 8.3335 L 28.125 8.3335 A 3.125 4.16675 0 0 0 28.125 16.667 L 71.875 16.667 A 3.125 4.16675 0 0 0 71.875 8.3335 L 65.625 8.3335 A 3.125 4.16675 0 0 1 65.625 0 L 100 0 L 87.5 41.6665 L 100 83.333 L 75 83.333 L 75 95.83324999999999 A 3.125 4.16675 0 0 1 71.875 100 L 28.125 100 A 3.125 4.16675 0 0 1 25 95.83324999999999 L 25 83.333 L 0 83.333 L 12.5 41.6665 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 37.5 4.16675 A 3.125 4.16675 0 0 1 34.375 8.3335 L 28.125 8.3335 A 3.125 4.16675 0 0 0 28.125 16.667 L 37.5 16.667 Z M 62.5 4.16675 A 3.125 4.16675 0 0 0 65.625 8.3335 L 71.875 8.3335 A 3.125 4.16675 0 0 1 71.875 16.667 L 62.5 16.667 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 0 0 L 34.375 0 A 3.125 4.16675 0 0 1 34.375 8.3335 L 28.125 8.3335 A 3.125 4.16675 0 0 0 28.125 16.667 L 71.875 16.667 A 3.125 4.16675 0 0 0 71.875 8.3335 L 65.625 8.3335 A 3.125 4.16675 0 0 1 65.625 0 L 100 0 L 87.5 41.6665 L 100 83.333 L 75 83.333 L 75 95.83324999999999 A 3.125 4.16675 0 0 1 71.875 100 L 28.125 100 A 3.125 4.16675 0 0 1 25 95.83324999999999 L 25 83.333 L 0 83.333 L 12.5 41.6665 Z M 37.5 4.16675 L 37.5 16.667 M 62.5 16.667 L 62.5 4.16675 M 25 83.333 L 25 12.500250000000001 M 75 12.500250000000001 L 75 83.333',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  ribbon2: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 100 L 34.375 100 A 3.125 4.16675 0 0 0 34.375 91.66649999999998 L 28.125 91.6665 A 3.125 4.16675 0 0 1 28.125 83.333 L 71.875 83.333 A 3.125 4.16675 0 0 1 71.875 91.66650000000001 L 65.625 91.6665 A 3.125 4.16675 0 0 0 65.625 100 L 100 100 L 87.5 58.3335 L 100 16.667 L 75 16.667 L 75 4.16675 A 3.125 4.16675 0 0 0 71.875 0 L 28.125 0 A 3.125 4.16675 0 0 0 25 4.166750000000001 L 25 16.667 L 0 16.667 L 12.5 58.3335 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 37.5 95.83324999999999 A 3.125 4.16675 0 0 0 34.375 91.66649999999998 L 28.125 91.6665 A 3.125 4.16675 0 0 1 28.125 83.333 L 37.5 83.333 Z M 62.5 95.83324999999999 A 3.125 4.16675 0 0 1 65.625 91.66649999999998 L 71.875 91.6665 A 3.125 4.16675 0 0 0 71.875 83.333 L 62.5 83.333 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 0 100 L 12.5 58.3335 L 0 16.667 L 25 16.667 L 25 4.16675 A 3.125 4.16675 0 0 1 28.125 -8.881784197001252e-16 L 71.875 0 A 3.125 4.16675 0 0 1 75 4.1667499999999995 L 75 16.667 L 75 16.667 L 100 16.667 L 87.5 58.3335 L 100 100 L 65.625 100 A 3.125 4.16675 0 0 1 65.625 91.66649999999998 L 71.875 91.6665 A 3.125 4.16675 0 0 0 71.875 83.333 L 28.125 83.333 A 3.125 4.16675 0 0 0 28.125 91.66650000000001 L 34.375 91.6665 A 3.125 4.16675 0 0 1 34.375 100 Z M 37.5 83.333 L 37.5 95.83324999999999 M 62.5 95.83324999999999 L 62.5 83.333 M 25 87.49975 L 25 16.667 M 75 16.667 L 75 87.49975',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  rightArrow: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 0 75 Z', fill: '#000000', stroke: '#000000' }],
  },
  rightArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 64.977 0 L 64.977 37.5 L 75 37.5 L 75 25 L 100 50 L 75 75 L 75 62.5 L 64.977 62.5 L 64.977 100 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  rightBrace: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 A 50 8.333 0 0 1 50.00000000000001 8.332999999999998 L 50 41.667 A 50 8.333 0 0 0 100 50 A 50 8.333 0 0 0 50.000000000000014 58.333 L 50 91.667 A 50 8.333 0 0 1 3.061616997868383e-15 100 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 0 0 A 50 8.333 0 0 1 50.00000000000001 8.332999999999998 L 50 41.667 A 50 8.333 0 0 0 100 50 A 50 8.333 0 0 0 50.000000000000014 58.333 L 50 91.667 A 50 8.333 0 0 1 3.061616997868383e-15 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  rightBracket: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 A 100 8.333 0 0 1 100.00000000000001 8.332999999999998 L 100 91.667 A 100 8.333 0 0 1 6.123233995736766e-15 100 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 0 0 A 100 8.333 0 0 1 100.00000000000001 8.332999999999998 L 100 91.667 A 100 8.333 0 0 1 6.123233995736766e-15 100',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  round1Rect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 100 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  round2DiagRect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.667 0 L 100 0 A 0 0 0 0 1 100 0 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 0 100 A 0 0 0 0 1 0 100 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  round2SameRect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.667 0 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 100 A 0 0 0 0 1 100 100 L 0 100 A 0 0 0 0 1 0 100 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  roundRect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 16.667 100 A 16.667 16.667 0 0 1 0 83.333 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  rtTriangle: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 0 0 L 100 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  smileyFace: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 0 50.000000000000014 Z',
        fill: '#000000',
        stroke: 'none',
      },
      {
        d: 'M 28.77314814814815 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 39.18981481481482 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 28.77314814814815 35.0462962962963 M 60.81018518518518 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 71.22685185185185 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 60.81018518518518 35.0462962962963',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 22.89967279598138 71.80533333333332 Q 50 90.41733333333333 77.03703703703704 71.80533333333332',
        fill: 'none',
        stroke: '#000000',
      },
      {
        d: 'M 0 50 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 0 50.000000000000014 Z',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  snip1Rect: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 0 L 83.333 0 L 100 16.667 L 100 100 L 0 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  snip2DiagRect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 83.333 0 L 100 16.667 L 100 100 L 100 100 L 16.667 100 L 0 83.333 L 0 0 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  snip2SameRect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.667 0 L 83.333 0 L 100 16.667 L 100 100 L 100 100 L 0 100 L 0 100 L 0 16.667 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  snipRoundRect: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 16.667 0 L 83.333 0 L 100 16.667 L 100 100 L 0 100 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  squareTabs: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 7.0710678118654755 0 L 7.0710678118654755 7.0710678118654755 L 0 7.0710678118654755 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 0 92.92893218813452 L 7.0710678118654755 92.92893218813452 L 7.0710678118654755 100 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 92.92893218813452 0 L 100 0 L 100 7.0710678118654755 L 92.92893218813452 7.0710678118654755 Z',
        fill: '#000000',
        stroke: '#000000',
      },
      {
        d: 'M 92.92893218813452 92.92893218813452 L 100 92.92893218813452 L 100 100 L 92.92893218813452 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star10: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M -0.00007738000000045986 34.549 L 13.819211287416401 24.99952793 L 19.09811633 9.549 L 36.180085377416404 9.548565019999998 L 50 0 L 63.819914622583596 9.548565019999998 L 80.90188367 9.549 L 86.18078871258359 24.99952793 L 100.00007738 34.549 L 94.72174817999999 50 L 100.00007738 65.451 L 86.18078871258359 75.00047207 L 80.90188367 90.451 L 63.819914622583596 90.45143498 L 50 100 L 36.180085377416404 90.45143498 L 19.09811633 90.451 L 13.819211287416401 75.00047207 L -0.00007738000000045986 65.451 L 5.278251820000001 50 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star12: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 13.77778151415994 40.294285808655474 L 6.698729810778062 25 L 23.483495705504467 23.48349570550447 L 25 6.698729810778069 L 40.294285808655474 13.77778151415994 L 50 0 L 59.705714191344526 13.77778151415994 L 75 6.698729810778069 L 76.51650429449553 23.48349570550447 L 93.30127018922194 25 L 86.22221848584006 40.294285808655474 L 100 50 L 86.22221848584006 59.705714191344526 L 93.30127018922194 75 L 76.51650429449553 76.51650429449553 L 75 93.30127018922192 L 59.705714191344526 86.22221848584006 L 50 100 L 40.294285808655474 86.22221848584006 L 25 93.30127018922192 L 23.483495705504467 76.51650429449553 L 6.698729810778062 75 L 13.77778151415994 59.705714191344526 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star16: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 13.220374999999997 42.684125 L 3.8059999999999974 30.866 L 18.819875 29.166125 L 14.6445 14.6445 L 29.166125 18.819875 L 30.866 3.8059999999999974 L 42.684125 13.220374999999997 L 50 0 L 57.315875 13.220374999999997 L 69.134 3.8059999999999974 L 70.833875 18.819875 L 85.3555 14.6445 L 81.180125 29.166125 L 96.194 30.866 L 86.77962500000001 42.684125 L 100 50 L 86.77962500000001 57.315875 L 96.194 69.134 L 81.180125 70.833875 L 85.3555 85.3555 L 70.833875 81.180125 L 69.134 96.194 L 57.315875 86.77962500000001 L 50 100 L 42.684125 86.77962500000001 L 30.866 96.194 L 29.166125 81.180125 L 14.6445 85.3555 L 18.819875 70.833875 L 3.8059999999999974 69.134 L 13.220374999999997 57.315875 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star24: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 12.820999999999998 45.105125 L 1.7037086855465873 37.059047744873965 L 15.354500000000002 35.6495 L 6.698729810778062 25 L 20.249375 27.1715 L 14.644660940672622 14.64466094067263 L 27.1715 20.249375 L 25 6.698729810778069 L 35.6495 15.354500000000002 L 37.059047744873965 1.7037086855465873 L 45.105125 12.820999999999998 L 50 0 L 54.894875 12.820999999999998 L 62.940952255126035 1.7037086855465873 L 64.3505 15.354500000000002 L 75 6.698729810778069 L 72.82849999999999 20.249375 L 85.35533905932738 14.64466094067263 L 79.750625 27.1715 L 93.30127018922194 25 L 84.6455 35.6495 L 98.29629131445341 37.059047744873965 L 87.179 45.105125 L 100 50 L 87.179 54.894875 L 98.29629131445341 62.940952255126035 L 84.6455 64.3505 L 93.30127018922194 75 L 79.750625 72.82849999999999 L 85.35533905932738 85.35533905932738 L 72.82849999999999 79.750625 L 75 93.30127018922192 L 64.3505 84.6455 L 62.940952255126035 98.29629131445341 L 54.894875 87.179 L 50 100 L 45.105125 87.179 L 37.059047744873965 98.29629131445341 L 35.6495 84.6455 L 25 93.30127018922192 L 27.1715 79.750625 L 14.644660940672622 85.35533905932738 L 20.249375 72.82849999999999 L 6.698729810778062 75 L 15.354500000000002 64.3505 L 1.7037086855465873 62.940952255126035 L 12.820999999999998 54.894875 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star32: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 12.680750000000003 46.32425 L 0.9605000000000032 40.2455 L 14.11475 39.1145 L 3.8059999999999974 30.866 L 16.927999999999997 32.322500000000005 L 8.426499999999997 22.2215 L 21.012125 26.210375 L 14.644660940672622 14.64466094067263 L 26.210375 21.012125 L 22.2215 8.426499999999997 L 32.322500000000005 16.927999999999997 L 30.866 3.8059999999999974 L 39.1145 14.11475 L 40.2455 0.9605000000000032 L 46.32425 12.680750000000003 L 50 0 L 53.67575 12.680750000000003 L 59.7545 0.9605000000000032 L 60.8855 14.11475 L 69.134 3.8059999999999974 L 67.6775 16.927999999999997 L 77.77850000000001 8.426499999999997 L 73.789625 21.012125 L 85.35533905932738 14.64466094067263 L 78.987875 26.210375 L 91.5735 22.2215 L 83.072 32.322500000000005 L 96.194 30.866 L 85.88525 39.1145 L 99.0395 40.2455 L 87.31925 46.32425 L 100 50 L 87.31925 53.67575 L 99.0395 59.7545 L 85.88525 60.8855 L 96.194 69.134 L 83.072 67.6775 L 91.5735 77.77850000000001 L 78.987875 73.789625 L 85.35533905932738 85.35533905932738 L 73.789625 78.987875 L 77.77850000000001 91.5735 L 67.6775 83.072 L 69.134 96.194 L 60.8855 85.88525 L 59.7545 99.0395 L 53.67575 87.31925 L 50 100 L 46.32425 87.31925 L 40.2455 99.0395 L 39.1145 85.88525 L 30.866 96.194 L 32.322500000000005 83.072 L 22.2215 91.5735 L 26.210375 78.987875 L 14.644660940672622 85.35533905932738 L 21.012125 73.789625 L 8.426499999999997 77.77850000000001 L 16.927999999999997 67.6775 L 3.8059999999999974 69.134 L 14.11475 60.8855 L 0.9605000000000032 59.7545 L 12.680750000000003 53.67575 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star4: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 41.161165235168156 41.161165235168156 L 50 0 L 58.838834764831844 41.161165235168156 L 100 50 L 58.838834764831844 58.838834764831844 L 50 100 L 41.161165235168156 58.838834764831844 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star5: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0.00010576881489043899 38.19650407644447 L 38.19681185109177 38.196772907038735 L 50 0 L 61.80318814890823 38.196772907038735 L 99.99989423118511 38.19650407644447 L 69.09795960054346 61.80313916296127 L 80.90163406877218 99.99974592355554 L 50 76.39267586 L 19.09836593122782 99.99974592355554 L 30.90204039945654 61.80313916296127 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star6: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0.000023312505433636943 25 L 33.3330602 24.999578643550826 L 50 0 L 66.6669398 24.999578643550826 L 99.99997668749457 25 L 83.3338796 50 L 99.99997668749457 75 L 66.6669398 75.00042135644918 L 50 100 L 33.3330602 75.00042135644918 L 0.000023312505433636943 75 L 16.666120399999997 50 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star7: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M -0.0002599799999956076 64.3106646 L 15.398820088640399 44.504445983508 L 9.903066619999997 19.806308549999997 L 34.6011919420464 19.806347509263 L 50 0 L 65.3988080579536 19.806347509263 L 90.09693338 19.806308549999997 L 84.6011799113596 44.504445983508 L 100.00025998 64.3106646 L 77.7478798376276 75.302350457229 L 72.25196968 100.00052685 L 50 89.0087121 L 27.74803032 100.00052685 L 22.252120162372403 75.302350457229 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  star8: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 15.354500000000002 35.6495 L 14.644660940672622 14.64466094067263 L 35.6495 15.354500000000002 L 50 0 L 64.3505 15.354500000000002 L 85.35533905932738 14.64466094067263 L 84.6455 35.6495 L 100 50 L 84.6455 64.3505 L 85.35533905932738 85.35533905932738 L 64.3505 84.6455 L 50 100 L 35.6495 84.6455 L 14.644660940672622 85.35533905932738 L 15.354500000000002 64.3505 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  straightConnector1: { viewBox: '0 0 100 100', paths: [{ d: 'M 0 0 L 100 100', fill: 'none', stroke: '#000000' }] },
  stripedRightArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 25 L 0 25 L 0 75 L 0 75 Z M 0 25 L 0 25 L 0 75 L 0 75 Z M 15.625 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 15.625 75 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  sun: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 100 50 L 79.82292175292969 57.175445556640625 L 79.82292175292969 42.824554443359375 Z M 85.35185185185185 14.643518518518519 L 76.16092175292968 33.986554443359374 L 66.01344555664062 23.83907824707031 Z M 50 0 L 57.175445556640625 20.177078247070312 L 42.824554443359375 20.177078247070312 Z M 14.643518518518519 14.643518518518519 L 33.986554443359374 23.83907824707031 L 23.83907824707031 33.986554443359374 Z M 0 50 L 20.177078247070312 42.824554443359375 L 20.177078247070312 57.175445556640625 Z M 14.643518518518519 85.35185185185185 L 23.83907824707031 66.01344555664062 L 33.986554443359374 76.16092175292968 Z M 50 100 L 42.824554443359375 79.82292175292969 L 57.175445556640625 79.82292175292969 Z M 85.35185185185185 85.35185185185185 L 66.01344555664062 76.16092175292968 L 76.16092175292968 66.01344555664062 Z M 25 50 A 25 25 0 0 1 75 49.99999999999999 A 25 25 0 0 1 25 50.00000000000001 Z',
        fill: '#000000',
        stroke: '#000000',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
    ],
  },
  swooshArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 100 Q 16.666666666666668 33.333333333333336 83.333 0 L 83.333 0 L 100 7.5 L 86.14982349750278 25 L 86.14982349750278 25 Q 25 33.333333333333336 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  teardrop: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 Q 75 0 100 0 Q 100 25 100 50 A 50 50 0 0 1 50 100 A 50 50 0 0 1 0 50.00000000000001 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  trapezoid: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 25 0 L 75 0 L 100 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  triangle: {
    viewBox: '0 0 100 100',
    paths: [{ d: 'M 0 100 L 50 0 L 100 100 Z', fill: '#000000', stroke: '#000000' }],
  },
  upArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 35.022999999999996 L 37.5 35.022999999999996 L 37.5 25 L 25 25 L 50 0 L 75 25 L 62.5 25 L 62.5 35.022999999999996 L 100 35.022999999999996 L 100 100 L 0 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  upDownArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 50 L 50 0 L 100 50 L 75 50 L 75 50 L 100 50 L 50 100 L 0 50 L 25 50 L 25 50 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  upDownArrowCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 25.9385 L 37.5 25.9385 L 37.5 25 L 25 25 L 50 0 L 75 25 L 62.5 25 L 62.5 25.9385 L 100 25.9385 L 100 74.0615 L 62.5 74.0615 L 62.5 75 L 75 75 L 50 100 L 25 75 L 37.5 75 L 37.5 74.0615 L 0 74.0615 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  uturnArrow: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 100 L 0 43.75 A 43.75 43.75 0 0 1 43.74999999999999 -7.105427357601002e-15 L 43.75 0 A 43.75 43.75 0 0 1 87.5 43.749999999999986 L 87.5 50 L 100 50 L 75 75 L 50 50 L 62.5 50 L 62.5 43.75 A 18.75 18.75 0 0 0 43.75 25 L 43.75 25 A 18.75 18.75 0 0 0 25 43.75 L 25 100 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  verticalScroll: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 6.25 100 A 6.25 6.25 0 0 0 12.5 93.75 L 6.25 93.75 A 3.125 3.125 0 0 0 6.25 87.5 L 12.5 87.5 L 12.5 6.25 A 6.25 6.25 0 0 1 18.75 -8.881784197001252e-16 L 93.75 0 A 6.25 6.25 0 0 1 93.75 12.5 L 87.5 12.5 L 87.5 93.75 A 6.25 6.25 0 0 1 81.25 100 Z M 25 6.25 A 6.25 6.25 0 0 1 18.75 12.5 A 3.125 3.125 0 0 1 18.75 6.25 Z',
        fill: '#000000',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 25 6.25 A 6.25 6.25 0 0 1 18.75 12.5 A 3.125 3.125 0 0 1 18.75 6.25 Z M 12.5 93.75 A 6.25 6.25 0 0 1 1.8305826175840787 98.16941738241593 A 6.25 6.25 0 0 1 6.249999999999999 87.5 A 3.125 3.125 0 0 1 6.250000000000001 93.75 Z',
        fill: 'color-mix(in srgb, currentColor 80%, black)',
        stroke: 'none',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      },
      {
        d: 'M 12.5 87.5 L 12.5 6.25 A 6.25 6.25 0 0 1 18.75 -8.881784197001252e-16 L 93.75 0 A 6.25 6.25 0 0 1 93.75 12.5 L 87.5 12.5 L 87.5 93.75 A 6.25 6.25 0 0 1 81.25 100 L 6.25 100 A 6.25 6.25 0 0 1 6.249999999999999 87.5 Z M 18.75 0 A 6.25 6.25 0 0 1 18.750000000000004 12.5 A 3.125 3.125 0 0 1 18.750000000000004 6.25 L 25 6.25 M 87.5 12.5 L 18.75 12.5 M 6.25 87.5 A 3.125 3.125 0 0 1 6.250000000000002 93.75 L 12.5 93.75 M 6.25 100 A 6.25 6.25 0 0 0 12.5 93.75 L 12.5 87.5',
        fill: 'none',
        stroke: '#000000',
      },
    ],
  },
  wave: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 12.5 C 33.333333333333336 -29.166666666666664 66.66666666666667 54.166666666666664 100 12.5 L 100 87.5 C 66.66666666666667 129.16666666666666 33.333333333333336 45.833333333333336 0 87.5 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  wedgeEllipseCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 29.167 112.5 L 25.428460527844393 93.54583157970805 A 50 50 0 0 1 65.81115470846487 2.5657572339877106 A 50 50 0 0 1 43.53022094510429 99.57965267103867 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  wedgeRectCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 0 L 16.666666666666668 0 L 16.666666666666668 0 L 41.666666666666664 0 L 100 0 L 100 58.333333333333336 L 100 58.333333333333336 L 100 83.33333333333333 L 100 100 L 41.666666666666664 100 L 29.167 112.5 L 16.666666666666668 100 L 0 100 L 0 83.33333333333333 L 0 58.333333333333336 L 0 58.333333333333336 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
  wedgeRoundRectCallout: {
    viewBox: '0 0 100 100',
    paths: [
      {
        d: 'M 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 L 16.666666666666668 0 L 16.666666666666668 0 L 41.666666666666664 0 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 58.333333333333336 L 100 58.333333333333336 L 100 83.33333333333333 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 41.666666666666664 100 L 29.167 112.5 L 16.666666666666668 100 L 16.667 100 A 16.667 16.667 0 0 1 0 83.333 L 0 83.33333333333333 L 0 58.333333333333336 L 0 58.333333333333336 Z',
        fill: '#000000',
        stroke: '#000000',
      },
    ],
  },
};
var M = ['fill', 'stroke', 'strokeWidth', 'fillRule', 'clipRule'],
  d = s;
function r(t) {
  if (!t) return null;
  let e = {};
  return (
    M.forEach((l) => {
      let L = t[l];
      if (L !== void 0)
        if (l === 'strokeWidth') {
          if (typeof L == 'number') e.strokeWidth = L;
          else if (typeof L == 'string') {
            let o = Number(L);
            Number.isFinite(o) && (e.strokeWidth = o);
          }
        } else typeof L == 'string' && (e[l] = L);
    }),
    Object.keys(e).length ? e : null
  );
}
function A(t, e) {
  let l = t.map((o) => ({ ...o }));
  if (!e) return l;
  let L = (o, i) => (typeof e == 'function' ? r(e(o, i)) : Array.isArray(e) ? r(e[i]) : r(e));
  return l.map((o, i) => {
    let n = L(o, i);
    return n ? { ...o, ...n } : o;
  });
}
function f(t) {
  let { preset: e, styleOverrides: l } = t;
  if (!e) throw new Error('createPresetShape requires a preset name.');
  let L = d[e];
  if (!L) throw new Error(`Unknown preset shape: ${e}`);
  return { preset: e, viewBox: L.viewBox, paths: A(L.paths, l) };
}
function k(t) {
  let e = f(t),
    l = e.paths.map((L) => {
      let o = [`d="${L.d}"`];
      return (
        L.fill !== void 0 && o.push(`fill="${L.fill}"`),
        L.stroke !== void 0 && o.push(`stroke="${L.stroke}"`),
        L.strokeWidth !== void 0 && o.push(`stroke-width="${L.strokeWidth}"`),
        L.fillRule !== void 0 && o.push(`fill-rule="${L.fillRule}"`),
        L.clipRule !== void 0 && o.push(`clip-rule="${L.clipRule}"`),
        `  <path ${o.join(' ')} />`
      );
    }).join(`
`);
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${e.viewBox}" preserveAspectRatio="none">
${l}
</svg>`;
}
class VectorShapeView {
  constructor(props) {
    __publicField(this, 'node');
    __publicField(this, 'view');
    __publicField(this, 'getPos');
    __publicField(this, 'decorations');
    __publicField(this, 'innerDecorations');
    __publicField(this, 'editor');
    __publicField(this, 'extension');
    __publicField(this, 'htmlAttributes');
    __publicField(this, 'root');
    this.node = props.node;
    this.view = props.editor.view;
    this.getPos = props.getPos;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.editor = props.editor;
    this.extension = props.extension;
    this.htmlAttributes = props.htmlAttributes;
    this.mount();
  }
  mount() {
    this.buildView();
  }
  get dom() {
    return this.root;
  }
  get contentDOM() {
    return null;
  }
  createElement() {
    const attrs = this.node.attrs;
    const element = document.createElement('span');
    element.classList.add('sd-vector-shape');
    element.setAttribute('data-vector-shape', '');
    element.style.width = `${attrs.width}px`;
    element.style.height = `${attrs.height}px`;
    const transforms = this.generateTransform();
    if (transforms.length > 0) {
      element.style.transform = transforms.join(' ');
    }
    const svgTemplate = this.generateSVG({
      kind: attrs.kind,
      fillColor: attrs.fillColor,
      strokeColor: attrs.strokeColor,
      strokeWidth: attrs.strokeWidth,
    });
    if (svgTemplate) {
      element.innerHTML = svgTemplate;
    }
    return { element };
  }
  generateTransform() {
    const attrs = this.node.attrs;
    const transforms = [];
    if (attrs.rotation != null) {
      transforms.push(`rotate(${attrs.rotation}deg)`);
    }
    if (attrs.flipH) {
      transforms.push(`scaleX(-1)`);
    }
    if (attrs.flipV) {
      transforms.push(`scaleY(-1)`);
    }
    return transforms;
  }
  generateSVG({ kind, fillColor, strokeColor, strokeWidth }) {
    try {
      return k({
        preset: kind,
        styleOverrides: {
          fill: fillColor || 'none',
          stroke: strokeColor || 'none',
          strokeWidth: strokeWidth || 0,
        },
      });
    } catch {
      return null;
    }
  }
  buildView() {
    const { element } = this.createElement();
    this.root = element;
  }
  update() {
    return false;
  }
}
const VectorShape = Node$1.create({
  name: 'vectorShape',
  group: 'inline',
  inline: true,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  addAttributes() {
    return {
      kind: {
        default: 'rect',
        renderDOM: (attrs) => {
          if (!attrs.kind) return {};
          return { 'data-kind': attrs.kind };
        },
      },
      width: {
        default: 100,
        renderDOM: (attrs) => {
          if (attrs.width == null) return {};
          return { 'data-width': attrs.width };
        },
      },
      height: {
        default: 100,
        renderDOM: (attrs) => {
          if (attrs.height == null) return {};
          return { 'data-height': attrs.height };
        },
      },
      fillColor: {
        default: '#5b9bd5',
        renderDOM: (attrs) => {
          if (!attrs.fillColor) return {};
          return { 'data-fill-color': attrs.fillColor };
        },
      },
      strokeColor: {
        default: '#000000',
        renderDOM: (attrs) => {
          if (!attrs.strokeColor) return {};
          return { 'data-stroke-color': attrs.strokeColor };
        },
      },
      strokeWidth: {
        default: 1,
        renderDOM: (attrs) => {
          if (attrs.strokeWidth == null) return {};
          return { 'data-stroke-width': attrs.strokeWidth };
        },
      },
      rotation: {
        default: 0,
        renderDOM: (attrs) => {
          if (attrs.rotation == null) return {};
          return { 'data-rotation': attrs.rotation };
        },
      },
      flipH: {
        default: false,
        renderDOM: (attrs) => {
          if (!attrs.flipH) return {};
          return { 'data-flip-h': attrs.flipH };
        },
      },
      flipV: {
        default: false,
        renderDOM: (attrs) => {
          if (!attrs.flipV) return {};
          return { 'data-flip-v': attrs.flipV };
        },
      },
      drawingContent: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return [
      'span',
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { 'data-vector-shape': '' }),
    ];
  },
  addNodeView() {
    return (props) => {
      return new VectorShapeView({ ...props });
    };
  },
});
class ShapeGroupView {
  constructor(props) {
    __publicField(this, 'node');
    __publicField(this, 'view');
    __publicField(this, 'getPos');
    __publicField(this, 'decorations');
    __publicField(this, 'innerDecorations');
    __publicField(this, 'editor');
    __publicField(this, 'extension');
    __publicField(this, 'htmlAttributes');
    __publicField(this, 'root');
    this.node = props.node;
    this.view = props.editor.view;
    this.getPos = props.getPos;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.editor = props.editor;
    this.extension = props.extension;
    this.htmlAttributes = props.htmlAttributes;
    this.mount();
  }
  mount() {
    this.buildView();
  }
  get dom() {
    return this.root;
  }
  get contentDOM() {
    return null;
  }
  createElement() {
    const attrs = this.node.attrs;
    const { groupTransform, shapes, size } = attrs;
    const container = document.createElement('div');
    container.classList.add('sd-shape-group');
    container.setAttribute('data-shape-group', '');
    const width = size?.width || groupTransform?.width || 300;
    const height = size?.height || groupTransform?.height || 200;
    container.style.width = `${width}px`;
    container.style.height = `${height}px`;
    container.style.position = 'relative';
    container.style.display = 'inline-block';
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('version', '1.1');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('width', width.toString());
    svg.setAttribute('height', height.toString());
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.style.display = 'block';
    if (shapes && Array.isArray(shapes)) {
      shapes.forEach((shape) => {
        if (shape.shapeType === 'vectorShape') {
          const shapeElement = this.createShapeElement(shape, groupTransform);
          if (shapeElement) {
            svg.appendChild(shapeElement);
          }
        }
      });
    }
    container.appendChild(svg);
    return { element: container };
  }
  createShapeElement(shape) {
    const attrs = shape.attrs;
    if (!attrs) return null;
    const x = attrs.x || 0;
    const y = attrs.y || 0;
    const width = attrs.width || 100;
    const height = attrs.height || 100;
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const transforms = [];
    transforms.push(`translate(${x}, ${y})`);
    if (attrs.rotation !== 0) {
      transforms.push(`rotate(${attrs.rotation} ${width / 2} ${height / 2})`);
    }
    if (attrs.flipH) {
      transforms.push(`scale(-1, 1) translate(${-width}, 0)`);
    }
    if (attrs.flipV) {
      transforms.push(`scale(1, -1) translate(0, ${-height})`);
    }
    if (transforms.length > 0) {
      g.setAttribute('transform', transforms.join(' '));
    }
    const shapeKind = attrs.kind || 'rect';
    const fillColor = attrs.fillColor || '#5b9bd5';
    const strokeColor = attrs.strokeColor || '#000000';
    const strokeWidth = attrs.strokeWidth || 1;
    try {
      const svgContent = k({
        preset: shapeKind,
        styleOverrides: {
          fill: fillColor || 'none',
          stroke: strokeColor || 'none',
          strokeWidth: strokeWidth || 0,
        },
        width,
        height,
      });
      if (svgContent) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = svgContent;
        const svgElement = tempDiv.querySelector('svg');
        if (svgElement) {
          Array.from(svgElement.children).forEach((child) => {
            const clonedChild = child.cloneNode(true);
            if (clonedChild.tagName === 'ellipse') {
              clonedChild.setAttribute('cx', (width / 2).toString());
              clonedChild.setAttribute('cy', (height / 2).toString());
              clonedChild.setAttribute('rx', (width / 2).toString());
              clonedChild.setAttribute('ry', (height / 2).toString());
            } else if (clonedChild.tagName === 'circle') {
              if (width !== height) {
                const ellipse = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                ellipse.setAttribute('cx', (width / 2).toString());
                ellipse.setAttribute('cy', (height / 2).toString());
                ellipse.setAttribute('rx', (width / 2).toString());
                ellipse.setAttribute('ry', (height / 2).toString());
                Array.from(clonedChild.attributes).forEach((attr) => {
                  if (!['cx', 'cy', 'r'].includes(attr.name)) {
                    ellipse.setAttribute(attr.name, attr.value);
                  }
                });
                g.appendChild(ellipse);
                return;
              } else {
                clonedChild.setAttribute('cx', (width / 2).toString());
                clonedChild.setAttribute('cy', (height / 2).toString());
                clonedChild.setAttribute('r', (width / 2).toString());
              }
            } else if (clonedChild.tagName === 'rect') {
              clonedChild.setAttribute('width', width.toString());
              clonedChild.setAttribute('height', height.toString());
            } else if (clonedChild.tagName === 'path' && svgElement.hasAttribute('viewBox')) {
              const viewBox = svgElement.getAttribute('viewBox').split(' ').map(Number);
              if (viewBox.length === 4) {
                const [, , vbWidth, vbHeight] = viewBox;
                const scaleX = width / vbWidth;
                const scaleY = height / vbHeight;
                if (scaleX !== 1 || scaleY !== 1) {
                  const pathTransform = `scale(${scaleX}, ${scaleY})`;
                  const existingTransform = clonedChild.getAttribute('transform');
                  clonedChild.setAttribute(
                    'transform',
                    existingTransform ? `${existingTransform} ${pathTransform}` : pathTransform,
                  );
                }
              }
            } else if (clonedChild.hasAttribute('width')) {
              clonedChild.setAttribute('width', width.toString());
            }
            if (clonedChild.hasAttribute('height') && clonedChild.tagName !== 'ellipse') {
              clonedChild.setAttribute('height', height.toString());
            }
            g.appendChild(clonedChild);
          });
        }
      }
    } catch (error) {
      console.warn('Failed to generate shape SVG:', error);
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('width', width.toString());
      rect.setAttribute('height', height.toString());
      rect.setAttribute('fill', fillColor);
      rect.setAttribute('stroke', strokeColor);
      rect.setAttribute('stroke-width', strokeWidth.toString());
      g.appendChild(rect);
    }
    return g;
  }
  buildView() {
    const { element } = this.createElement();
    this.root = element;
  }
  update() {
    return false;
  }
}
const ShapeGroup = Node$1.create({
  name: 'shapeGroup',
  group: 'inline',
  inline: true,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
      },
    };
  },
  addAttributes() {
    return {
      groupTransform: {
        default: {},
        renderDOM: () => ({}),
      },
      shapes: {
        default: [],
        renderDOM: () => ({}),
      },
      size: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.size) return {};
          const sizeData = {};
          if (attrs.size.width) sizeData['data-width'] = attrs.size.width;
          if (attrs.size.height) sizeData['data-height'] = attrs.size.height;
          return sizeData;
        },
      },
      padding: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.padding) return {};
          const paddingData = {};
          if (attrs.padding.top != null) paddingData['data-padding-top'] = attrs.padding.top;
          if (attrs.padding.right != null) paddingData['data-padding-right'] = attrs.padding.right;
          if (attrs.padding.bottom != null) paddingData['data-padding-bottom'] = attrs.padding.bottom;
          if (attrs.padding.left != null) paddingData['data-padding-left'] = attrs.padding.left;
          return paddingData;
        },
      },
      marginOffset: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.marginOffset) return {};
          const offsetData = {};
          if (attrs.marginOffset.horizontal != null) offsetData['data-offset-x'] = attrs.marginOffset.horizontal;
          if (attrs.marginOffset.top != null) offsetData['data-offset-y'] = attrs.marginOffset.top;
          return offsetData;
        },
      },
      drawingContent: {
        rendered: false,
      },
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ['div', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { 'data-shape-group': '' })];
  },
  addNodeView() {
    return (props) => {
      return new ShapeGroupView({ ...props });
    };
  },
});
const TextStyle = Mark.create({
  name: 'textStyle',
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  parseDOM() {
    return [
      {
        tag: 'span',
        getAttrs: (el) => {
          const hasStyles = el.hasAttribute('style');
          const isAnnotation = el.classList.contains(annotationClass) || el.classList.contains(annotationContentClass);
          if (!hasStyles || isAnnotation) return false;
          return {};
        },
      },
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [styleId] - Style identifier for referencing predefined styles
       */
      styleId: {},
    };
  },
  addCommands() {
    return {
      /**
       * Remove empty text style marks
       * @category Command
       * @example
       * editor.commands.removeEmptyTextStyle()
       * @note Cleanup utility to prevent empty span elements
       * @note Automatically checks if any style attributes exist before removal
       */
      removeEmptyTextStyle:
        () =>
        ({ state, commands: commands2 }) => {
          const attributes = Attribute.getMarkAttributes(state, this.type);
          const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
          if (hasStyles) return true;
          return commands2.unsetMark(this.name);
        },
    };
  },
});
function createCascadeToggleCommands({
  markName,
  setCommand,
  unsetCommand,
  toggleCommand,
  negationAttrs,
  isNegation,
  extendEmptyMarkRange,
} = {}) {
  if (!markName) throw new Error('createCascadeToggleCommands requires a markName');
  const capitalized = markName.charAt(0).toUpperCase() + markName.slice(1);
  const setName = setCommand ?? `set${capitalized}`;
  const unsetName = unsetCommand ?? `unset${capitalized}`;
  const toggleName = toggleCommand ?? `toggle${capitalized}`;
  const cascadeOptions = {};
  if (negationAttrs) cascadeOptions.negationAttrs = negationAttrs;
  if (typeof isNegation === 'function') cascadeOptions.isNegation = isNegation;
  if (extendEmptyMarkRange !== void 0) cascadeOptions.extendEmptyMarkRange = extendEmptyMarkRange;
  return {
    [setName]:
      () =>
      ({ commands: commands2 }) =>
        commands2.setMark(markName),
    [unsetName]:
      () =>
      ({ commands: commands2 }) =>
        commands2.unsetMark(markName),
    [toggleName]:
      () =>
      ({ commands: commands2 }) =>
        commands2.toggleMarkCascade(markName, cascadeOptions),
  };
}
const Bold = Mark.create({
  name: 'bold',
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  addAttributes() {
    return {
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.value) return {};
          if (attrs.value === '0') {
            return { style: 'font-weight: normal' };
          }
          return {};
        },
      },
    };
  },
  parseDOM() {
    return [
      { tag: 'strong' },
      { tag: 'b', getAttrs: (node) => node.style.fontWeight != 'normal' && null },
      { style: 'font-weight=400', clearMark: (m) => m.type.name == 'strong' },
      { style: 'font-weight', getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null },
    ];
  },
  renderDOM({ htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const { value, ...rest } = merged || {};
    if (value === '0') {
      return ['span', rest, 0];
    }
    return ['strong', rest, 0];
  },
  addCommands() {
    const { setBold, unsetBold, toggleBold } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { value: '0' },
    });
    return {
      /**
       * Apply bold formatting
       * @category Command
       * @example
       * editor.commands.setBold()
       * @note '0' renders as normal weight
       */
      setBold,
      /**
       * Remove bold formatting
       * @category Command
       * @example
       * editor.commands.unsetBold()
       */
      unsetBold,
      /**
       * Toggle bold formatting
       * @category Command
       * @example
       * editor.commands.toggleBold()
       */
      toggleBold,
    };
  },
  addShortcuts() {
    return {
      'Mod-b': () => this.editor.commands.toggleBold(),
      'Mod-B': () => this.editor.commands.toggleBold(),
    };
  },
});
const Italic = Mark.create({
  name: 'italic',
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [value] - Italic toggle value ('0' renders as normal)
       */
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.value) return {};
          if (attrs.value === '0') return { style: 'font-style: normal' };
          return {};
        },
      },
    };
  },
  parseDOM() {
    return [
      { tag: 'i' },
      { tag: 'em' },
      { style: 'font-style=italic' },
      { style: 'font-style=normal', clearMark: (m) => m.type.name == 'em' },
    ];
  },
  renderDOM({ htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const { value, ...rest } = merged || {};
    if (value === '0') {
      return ['span', rest, 0];
    }
    return ['em', rest, 0];
  },
  addCommands() {
    const { setItalic, unsetItalic, toggleItalic } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { value: '0' },
    });
    return {
      /**
       * Apply italic formatting
       * @category Command
       * @example
       * editor.commands.setItalic()
       */
      setItalic,
      /**
       * Remove italic formatting
       * @category Command
       * @example
       * editor.commands.unsetItalic()
       */
      unsetItalic,
      /**
       * Toggle italic formatting
       * @category Command
       * @example
       * editor.commands.toggleItalic()
       */
      toggleItalic,
    };
  },
  addShortcuts() {
    return {
      'Mod-i': () => this.editor.commands.toggleItalic(),
      'Mod-I': () => this.editor.commands.toggleItalic(),
    };
  },
});
const Underline = Mark.create({
  name: 'underline',
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  parseDOM() {
    return [
      { tag: 'u' },
      { style: 'text-decoration=underline' },
      { style: 'text-decoration=auto', clearMark: (m) => m.type.name == 'u' },
    ];
  },
  renderDOM({ htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const type = merged?.underlineType;
    const color = merged?.underlineColor;
    const css = getUnderlineCssString({ type, color });
    const { style, ...rest } = merged || {};
    const styleString = [style, css].filter(Boolean).join('; ');
    if (type === 'none') {
      return ['span', { ...rest, ...(styleString ? { style: styleString } : {}) }, 0];
    }
    return ['u', { ...rest, ...(styleString ? { style: styleString } : {}) }, 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {UnderlineConfig} [underlineType='single'] - Style of underline
       */
      underlineType: {
        default: 'single',
      },
      underlineColor: {
        default: null,
      },
    };
  },
  addCommands() {
    const { setUnderline, unsetUnderline, toggleUnderline } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { underlineType: 'none' },
      isNegation: (attrs) => attrs?.underlineType === 'none',
    });
    return {
      /**
       * Apply underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setUnderline()
       */
      setUnderline,
      /**
       * Remove underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetUnderline()
       */
      unsetUnderline,
      /**
       * Toggle underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleUnderline()
       */
      toggleUnderline,
    };
  },
  addShortcuts() {
    return {
      'Mod-u': () => this.editor.commands.toggleUnderline(),
      'Mod-U': () => this.editor.commands.toggleUnderline(),
    };
  },
});
const Highlight = Mark.create({
  name: 'highlight',
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  addAttributes() {
    return {
      color: {
        default: null,
        parseDOM: (element) => element.getAttribute('data-color') || element.style.backgroundColor,
        renderDOM: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            'data-color': attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`,
          };
        },
      },
    };
  },
  parseDOM() {
    return [{ tag: 'mark' }];
  },
  renderDOM({ htmlAttributes }) {
    return ['mark', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply highlight with specified color
       * @category Command
       * @param {string} color - CSS color value
       * @example
       * editor.commands.setHighlight('#FFEB3B')
       * editor.commands.setHighlight('rgba(255, 235, 59, 0.5)')
       */
      setHighlight:
        (color) =>
        ({ commands: commands2 }) =>
          commands2.setMark(this.name, { color }),
      /**
       * Remove highlight formatting
       * @category Command
       * @example
       * editor.commands.unsetHighlight()
       */
      unsetHighlight:
        () =>
        ({ commands: commands2 }) =>
          commands2.unsetMark(this.name),
      /**
       * Toggle highlight formatting
       * @category Command
       * @example
       * editor.commands.toggleHighlight()
       */
      toggleHighlight:
        () =>
        ({ commands: commands2 }) =>
          commands2.toggleMark(this.name),
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-h': () => this.editor.commands.toggleHighlight(),
    };
  },
});
const Strike = Mark.create({
  name: 'strike',
  addOptions() {
    return {
      htmlAttributes: {},
    };
  },
  parseDOM() {
    return [
      { tag: 's' },
      { style: 'text-decoration=line-through' },
      { style: 'text-decoration=auto', clearMark: (m) => m.type.name == 's' },
    ];
  },
  renderDOM({ mark, htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const { value } = mark.attrs;
    const { ...rest } = merged || {};
    if (value === '0') {
      return ['span', rest, 0];
    }
    return ['s', rest, 0];
  },
  addCommands() {
    const { setStrike, unsetStrike, toggleStrike } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { value: '0' },
    });
    return {
      /**
       * Apply strikethrough formatting
       * @category Command
       * @example
       * editor.commands.setStrike()
       */
      setStrike,
      /**
       * Remove strikethrough formatting
       * @category Command
       * @example
       * editor.commands.unsetStrike()
       */
      unsetStrike,
      /**
       * Toggle strikethrough formatting
       * @category Command
       * @example
       * editor.commands.toggleStrike()
       */
      toggleStrike,
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [value] - Strike toggle value ('0' renders as normal)
       */
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.value) return {};
          if (attrs.value === '0') {
            return { style: 'text-decoration: none' };
          }
          return {};
        },
      },
    };
  },
  addShortcuts() {
    return {
      'Mod-Shift-s': () => this.editor.commands.toggleStrike(),
    };
  },
});
const Link = Mark.create({
  name: 'link',
  priority: 1e3,
  keepOnSplit: false,
  inclusive: false,
  addOptions() {
    return {
      protocols: ['http', 'https'],
      htmlAttributes: {
        target: null,
        rel: 'noopener noreferrer nofollow',
        class: null,
        title: null,
      },
    };
  },
  parseDOM() {
    return [{ tag: 'a' }];
  },
  renderDOM({ htmlAttributes }) {
    if (!isAllowedUri(htmlAttributes.href, this.options.protocols)) {
      return ['a', Attribute.mergeAttributes(this.options.htmlAttributes, { ...htmlAttributes, href: '' }), 0];
    }
    return ['a', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [href] - URL or anchor reference
       */
      href: {
        default: null,
        renderDOM: ({ href, name }) => {
          if (href && isAllowedUri(href, this.options.protocols)) return { href };
          else if (name) return { href: `#${name}` };
          return {};
        },
      },
      /**
       * @category Attribute
       * @param {TargetFrameOptions} [target='_blank'] - Link target window
       */
      target: {
        default: this.options.htmlAttributes.target,
        renderDOM: ({ target, href }) => {
          if (target) return { target };
          else if (href && !href.startsWith('#')) return { target: '_blank' };
          return {};
        },
      },
      /**
       * @category Attribute
       * @param {string} [rel='noopener noreferrer nofollow'] - Relationship attributes
       */
      rel: { default: this.options.htmlAttributes.rel },
      /**
       * @private
       * @category Attribute
       * @param {string} [rId] - Word relationship ID for internal links
       */
      rId: { default: this.options.htmlAttributes.rId || null },
      /**
       * @category Attribute
       * @param {string} [text] - Display text for the link
       */
      text: { default: null },
      /**
       * @category Attribute
       * @param {string} [name] - Anchor name for internal references
       */
      name: { default: null },
      /**
       * @category Attribute
       * @param {boolean} [history] - Specifies whether the target of the hyperlink  shall be added to a list of viewed hyperlinks when it is invoked.
       */
      history: { default: true, rendered: false },
      /**
       * @category Attribute
       * @param {string|null} [anchor] - Specifies the name of a bookmark that is the target of this link. If the rId and href attributes are specified, then this attribute is ignored.
       */
      anchor: { rendered: false },
      /**
       * @category Attribute
       * @param {string|null} [docLocation] - Specifies a location in the target of the hyperlink.
       */
      docLocation: { rendered: false },
      /**
       * @category Attribute
       * @param {string|null} [tooltip] - A tooltip for the link
       */
      tooltip: {
        default: null,
        renderDOM: ({ tooltip }) => {
          if (tooltip) return { title: tooltip };
          return {};
        },
      },
    };
  },
  addCommands() {
    return {
      /**
       * Create or update a link
       * @category Command
       * @param {SetLinkOptions} [options] - Link configuration
       * @example
       * editor.commands.setLink({ href: 'https://example.com' })
       * editor.commands.setLink({
       *   href: 'https://example.com',
       *   text: 'Visit Example'
       * })
       * @note Automatically adds underline formatting and trims whitespace from link boundaries
       */
      setLink:
        ({ href, text } = {}) =>
        ({ state, dispatch, editor }) => {
          const { selection } = state;
          const linkMarkType = editor.schema.marks.link;
          const underlineMarkType = editor.schema.marks.underline;
          let from = selection.from;
          let to = selection.to;
          if (selection.empty) {
            const range = getMarkRange(selection.$from, linkMarkType);
            if (range) {
              from = range.from;
              to = range.to;
            }
          } else {
            const fromLinkRange = getMarkRange(selection.$from, linkMarkType);
            const toLinkRange = getMarkRange(selection.$to, linkMarkType);
            if (fromLinkRange || toLinkRange) {
              const linkRange = fromLinkRange || toLinkRange;
              from = linkRange.from;
              to = linkRange.to;
            }
          }
          ({ from, to } = trimRange(state.doc, from, to));
          const currentText = state.doc.textBetween(from, to);
          const computedText = text ?? currentText;
          const finalText = computedText && computedText.length > 0 ? computedText : href || '';
          let tr = state.tr;
          if (finalText && currentText !== finalText) {
            tr = tr.insertText(finalText, from, to);
            to = from + finalText.length;
          }
          if (linkMarkType) tr = tr.removeMark(from, to, linkMarkType);
          if (underlineMarkType) tr = tr.removeMark(from, to, underlineMarkType);
          if (underlineMarkType) tr = tr.addMark(from, to, underlineMarkType.create());
          let rId = null;
          if (editor.options.mode === 'docx') {
            const id = addLinkRelationship({ editor, href });
            if (id) rId = id;
          }
          const newLinkMarkType = linkMarkType.create({ href, text: finalText, rId });
          tr = tr.addMark(from, to, newLinkMarkType);
          dispatch(tr.scrollIntoView());
          return true;
        },
      /**
       * Remove link and associated formatting
       * @category Command
       * @example
       * editor.commands.unsetLink()
       * @note Also removes underline and text color
       */
      unsetLink:
        () =>
        ({ chain }) => {
          return chain()
            .unsetMark('underline', { extendEmptyMarkRange: true })
            .unsetColor()
            .unsetMark('link', { extendEmptyMarkRange: true })
            .run();
        },
      /**
       * Toggle link on selection
       * @category Command
       * @param {SetLinkOptions} [options] - Link configuration
       * @example
       * editor.commands.toggleLink({ href: 'https://example.com' })
       * editor.commands.toggleLink()
       */
      toggleLink:
        ({ href, text } = {}) =>
        ({ commands: commands2 }) => {
          if (!href) return commands2.unsetLink();
          return commands2.setLink({ href, text });
        },
    };
  },
});
const ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ['http', 'https', 'mailto'];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return (
    !uri ||
    uri
      .replace(ATTR_WHITESPACE, '')
      .match(new RegExp(`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, 'i'))
  );
}
const trimRange = (doc, from, to) => {
  while (from < to && doc.textBetween(from, from + 1, '') === '') {
    from += 1;
  }
  while (to > from && doc.textBetween(to - 1, to, '') === '') {
    to -= 1;
  }
  return { from, to };
};
function addLinkRelationship({ editor, href }) {
  const target = href;
  const type = 'hyperlink';
  try {
    const id = insertNewRelationship(target, type, editor);
    return id;
  } catch {
    return null;
  }
}
const trackInsertClass = 'track-insert';
const TrackInsert = Mark.create({
  name: TrackInsertMarkName,
  group: 'track',
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackInsertClass,
      },
    };
  },
  addAttributes() {
    return {
      id: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-id'),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            'data-id': attrs.id,
          };
        },
      },
      author: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-author'),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            'data-author': attrs.author,
          };
        },
      },
      authorEmail: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-authoremail'),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            'data-authoremail': attrs.authorEmail,
          };
        },
      },
      authorImage: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-authorimage'),
        renderDOM: (attrs) => {
          if (!attrs.authorImage) return {};
          return {
            'data-authorimage': attrs.authorImage,
          };
        },
      },
      date: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-date'),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            'data-date': attrs.date,
          };
        },
      },
      importedAuthor: {
        default: '',
        rendered: false,
      },
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
const trackDeleteClass = 'track-delete';
const TrackDelete = Mark.create({
  name: TrackDeleteMarkName,
  group: 'track',
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackDeleteClass,
      },
    };
  },
  addAttributes() {
    return {
      id: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-id'),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            'data-id': attrs.id,
          };
        },
      },
      author: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-author'),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            'data-author': attrs.author,
          };
        },
      },
      authorEmail: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-authoremail'),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            'data-authoremail': attrs.authorEmail,
          };
        },
      },
      authorImage: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-authorimage'),
        renderDOM: (attrs) => {
          if (!attrs.authorImage) return {};
          return {
            'data-authorimage': attrs.authorImage,
          };
        },
      },
      date: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-date'),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            'data-date': attrs.date,
          };
        },
      },
      importedAuthor: {
        default: '',
        rendered: false,
      },
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
const parseFormatList = (str) => {
  if (!str) return [];
  let formatList;
  try {
    formatList = JSON.parse(str);
  } catch {
    return [];
  }
  if (!Array.isArray(formatList)) {
    return [];
  }
  return formatList.filter((format) => Object.hasOwn(format, 'type') && Object.hasOwn(format, 'attrs'));
};
const trackFormatClass = 'track-format';
const TrackFormat = Mark.create({
  name: TrackFormatMarkName,
  group: 'track',
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackFormatClass,
      },
    };
  },
  addAttributes() {
    return {
      id: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-id'),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            'data-id': attrs.id,
          };
        },
      },
      author: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-author'),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            'data-author': attrs.author,
          };
        },
      },
      authorEmail: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-authoremail'),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            'data-authoremail': attrs.authorEmail,
          };
        },
      },
      authorImage: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-authorimage'),
        renderDOM: (attrs) => {
          if (!attrs.authorImage) return {};
          return {
            'data-authorimage': attrs.authorImage,
          };
        },
      },
      date: {
        default: '',
        parseDOM: (elem) => elem.getAttribute('data-date'),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            'data-date': attrs.date,
          };
        },
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      before: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute('data-before'));
        },
        renderDOM: (attrs) => {
          if (!attrs.before) return {};
          return {
            'data-before': JSON.stringify(attrs.before),
          };
        },
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      after: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute('data-after'));
        },
        renderDOM: (attrs) => {
          if (!attrs.after) return {};
          return {
            'data-after': JSON.stringify(attrs.after),
          };
        },
      },
      importedAuthor: {
        default: '',
        rendered: false,
      },
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ['span', Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
});
const PERMISSION_MAP = {
  accept: {
    own: 'RESOLVE_OWN',
    other: 'RESOLVE_OTHER',
  },
  reject: {
    own: 'REJECT_OWN',
    other: 'REJECT_OTHER',
  },
};
const buildKey = (change) => {
  const id = change.mark?.attrs?.id ?? `${change.from}-${change.to}`;
  return `${id}:${change.mark?.type?.name ?? 'unknown'}`;
};
const mergeChange = (bucket, change) => {
  const key2 = buildKey(change);
  const existing = bucket.get(key2);
  if (existing) {
    existing.from = Math.min(existing.from, change.from);
    existing.to = Math.max(existing.to, change.to);
    existing.segments.push({ from: change.from, to: change.to });
  } else {
    bucket.set(key2, {
      id: change.mark?.attrs?.id ?? null,
      type: change.mark?.type?.name ?? null,
      attrs: { ...(change.mark?.attrs ?? {}) },
      from: change.from,
      to: change.to,
      segments: [{ from: change.from, to: change.to }],
    });
  }
};
const collectTrackedChanges = ({ state, from, to }) => {
  if (!state) return [];
  const collapsed = from === to;
  const changes = getTrackChanges(state);
  if (!changes?.length) return [];
  const bucket = /* @__PURE__ */ new Map();
  changes.forEach((change) => {
    const overlaps = collapsed ? change.from <= from && change.to >= from : change.from < to && change.to > from;
    if (!overlaps) return;
    mergeChange(bucket, change);
  });
  return Array.from(bucket.values());
};
const derivePermissionKey = ({ action, isOwn }) => {
  const mapping = PERMISSION_MAP[action];
  if (!mapping) return null;
  return isOwn ? mapping.own : mapping.other;
};
const normalizeEmail = (value) => {
  if (typeof value !== 'string') return '';
  return value.trim().toLowerCase();
};
const resolveChanges = (editor) => {
  if (!editor) return { role: 'editor', isInternal: false, currentUser: null, resolver: null };
  const role = editor.options?.role ?? 'editor';
  const isInternal = Boolean(editor.options?.isInternal);
  const currentUser = editor.options?.user ?? null;
  const resolver = editor.options?.permissionResolver;
  return { role, isInternal, currentUser, resolver };
};
const isTrackedChangeActionAllowed = ({ editor, action, trackedChanges }) => {
  if (!trackedChanges?.length) return true;
  const { role, isInternal, currentUser, resolver } = resolveChanges(editor);
  if (typeof resolver !== 'function') return true;
  const currentEmail = normalizeEmail(currentUser?.email);
  return trackedChanges.every((change) => {
    const authorEmail = normalizeEmail(change.attrs?.authorEmail);
    const isOwn = !currentEmail || !authorEmail || currentEmail === authorEmail;
    const permission = derivePermissionKey({ action, isOwn });
    if (!permission) return true;
    const payload = {
      permission,
      role,
      isInternal,
      trackedChange: {
        id: change.id,
        type: change.type,
        attrs: change.attrs,
        from: change.from,
        to: change.to,
        segments: change.segments,
        commentId: change.id,
      },
      comment: change.comment ?? null,
    };
    return resolver(payload) !== false;
  });
};
const TrackChanges = Extension.create({
  name: 'trackChanges',
  addCommands() {
    return {
      acceptTrackedChangesBetween:
        (from, to) =>
        ({ state, dispatch, editor }) => {
          const trackedChanges = collectTrackedChanges({ state, from, to });
          if (!isTrackedChangeActionAllowed({ editor, action: 'accept', trackedChanges })) return false;
          let { tr, doc } = state;
          tr.setMeta('inputType', 'acceptReject');
          const map = new Mapping();
          doc.nodesBetween(from, to, (node, pos) => {
            if (node.marks && node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
              const deletionStep = new ReplaceStep(
                map.map(Math.max(pos, from)),
                map.map(Math.min(pos + node.nodeSize, to)),
                Slice.empty,
              );
              tr.step(deletionStep);
              map.appendMap(deletionStep.getMap());
            } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackInsertMarkName)) {
              const insertionMark = node.marks.find((mark) => mark.type.name === TrackInsertMarkName);
              tr.step(
                new RemoveMarkStep(
                  map.map(Math.max(pos, from)),
                  map.map(Math.min(pos + node.nodeSize, to)),
                  insertionMark,
                ),
              );
            } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackFormatMarkName)) {
              const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
              tr.step(
                new RemoveMarkStep(
                  map.map(Math.max(pos, from)),
                  map.map(Math.min(pos + node.nodeSize, to)),
                  formatChangeMark,
                ),
              );
            }
          });
          if (tr.steps.length) {
            dispatch(tr);
          }
          return true;
        },
      rejectTrackedChangesBetween:
        (from, to) =>
        ({ state, dispatch, editor }) => {
          const trackedChanges = collectTrackedChanges({ state, from, to });
          if (!isTrackedChangeActionAllowed({ editor, action: 'reject', trackedChanges })) return false;
          const { tr, doc } = state;
          tr.setMeta('inputType', 'acceptReject');
          const map = new Mapping();
          doc.nodesBetween(from, to, (node, pos) => {
            if (node.marks && node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
              const deletionMark = node.marks.find((mark) => mark.type.name === TrackDeleteMarkName);
              tr.step(
                new RemoveMarkStep(
                  map.map(Math.max(pos, from)),
                  map.map(Math.min(pos + node.nodeSize, to)),
                  deletionMark,
                ),
              );
            } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackInsertMarkName)) {
              const deletionStep = new ReplaceStep(
                map.map(Math.max(pos, from)),
                map.map(Math.min(pos + node.nodeSize, to)),
                Slice.empty,
              );
              tr.step(deletionStep);
              map.appendMap(deletionStep.getMap());
            } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackFormatMarkName)) {
              const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
              formatChangeMark.attrs.before.forEach((oldMark) => {
                tr.step(
                  new AddMarkStep(
                    map.map(Math.max(pos, from)),
                    map.map(Math.min(pos + node.nodeSize, to)),
                    state.schema.marks[oldMark.type].create(oldMark.attrs),
                  ),
                );
              });
              formatChangeMark.attrs.after.forEach((newMark) => {
                tr.step(
                  new RemoveMarkStep(
                    map.map(Math.max(pos, from)),
                    map.map(Math.min(pos + node.nodeSize, to)),
                    node.marks.find((mark) => mark.type.name === newMark.type),
                  ),
                );
              });
              tr.step(
                new RemoveMarkStep(
                  map.map(Math.max(pos, from)),
                  map.map(Math.min(pos + node.nodeSize, to)),
                  formatChangeMark,
                ),
              );
            }
          });
          if (tr.steps.length) {
            dispatch(tr);
          }
          return true;
        },
      acceptTrackedChange:
        ({ trackedChange }) =>
        ({ commands: commands2 }) => {
          const { start: from, end: to } = trackedChange;
          return commands2.acceptTrackedChangesBetween(from, to);
        },
      acceptTrackedChangeBySelection:
        () =>
        ({ state, commands: commands2 }) => {
          const { from, to } = state.selection;
          return commands2.acceptTrackedChangesBetween(from, to);
        },
      acceptTrackedChangeFromToolbar:
        () =>
        ({ state, commands: commands2 }) => {
          const commentsPluginState = CommentsPluginKey.getState(state);
          const activeThreadId = commentsPluginState?.activeThreadId;
          if (activeThreadId && commentsPluginState?.trackedChanges?.[activeThreadId]) {
            return commands2.acceptTrackedChangeById(activeThreadId);
          } else {
            return commands2.acceptTrackedChangeBySelection();
          }
        },
      acceptTrackedChangeById:
        (id) =>
        ({ state, tr, commands: commands2 }) => {
          const toResolve = getChangesByIdToResolve(state, id) || [];
          return toResolve
            .map(({ from, to }) => {
              let mappedFrom = tr.mapping.map(from);
              let mappedTo = tr.mapping.map(to);
              return commands2.acceptTrackedChangesBetween(mappedFrom, mappedTo);
            })
            .every((result) => result);
        },
      acceptAllTrackedChanges:
        () =>
        ({ state, commands: commands2 }) => {
          const from = 0,
            to = state.doc.content.size;
          return commands2.acceptTrackedChangesBetween(from, to);
        },
      rejectTrackedChangeById:
        (id) =>
        ({ state, tr, commands: commands2 }) => {
          const toReject = getChangesByIdToResolve(state, id) || [];
          return toReject
            .map(({ from, to }) => {
              let mappedFrom = tr.mapping.map(from);
              let mappedTo = tr.mapping.map(to);
              return commands2.rejectTrackedChangesBetween(mappedFrom, mappedTo);
            })
            .every((result) => result);
        },
      rejectTrackedChange:
        ({ trackedChange }) =>
        ({ commands: commands2 }) => {
          const { start: from, end: to } = trackedChange;
          return commands2.rejectTrackedChangesBetween(from, to);
        },
      rejectTrackedChangeOnSelection:
        () =>
        ({ state, commands: commands2 }) => {
          const { from, to } = state.selection;
          return commands2.rejectTrackedChangesBetween(from, to);
        },
      rejectTrackedChangeFromToolbar:
        () =>
        ({ state, commands: commands2 }) => {
          const commentsPluginState = CommentsPluginKey.getState(state);
          const activeThreadId = commentsPluginState?.activeThreadId;
          if (activeThreadId && commentsPluginState?.trackedChanges?.[activeThreadId]) {
            return commands2.rejectTrackedChangeById(activeThreadId);
          } else {
            return commands2.rejectTrackedChangeOnSelection();
          }
        },
      rejectAllTrackedChanges:
        () =>
        ({ state, commands: commands2 }) => {
          const from = 0,
            to = state.doc.content.size;
          return commands2.rejectTrackedChangesBetween(from, to);
        },
      toggleTrackChanges:
        () =>
        ({ state }) => {
          const trackChangeState = TrackChangesBasePluginKey.getState(state);
          if (trackChangeState === void 0) return false;
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'TRACK_CHANGES_ENABLE',
            value: !trackChangeState.isTrackChangesActive,
          });
          return true;
        },
      enableTrackChanges:
        () =>
        ({ state }) => {
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'TRACK_CHANGES_ENABLE',
            value: true,
          });
          return true;
        },
      disableTrackChanges:
        () =>
        ({ state }) => {
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'TRACK_CHANGES_ENABLE',
            value: false,
          });
          return true;
        },
      toggleTrackChangesShowOriginal:
        () =>
        ({ state }) => {
          const trackChangeState = TrackChangesBasePluginKey.getState(state);
          if (trackChangeState === void 0) return false;
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'SHOW_ONLY_ORIGINAL',
            value: !trackChangeState.onlyOriginalShown,
          });
          return true;
        },
      enableTrackChangesShowOriginal:
        () =>
        ({ state }) => {
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'SHOW_ONLY_ORIGINAL',
            value: true,
          });
          return true;
        },
      disableTrackChangesShowOriginal:
        () =>
        ({ state }) => {
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'SHOW_ONLY_ORIGINAL',
            value: false,
          });
          return true;
        },
      toggleTrackChangesShowFinal:
        () =>
        ({ state }) => {
          const trackChangeState = TrackChangesBasePluginKey.getState(state);
          if (trackChangeState === void 0) return false;
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'SHOW_ONLY_MODIFIED',
            value: !trackChangeState.onlyModifiedShown,
          });
          return true;
        },
      enableTrackChangesShowFinal:
        () =>
        ({ state }) => {
          state.tr.setMeta(TrackChangesBasePluginKey, {
            type: 'SHOW_ONLY_MODIFIED',
            value: true,
          });
          return true;
        },
    };
  },
  addPmPlugins() {
    return [TrackChangesBasePlugin()];
  },
});
const getChangesByIdToResolve = (state, id) => {
  const trackedChanges = getTrackChanges(state);
  const changeIndex = trackedChanges.findIndex(({ mark }) => mark.attrs.id === id);
  if (changeIndex === -1) return;
  const matchingChange = trackedChanges[changeIndex];
  const matchingId = matchingChange.mark.attrs.id;
  const getSegmentSize = ({ from, to }) => to - from;
  const areDirectlyConnected = (left, right) => {
    if (!left || !right) {
      return false;
    }
    if (left.to !== right.from) {
      return false;
    }
    const hasContentBetween =
      state.doc.textBetween(left.from, right.to, '\n').length > getSegmentSize(left) + getSegmentSize(right);
    return !hasContentBetween;
  };
  const isComplementaryPair = (firstType, secondType) =>
    (firstType === TrackDeleteMarkName && secondType === TrackInsertMarkName) ||
    (firstType === TrackInsertMarkName && secondType === TrackDeleteMarkName);
  const linkedBefore = [];
  const linkedAfter = [];
  const collectDirection = (direction, collection) => {
    let currentIndex = changeIndex;
    let currentChange = matchingChange;
    while (true) {
      const neighborIndex = currentIndex + direction;
      const neighbor = trackedChanges[neighborIndex];
      if (!neighbor) {
        break;
      }
      const [left, right] = direction < 0 ? [neighbor, currentChange] : [currentChange, neighbor];
      if (!areDirectlyConnected(left, right)) {
        break;
      }
      const sharesId = neighbor.mark.attrs.id === matchingId;
      const complementary = isComplementaryPair(currentChange.mark.type.name, neighbor.mark.type.name);
      if (!sharesId && !complementary) {
        break;
      }
      collection.push(neighbor);
      currentIndex = neighborIndex;
      currentChange = neighbor;
      if (!sharesId) {
        break;
      }
    }
  };
  collectDirection(-1, linkedBefore);
  collectDirection(1, linkedAfter);
  return [matchingChange, ...linkedAfter, ...linkedBefore];
};
const TextTransform = Extension.create({
  name: 'textTransform',
  addOptions() {
    return {
      types: ['textStyle'],
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {string} [textTransform] - Text transform value (uppercase, lowercase, capitalize, none)
           */
          textTransform: {
            default: null,
            renderDOM: (attrs) => {
              if (!attrs.textTransform) return {};
              return {
                style: `text-transform: ${attrs.textTransform}`,
              };
            },
          },
        },
      },
    ];
  },
});
const Placeholder = Extension.create({
  name: 'placeholder',
  addOptions() {
    return {
      placeholder: 'Type something...',
    };
  },
  addPmPlugins() {
    const applyDecoration = (state) => {
      const plainText = state.doc.textBetween(0, state.doc.content.size, ' ', ' ');
      if (plainText !== '') return DecorationSet.empty;
      const { $from } = state.selection;
      const decoration = Decoration.node($from.before(), $from.after(), {
        'data-placeholder': this.options.placeholder,
        class: 'sd-editor-placeholder',
      });
      return DecorationSet.create(state.doc, [decoration]);
    };
    const placeholderPlugin = new Plugin({
      key: new PluginKey('placeholder'),
      state: {
        init: (_, state) => {
          return applyDecoration(state);
        },
        apply: (tr, oldValue, oldState, newState) => {
          return applyDecoration(newState);
        },
      },
      props: {
        decorations(state) {
          return this.getState(state);
        },
      },
    });
    return [placeholderPlugin];
  },
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
const _hoisted_1 = ['onClick', 'onMouseenter'];
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 1 };
const _hoisted_5 = { key: 1 };
const _sfc_main = {
  __name: 'Mentions',
  props: {
    users: {
      type: Array,
      required: true,
    },
    mention: {
      type: String,
      default: '',
    },
    inserMention: {
      type: Function,
      required: true,
    },
  },
  setup(__props) {
    const props = __props;
    const container = ref(null);
    const activeUserIndex = ref(null);
    const getFilteredUsers = computed(() => {
      const mention = props.mention.slice(1)?.toLowerCase();
      const filtered =
        props.users.filter((user) => {
          const isViewer = user.role === 'viewer';
          const userMatch = user.name?.toLowerCase().startsWith(mention);
          const emailMatch = user.email?.toLowerCase().startsWith(mention);
          return !isViewer && (userMatch || emailMatch);
        }) || [];
      return filtered;
    });
    const handleClick = (user) => {
      props.inserMention(user);
    };
    const handleKeydown = (event) => {
      if (event.key === 'ArrowDown') {
        activeUserIndex.value += 1;
        if (activeUserIndex.value === getFilteredUsers.value.length) {
          activeUserIndex.value = 0;
        }
      } else if (event.key === 'ArrowUp') {
        activeUserIndex.value -= 1;
        if (activeUserIndex.value < 0) {
          activeUserIndex.value = getFilteredUsers.value.length - 1;
        }
      } else if (event.key === 'Enter') {
        const user = getFilteredUsers.value[activeUserIndex.value];
        if (user) {
          props.inserMention(user);
        }
      }
    };
    const handleFocus = () => {
      activeUserIndex.value = 0;
    };
    return (_ctx, _cache) => {
      return (
        openBlock(),
        createElementBlock(
          'div',
          {
            class: 'mentions-container',
            ref_key: 'container',
            ref: container,
            onKeydown: withModifiers(handleKeydown, ['prevent']),
            onFocus: withModifiers(handleFocus, ['stop', 'prevent']),
            tabindex: '0',
          },
          [
            (openBlock(true),
            createElementBlock(
              Fragment$1,
              null,
              renderList(getFilteredUsers.value, (user, index) => {
                return (
                  openBlock(),
                  createElementBlock(
                    'div',
                    {
                      onClick: withModifiers(($event) => handleClick(user), ['stop', 'prevent']),
                      onMouseenter: ($event) => (activeUserIndex.value = index),
                      onMouseleave: _cache[0] || (_cache[0] = ($event) => (activeUserIndex.value = null)),
                      key: user.email,
                      class: normalizeClass(['user-row', { selected: activeUserIndex.value === index }]),
                    },
                    [
                      user.name
                        ? (openBlock(),
                          createElementBlock('div', _hoisted_2, [
                            user.name
                              ? (openBlock(),
                                createElementBlock(
                                  'span',
                                  _hoisted_3,
                                  toDisplayString(user.name),
                                  1,
                                  /* TEXT */
                                ))
                              : createCommentVNode('v-if', true),
                            user.name && user.email
                              ? (openBlock(),
                                createElementBlock(
                                  'span',
                                  _hoisted_4,
                                  ' (' + toDisplayString(user.email) + ')',
                                  1,
                                  /* TEXT */
                                ))
                              : createCommentVNode('v-if', true),
                          ]))
                        : (openBlock(),
                          createElementBlock('div', _hoisted_5, [
                            createElementVNode(
                              'span',
                              null,
                              toDisplayString(user.email),
                              1,
                              /* TEXT */
                            ),
                          ])),
                    ],
                    42,
                    _hoisted_1,
                  )
                );
              }),
              128,
              /* KEYED_FRAGMENT */
            )),
          ],
          544,
          /* NEED_HYDRATION, NEED_PATCH */
        )
      );
    };
  },
};
const Mentions = /* @__PURE__ */ _export_sfc(_sfc_main, [['__scopeId', 'data-v-bcae18cf']]);
const popoverPluginKey = new PluginKey('popoverPlugin');
const PopoverPlugin = Extension.create({
  name: 'popoverPlugin',
  addOptions() {
    return {};
  },
  addPmPlugins() {
    const popover = new Plugin({
      key: popoverPluginKey,
      state: {
        init: () => {
          return {};
        },
        apply: (tr, value) => {
          const newValue = { ...value };
          if (tr.docChanged || tr.selectionSet) {
            newValue.shouldUpdate = true;
          } else {
            newValue.shouldUpdate = false;
          }
          return newValue;
        },
      },
      view: (view) => {
        const popover2 = new Popover(view, this.editor);
        return {
          update: (view2, lastState) => {
            const pluginState = popoverPluginKey.getState(view2.state);
            if (!pluginState.shouldUpdate) return;
            popover2.update(view2, lastState);
          },
          destroy: () => {
            popover2.destroy();
          },
        };
      },
    });
    return [popover];
  },
});
class Popover {
  constructor(view, editor) {
    __publicField(this, 'handleKeyDown', (event) => {
      const isArrow = event.key === 'ArrowDown' || event.key === 'ArrowUp';
      if (this.tippyInstance.state.isVisible && isArrow) {
        event.preventDefault();
        this.popover.firstChild.focus();
      }
    });
    this.editor = editor;
    this.view = view;
    this.popover = document.createElement('div');
    this.popover.className = 'sd-editor-popover';
    applyStyleIsolationClass(this.popover);
    document.body.appendChild(this.popover);
    this.tippyInstance = tippy(this.popover, {
      trigger: 'manual',
      placement: 'bottom-start',
      interactive: true,
      appendTo: document.body,
      arrow: false,
      onShow: (instance) => {
        instance.setProps({ getReferenceClientRect: () => this.popoverRect });
        this.bindKeyDownEvents();
      },
      onHide: () => {
        this.unbindKeyDownEvents();
      },
      theme: 'sd-editor-popover',
    });
  }
  bindKeyDownEvents() {
    this.view.dom.addEventListener('keydown', this.handleKeyDown);
  }
  unbindKeyDownEvents() {
    this.view.dom.removeEventListener('keydown', this.handleKeyDown);
  }
  mountVueComponent(component, props = {}) {
    if (this.app) this.app.unmount();
    this.app = createApp(component, props);
    this.app.mount(this.popover);
    this.tippyInstance.setContent(this.popover);
  }
  update(view) {
    this.state = view.state;
    const showPopover = this.isShowMentions;
    let popoverContent = { component: null, props: null };
    if (this.isShowMentions) {
      const { from } = this.state.selection;
      const atMention = this.getMentionText(from);
      popoverContent = {
        component: Mentions,
        props: {
          users: this.editor.users,
          mention: atMention,
          inserMention: (user) => {
            const { $from } = this.state.selection;
            const length = atMention.length;
            const attributes = { ...user };
            const mentionNode = this.editor.schema.nodes.mention.create(attributes);
            const tr = this.state.tr.replaceWith($from.pos - length, $from.pos, mentionNode);
            this.editor.view.dispatch(tr);
            this.editor.view.focus();
          },
        },
      };
    }
    if (showPopover && popoverContent.component) {
      const { to } = this.state.selection;
      const { component, props } = popoverContent;
      this.mountVueComponent(component, props);
      this.showPopoverAtPosition(to);
    } else this.tippyInstance.hide();
  }
  showPopoverAtPosition(pos) {
    const end = this.view.coordsAtPos(pos);
    this.popoverRect = {
      width: 0,
      height: 0,
      top: end.bottom,
      left: end.left,
      bottom: end.bottom,
      right: end.left,
    };
    this.tippyInstance.show();
  }
  getMentionText(from) {
    const maxLookBehind = 20;
    const startPos = Math.max(0, from - maxLookBehind);
    const textBefore = this.state.doc.textBetween(startPos, from, '\n', '\0');
    const atIndex = textBefore.lastIndexOf('@');
    if (atIndex !== -1) return textBefore.substring(atIndex);
    return '';
  }
  get isShowMentions() {
    const { from } = this.state.selection;
    if (from < 1) return false;
    const textBefore = this.getMentionText(from);
    const mentionPattern = /(?:^|\s)@[\w]*$/;
    const match = textBefore.match(mentionPattern);
    return match && this.state.selection.empty;
  }
  destroy() {
    this.tippyInstance.destroy();
    this.popover.remove();
  }
}
const SEPARATOR_CLASS = 'pagination-separator';
const SEPARATOR_FLOATING_CLASS = 'pagination-separator-floating';
const isDebugging = false;
const cleanupFunctions = /* @__PURE__ */ new Set();
const Pagination = Extension.create({
  name: 'pagination',
  priority: 500,
  addStorage() {
    return {
      height: 0,
      sectionData: null,
      headerFooterEditors: /* @__PURE__ */ new Map(),
    };
  },
  addCommands() {
    const editor = this.editor;
    if (isHeadless(editor)) {
      return {};
    }
    return {
      insertPageBreak:
        () =>
        ({ commands: commands2 }) => {
          return commands2.insertContent({
            type: 'hardBreak',
          });
        },
      /**
       * Toggle pagination on/off
       * @returns {void}
       */
      togglePagination:
        () =>
        ({ tr, state, dispatch, editor: editor2 }) => {
          const isEnabled = PaginationPluginKey.getState(state)?.isEnabled;
          tr.setMeta(PaginationPluginKey, { isEnabled: !isEnabled });
          if (dispatch) {
            dispatch(tr);
            editor2.initDefaultStyles(editor2.element, !isEnabled);
            return true;
          }
        },
    };
  },
  addShortcuts() {
    const editor = this.editor;
    if (isHeadless(editor)) {
      return {};
    }
    return {
      'Mod-Enter': () => {
        return editor.commands.insertPageBreak();
      },
    };
  },
  /**
   * The pagination plugin is responsible for calculating page breaks, and redering them using decorations.
   */
  addPmPlugins() {
    const editor = this.editor;
    if (isHeadless(editor)) {
      return [];
    }
    let isUpdating = false;
    let shouldUpdate = false;
    let hasInitialized = false;
    let shouldInitialize = false;
    let paginationTimeout = null;
    const PAGINATION_DEBOUNCE_MS = 150;
    const paginationPlugin = new Plugin({
      key: PaginationPluginKey,
      state: {
        isReadyToInit: false,
        init() {
          return {
            isReadyToInit: false,
            decorations: DecorationSet.empty,
            isDebugging,
            isEnabled: editor.options.pagination && !isHeadless(editor),
          };
        },
        apply(tr, oldState, prevEditorState, newEditorState) {
          const meta = tr.getMeta(PaginationPluginKey);
          if (meta && 'isEnabled' in meta) {
            const newEnabled = meta.isEnabled;
            if (newEnabled) shouldUpdate = true;
            return {
              ...oldState,
              decorations: newEnabled ? oldState.decorations : DecorationSet.empty,
              isEnabled: newEnabled,
            };
          }
          if (meta && meta.isReadyToInit) {
            shouldUpdate = true;
            shouldInitialize = meta.isReadyToInit;
          }
          if (meta && meta.skipPagination) {
            return { ...oldState };
          }
          const syncMeta = tr.getMeta('y-sync$');
          const listSyncMeta = tr.getMeta('orderedListSync');
          if ((syncMeta && syncMeta.isChangeOrigin) || listSyncMeta) {
            return { ...oldState };
          }
          const imageRegistrationMetaType = getImageRegistrationMetaType(tr);
          if (imageRegistrationMetaType) {
            if (imageRegistrationMetaType === 'remove') {
              onImageLoad(editor);
            }
            return { ...oldState };
          }
          const isAnnotationUpdate = tr.getMeta('fieldAnnotationUpdate');
          if (isAnnotationUpdate) {
            return { ...oldState };
          }
          if (!shouldInitialize && !oldState.isReadyToInit) {
            return { ...oldState };
          }
          if (meta && meta.decorations) {
            shouldUpdate = true;
            return {
              ...oldState,
              decorations: meta.decorations.map(tr.mapping, tr.doc),
            };
          }
          const isForceUpdate = tr.getMeta('forceUpdatePagination');
          if (!isForceUpdate && prevEditorState.doc.eq(newEditorState.doc) && hasInitialized) {
            shouldUpdate = false;
            return { ...oldState };
          }
          if (!isForceUpdate && hasInitialized && tr.docChanged) {
            let isMarkOnlyChange = true;
            tr.steps.forEach((step) => {
              if (step.jsonID !== 'addMark' && step.jsonID !== 'removeMark') {
                isMarkOnlyChange = false;
              }
            });
            if (isMarkOnlyChange) {
              shouldUpdate = false;
              return { ...oldState };
            }
          }
          shouldUpdate = true;
          if (isForceUpdate) shouldUpdate = true;
          return {
            ...oldState,
            decorations: meta?.decorations?.map(tr.mapping, tr.doc) || oldState.decorations.map(tr.mapping, tr.doc),
            isReadyToInit: shouldInitialize,
          };
        },
      },
      /* The view method is the most important part of the plugin */
      view: () => {
        let previousDecorations = DecorationSet.empty;
        return {
          update: (view) => {
            if (isHeadless(editor)) return;
            if (!PaginationPluginKey.getState(view.state)?.isEnabled) return;
            if (!shouldUpdate || isUpdating) return;
            const performPaginationUpdate = () => {
              if (!shouldUpdate) return;
              isUpdating = true;
              hasInitialized = true;
              performUpdate(editor, view, previousDecorations);
              isUpdating = false;
              shouldUpdate = false;
            };
            if (!hasInitialized) {
              performPaginationUpdate();
              return;
            }
            if (paginationTimeout) {
              clearTimeout(paginationTimeout);
            }
            paginationTimeout = setTimeout(performPaginationUpdate, PAGINATION_DEBOUNCE_MS);
          },
        };
      },
      props: {
        decorations(state) {
          if (isHeadless(editor)) return DecorationSet.empty;
          const pluginState = PaginationPluginKey.getState(state);
          return pluginState.isEnabled ? pluginState.decorations : DecorationSet.empty;
        },
      },
    });
    return [paginationPlugin];
  },
  onDestroy() {
    cleanupFloatingSeparators();
    const { headerFooterEditors } = this.editor.storage.pagination;
    if (headerFooterEditors) {
      headerFooterEditors.clear();
    }
  },
});
const getHeaderFooterId = (currentPageNumber, sectionType, editor, node = null) => {
  const { alternateHeaders } = editor.converter.pageStyles;
  const sectionIds = editor.converter[sectionType];
  if (node && node.attrs?.paragraphProperties?.sectPr) {
    const sectPr = node.attrs?.paragraphProperties?.sectPr;
    if (currentPageNumber === 1) {
      if (sectionType === 'headerIds') {
        const sectionData = sectPr?.elements?.find(
          (el) => el.name === 'w:headerReference' && el.attributes?.['w:type'] === 'first',
        );
        const newId = sectionData?.attributes?.['r:id'];
        return newId;
      } else if (sectionType === 'footerIds') {
        const sectionData = sectPr?.elements?.find(
          (el) => el.name === 'w:footerReference' && el.attributes?.['w:type'] === 'first',
        );
        const newId = sectionData?.attributes?.['r:id'];
        return newId;
      }
    }
  }
  if (sectionIds?.titlePg && !sectionIds.first && currentPageNumber === 1) return null;
  const even = sectionIds.even;
  const odd = sectionIds.odd;
  const first2 = sectionIds.first;
  const defaultHeader = sectionIds.default;
  if (sectionIds?.titlePg && first2 && currentPageNumber === 1) return first2;
  let sectionId = sectionIds.default;
  if (currentPageNumber === 1) sectionId = defaultHeader;
  if (alternateHeaders) {
    if (currentPageNumber === 1) sectionId = first2;
    if (currentPageNumber % 2 === 0) sectionId = even || defaultHeader;
    else sectionId = odd || defaultHeader;
  }
  return sectionId;
};
const performUpdate = (editor, view, previousDecorations) => {
  const sectionData = editor.storage.pagination.sectionData;
  const newDecorations = calculatePageBreaks(view, editor, sectionData);
  const editorElement = editor.options.element;
  if (!previousDecorations.eq(newDecorations)) {
    const updateTransaction = view.state.tr.setMeta(PaginationPluginKey, { decorations: newDecorations });
    view.dispatch(updateTransaction);
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        cleanupFloatingSeparators();
        const separators = [...editorElement.querySelectorAll(`.${SEPARATOR_CLASS}--table`)];
        separators.forEach((separator) => {
          const { cleanup } = createFloatingSeparator(separator, editor);
          cleanupFunctions.add(cleanup);
        });
      });
    });
  }
  editor.emit('paginationUpdate');
};
const calculatePageBreaks = (view, editor, sectionData) => {
  if (!editor.converter) return DecorationSet.empty;
  const pageSize = editor.converter.pageStyles?.pageSize;
  if (!pageSize) return DecorationSet.empty;
  const { width, height } = pageSize;
  if (!width || !height) return DecorationSet.empty;
  const ignorePlugins = [CollaborationPluginKey, PaginationPluginKey];
  const { state } = view;
  const cleanState = EditorState.create({
    schema: state.schema,
    doc: state.doc,
    plugins: state.plugins.filter((plugin) => ignorePlugins.includes(plugin.key)),
  });
  const tempContainer = editor.options.element.cloneNode();
  if (!tempContainer) return [];
  tempContainer.className = 'temp-container super-editor';
  applyStyleIsolationClass(tempContainer);
  const HIDDEN_EDITOR_OFFSET_TOP = 0;
  const HIDDEN_EDITOR_OFFSET_LEFT = 0;
  tempContainer.style.left = HIDDEN_EDITOR_OFFSET_TOP + 'px';
  tempContainer.style.top = HIDDEN_EDITOR_OFFSET_LEFT + 'px';
  tempContainer.style.position = 'fixed';
  tempContainer.style.visibility = 'hidden';
  document.body.appendChild(tempContainer);
  const tempView = new EditorView(tempContainer, {
    state: cleanState,
    dispatchTransaction: () => {},
  });
  editor.initDefaultStyles(tempContainer);
  const decorations = generateInternalPageBreaks(cleanState.doc, tempView, editor, sectionData);
  tempView.destroy();
  document.body.removeChild(tempContainer);
  return DecorationSet.create(view.state.doc, decorations);
};
function generateInternalPageBreaks(doc, view, editor, sectionData) {
  const decorations = [];
  const { pageSize, pageMargins } = editor.converter.pageStyles;
  const pageHeight = pageSize.height * 96;
  let currentPageNumber = 1;
  let pageHeightThreshold = pageHeight;
  let footer = null,
    header = null;
  const firstHeaderId = getHeaderFooterId(currentPageNumber, 'headerIds', editor);
  const isFirstHeader = true;
  const firstHeader = createHeader(
    pageMargins,
    pageSize,
    sectionData,
    firstHeaderId,
    editor,
    currentPageNumber,
    isFirstHeader,
  );
  const pageBreak = createPageBreak({ editor, header: firstHeader, isFirstHeader: true });
  decorations.push(Decoration.widget(0, pageBreak, { key: 'stable-key' }));
  const lastFooterId = getHeaderFooterId(currentPageNumber, 'footerIds', editor);
  const isLastFooter = true;
  const lastFooter = createFooter(
    pageMargins,
    pageSize,
    sectionData,
    lastFooterId,
    editor,
    currentPageNumber,
    isLastFooter,
  );
  pageHeightThreshold -= firstHeader.headerHeight + lastFooter.footerHeight;
  let coords = view?.coordsAtPos(doc.content.size);
  if (!coords) return [];
  doc.descendants((node, pos) => {
    let currentNode = node;
    let currentPos = pos;
    coords = view?.coordsAtPos(currentPos);
    if (!coords) return;
    let isHardBreakNode = currentNode.type.name === 'hardBreak';
    let isListItemNode = currentNode.type.name === 'listItem';
    const endPos = currentPos + currentNode.nodeSize;
    const endCoords = view.coordsAtPos(endPos);
    let shouldAddPageBreak =
      currentNode.isBlock && isListItemNode
        ? endCoords && endCoords.bottom > pageHeightThreshold
        : coords.bottom > pageHeightThreshold;
    if (currentNode.type.name === 'tableRow' && currentNode.attrs?.cantSplit) {
      const rowTop = coords.top;
      const rowBottom = view.coordsAtPos(currentPos + currentNode.nodeSize).bottom;
      const remaining = pageHeightThreshold - rowTop;
      if (rowBottom - rowTop > remaining) {
        shouldAddPageBreak = true;
      }
    }
    const paragraphSectPrBreak = currentNode.attrs?.pageBreakSource;
    if (paragraphSectPrBreak === 'sectPr') {
      const nextNode = doc.nodeAt(currentPos + currentNode.nodeSize);
      const nextNodeSectPr = nextNode?.attrs?.pageBreakSource === 'sectPr';
      if (!nextNodeSectPr) isHardBreakNode = true;
      if (currentPageNumber === 1) {
        const headerId2 = getHeaderFooterId(currentPageNumber, 'headerIds', editor, currentNode);
        decorations.pop();
        const isFirstHeader2 = true;
        const newFirstHeader = createHeader(
          pageMargins,
          pageSize,
          sectionData,
          headerId2,
          editor,
          currentPageNumber,
          isFirstHeader2,
        );
        const pageBreak2 = createPageBreak({ editor, header: newFirstHeader, isFirstHeader: true });
        decorations.push(Decoration.widget(0, pageBreak2, { key: 'stable-key' }));
      }
    }
    if (currentNode.type.name === 'paragraph' && currentNode.attrs.styleId) {
      const linkedStyles = LinkedStylesPluginKey.getState(editor.state)?.styles;
      const style = linkedStyles?.find((style2) => style2.id === currentNode.attrs.styleId);
      if (style) {
        const { definition = {} } = style;
        const { pageBreakBefore, pageBreakAfter } = definition.attrs || {};
        if (pageBreakBefore || pageBreakAfter) shouldAddPageBreak = true;
      }
    }
    if (isHardBreakNode || shouldAddPageBreak) {
      const $currentPos = view.state.doc.resolve(currentPos);
      const table = findParentNodeClosestToPos($currentPos, (node2) => node2.type.name === 'table');
      const tableRow = findParentNodeClosestToPos($currentPos, (node2) => node2.type.name === 'tableRow');
      let isInTable2 = table || tableRow ? true : false;
      let {
        top: actualBreakTop,
        bottom: actualBreakBottom,
        pos: breakPos,
      } = getActualBreakCoords(view, currentPos, pageHeightThreshold);
      const $breakPos = view.state.doc.resolve(breakPos);
      if ($breakPos.parent.type.name === 'listItem') {
        breakPos = $breakPos.before($breakPos.depth);
      }
      const footerId2 = getHeaderFooterId(currentPageNumber, 'footerIds', editor, currentNode);
      currentPageNumber++;
      const headerId2 = getHeaderFooterId(currentPageNumber, 'headerIds', editor);
      header = createHeader(pageMargins, pageSize, sectionData, headerId2, editor, currentPageNumber - 1);
      footer = createFooter(pageMargins, pageSize, sectionData, footerId2, editor, currentPageNumber - 1);
      const bufferHeight2 = pageHeightThreshold - actualBreakBottom;
      const { node: spacingNode2 } = createFinalPagePadding(bufferHeight2);
      const pageSpacer2 = Decoration.widget(breakPos, spacingNode2, { key: 'stable-key' });
      decorations.push(pageSpacer2);
      const pageBreak2 = createPageBreak({ editor, header, footer, isInTable: isInTable2 });
      decorations.push(Decoration.widget(breakPos, pageBreak2, { key: 'stable-key' }));
      pageHeightThreshold = actualBreakBottom + (pageHeight - header.headerHeight - footer.footerHeight);
    }
  });
  let finalPos = doc.content.size;
  const lastNodeCoords = view.coordsAtPos(finalPos);
  const headerId = getHeaderFooterId(currentPageNumber, 'headerIds', editor);
  const footerId = getHeaderFooterId(currentPageNumber, 'footerIds', editor);
  header = createHeader(pageMargins, pageSize, sectionData, headerId, editor, currentPageNumber);
  footer = createFooter(pageMargins, pageSize, sectionData, footerId, editor, currentPageNumber);
  const bufferHeight = pageHeightThreshold - lastNodeCoords.bottom;
  const { node: spacingNode } = createFinalPagePadding(bufferHeight);
  const pageSpacer = Decoration.widget(doc.content.size, spacingNode, { key: 'stable-key' });
  decorations.push(pageSpacer);
  const footerBreak = createPageBreak({ editor, footer, isLastFooter: true });
  decorations.push(Decoration.widget(doc.content.size, footerBreak, { key: 'stable-key' }));
  decorations.forEach((decoration) => {
    const sectionContainer = decoration.type.toDOM;
    const totalPageNumber = sectionContainer?.querySelector('span[data-id="auto-total-pages"]');
    if (totalPageNumber) {
      const fontSize =
        totalPageNumber.previousElementSibling?.style?.fontSize || totalPageNumber.nextElementSibling?.style?.fontSize;
      if (fontSize) totalPageNumber.style.fontSize = fontSize;
      totalPageNumber.innerText = currentPageNumber;
    }
  });
  editor.currentTotalPages = currentPageNumber;
  return decorations;
}
function createFinalPagePadding(bufferHeight) {
  const div = document.createElement('div');
  div.className = 'pagination-page-spacer';
  div.style.userSelect = 'none';
  div.style.pointerEvents = 'none';
  div.style.height = bufferHeight + 'px';
  return { nodeHeight: bufferHeight, node: div };
}
function createHeader(pageMargins, pageSize, sectionData, headerId, editor, currentPageNumber, isFirstHeader = false) {
  const headerDef = sectionData?.headers?.[headerId];
  const minHeaderHeight = pageMargins.top * 96;
  const headerMargin = pageMargins.header * 96;
  const hasHeaderOffset = headerDef?.height > minHeaderHeight - headerMargin;
  const headerOffset = hasHeaderOffset ? headerMargin : 0;
  const headerHeight = Math.max(headerDef?.height || 0, minHeaderHeight) + headerOffset;
  const availableHeight = headerHeight - headerMargin;
  let editorContainer = document.createElement('div');
  if (!headerId && !editor?.converter?.headerIds?.['default']) {
    headerId = 'rId' + generateDocxRandomId();
    editor.converter.headerIds['default'] = headerId;
  }
  if (!editor.converter.headers[headerId]) {
    editor.converter.headers[headerId] = {
      type: 'doc',
      content: [{ type: 'paragraph', content: [] }],
    };
  }
  const data = editor.converter.headers[headerId];
  const pageNumberIndex = currentPageNumber - 1;
  const editorKey = getHeaderFooterEditorKey({ pageNumber: pageNumberIndex, isHeader: true, isFirstHeader });
  let editorSection = null;
  const { headerFooterEditors } = editor.storage.pagination;
  if (headerFooterEditors.has(editorKey) && editor.converter.headerEditors[pageNumberIndex]) {
    const editorData = headerFooterEditors.get(editorKey);
    editorSection = editorData.editor;
    editorContainer = editorSection.element;
  } else {
    editorSection = createHeaderFooterEditor({
      editor,
      data,
      editorContainer,
      appendToBody: false,
      sectionId: headerId,
      type: 'header',
      availableHeight,
      currentPageNumber,
    });
    editor.converter.headerEditors.push({ id: headerId, editor: editorSection });
    headerFooterEditors.set(editorKey, { editor: editorSection });
    broadcastEditorEvents(editor, editorSection);
  }
  editorSection.setEditable(false, false);
  editorContainer.classList.add('pagination-section-header');
  editorContainer.style.paddingTop = headerMargin + 'px';
  editorContainer.style.paddingLeft = pageMargins.left * 96 + 'px';
  editorContainer.style.paddingRight = pageMargins.right * 96 + 'px';
  editorContainer.style.height = headerHeight + 'px';
  editorContainer.style.width = pageSize.width * 96 + 'px';
  editorContainer.style.position = 'static';
  editorContainer.addEventListener('dblclick', () => onHeaderFooterDblClick(editor, editorSection));
  return {
    section: editorContainer,
    headerHeight,
  };
}
function createFooter(pageMargins, pageSize, sectionData, footerId, editor, currentPageNumber, isLastFooter = false) {
  const footerDef = sectionData?.footers?.[footerId];
  const minFooterHeight = pageMargins.bottom * 96;
  const footerPaddingFromEdge = pageMargins.footer * 96;
  const footerHeight = Math.max(footerDef?.height || 0, minFooterHeight - footerPaddingFromEdge);
  let editorContainer = document.createElement('div');
  if (!footerId && !editor.converter.footerIds['default']) {
    footerId = 'rId' + generateDocxRandomId();
    editor.converter.footerIds['default'] = footerId;
  }
  if (!editor.converter.footers[footerId]) {
    editor.converter.footers[footerId] = {
      type: 'doc',
      content: [{ type: 'paragraph', content: [] }],
    };
  }
  const data = editor.converter.footers[footerId];
  const pageNumberIndex = currentPageNumber - 1;
  const editorKey = getHeaderFooterEditorKey({ pageNumber: pageNumberIndex, isFooter: true, isLastFooter });
  let editorSection = null;
  const { headerFooterEditors } = editor.storage.pagination;
  if (headerFooterEditors.has(editorKey) && editor.converter.footerEditors[pageNumberIndex]) {
    const editorData = headerFooterEditors.get(editorKey);
    editorSection = editorData.editor;
    editorContainer = editorSection.element;
  } else {
    editorSection = createHeaderFooterEditor({
      editor,
      data,
      editorContainer,
      appendToBody: false,
      sectionId: footerId,
      type: 'footer',
      availableHeight: footerHeight,
      currentPageNumber,
    });
    editor.converter.footerEditors.push({ id: footerId, editor: editorSection });
    headerFooterEditors.set(editorKey, { editor: editorSection });
    broadcastEditorEvents(editor, editorSection);
  }
  editorSection.setEditable(false, false);
  editorContainer.classList.add('pagination-section-footer');
  editorContainer.style.height = footerHeight + 'px';
  editorContainer.style.marginBottom = footerPaddingFromEdge + 'px';
  editorContainer.style.paddingLeft = pageMargins.left * 96 + 'px';
  editorContainer.style.paddingRight = pageMargins.right * 96 + 'px';
  editorContainer.style.width = pageSize.width * 96 + 'px';
  editorContainer.style.position = 'static';
  editorContainer.addEventListener('dblclick', () => onHeaderFooterDblClick(editor, editorSection));
  return {
    section: editorContainer,
    footerHeight: footerHeight + footerPaddingFromEdge,
  };
}
const getHeaderFooterEditorKey = ({ pageNumber, isHeader, isFooter, isFirstHeader = false, isLastFooter = false }) => {
  if (isFirstHeader) return `first-header-${pageNumber}`;
  if (isLastFooter) return `last-footer-${pageNumber}`;
  if (isHeader) return `header-${pageNumber}`;
  if (isFooter) return `footer-${pageNumber}`;
  return void 0;
};
const onHeaderFooterDblClick = (editor, currentFocusedSectionEditor) => {
  if (isHeadless(editor) || editor.options.documentMode !== 'editing') return;
  editor.setEditable(false, false);
  toggleHeaderFooterEditMode({
    editor,
    focusedSectionEditor: currentFocusedSectionEditor,
    isEditMode: true,
    documentMode: editor.options.documentMode,
  });
};
function createPageBreak({
  editor,
  header,
  footer,
  footerBottom = null,
  isFirstHeader,
  isLastFooter,
  isInTable: isInTable2 = false,
}) {
  const { pageSize, pageMargins } = editor.converter.pageStyles;
  let sectionHeight = 0;
  const paginationDiv = document.createElement('div');
  paginationDiv.className = 'pagination-break-wrapper';
  const innerDiv = document.createElement('div');
  innerDiv.className = 'pagination-inner';
  innerDiv.style.width = pageSize.width * 96 - 1 + 'px';
  if (isFirstHeader) innerDiv.style.borderRadius = '8px 8px 0 0';
  else if (isLastFooter) innerDiv.style.borderRadius = '0 0 8px 8px';
  paginationDiv.appendChild(innerDiv);
  if (footer) {
    innerDiv.appendChild(footer.section);
    sectionHeight += footer.footerHeight;
  }
  if (header && footer) {
    const separatorHeight = 20;
    sectionHeight += separatorHeight;
    const separator = document.createElement('div');
    separator.classList.add(SEPARATOR_CLASS);
    if (isInTable2) {
      separator.classList.add(`${SEPARATOR_CLASS}--table`);
    }
    innerDiv.appendChild(separator);
  }
  if (header) {
    innerDiv.appendChild(header.section);
    sectionHeight += header.headerHeight;
  }
  paginationDiv.style.height = sectionHeight + 'px';
  paginationDiv.style.minHeight = sectionHeight + 'px';
  paginationDiv.style.maxHeight = sectionHeight + 'px';
  innerDiv.style.height = sectionHeight + 'px';
  paginationDiv.style.width = '100px';
  paginationDiv.style.marginLeft = pageMargins.left * -96 + 'px';
  if (footerBottom !== null) {
    paginationDiv.style.position = 'absolute';
    paginationDiv.style.bottom = footerBottom + 'px';
  }
  return paginationDiv;
}
function getActualBreakCoords(view, pos, calculatedThreshold) {
  let currentPos = pos - 1;
  const actualBreak = { top: 0, bottom: 0, pos: 0 };
  while (currentPos > 0) {
    const { top, bottom } = view.coordsAtPos(currentPos);
    if (bottom < calculatedThreshold) {
      Object.assign(actualBreak, { top, bottom, pos: currentPos + 1 });
      break;
    }
    currentPos--;
  }
  return actualBreak;
}
const onImageLoad = (editor) => {
  if (isHeadless(editor)) return;
  if (typeof requestAnimationFrame !== 'function') return;
  requestAnimationFrame(() => {
    const newTr = editor.view.state.tr;
    newTr.setMeta('forceUpdatePagination', true);
    editor.view.dispatch(newTr);
  });
};
function createFloatingSeparator(separator, editor) {
  const floatingSeparator = document.createElement('div');
  floatingSeparator.classList.add(SEPARATOR_FLOATING_CLASS);
  floatingSeparator.dataset.floatingSeparator = '';
  const editorElement = editor.options.element;
  editorElement.append(floatingSeparator);
  const updatePosition2 = () => {
    computePosition(separator, floatingSeparator, {
      strategy: 'absolute',
      placement: 'top-start',
      middleware: [
        hide(),
        {
          name: 'copy',
          fn: ({ elements }) => {
            const rect = elements.reference.getBoundingClientRect();
            const containerRect = editorElement.getBoundingClientRect();
            const scaleFactor = getScaleFactor(editorElement);
            const x = Math.round((rect.left - containerRect.left) / scaleFactor);
            const y = Math.round((rect.top - containerRect.top) / scaleFactor);
            const width = Math.round(rect.width / scaleFactor);
            const height = Math.round(rect.height / scaleFactor);
            return {
              x,
              y,
              data: { width, height },
            };
          },
        },
      ],
    }).then(({ x, y, middlewareData }) => {
      Object.assign(floatingSeparator.style, {
        top: `${y}px`,
        left: `${x}px`,
        width: `${middlewareData.copy.width}px`,
        height: `${middlewareData.copy.height}px`,
        visibility: middlewareData.hide?.referenceHidden ? 'hidden' : 'visible',
      });
    });
  };
  const cleanup = autoUpdate(separator, floatingSeparator, updatePosition2);
  const extendedCleanup = () => {
    floatingSeparator?.remove();
    cleanup();
  };
  return {
    cleanup: extendedCleanup,
    updatePosition: updatePosition2,
  };
}
function cleanupFloatingSeparators() {
  cleanupFunctions.forEach((cleanup) => cleanup());
  cleanupFunctions.clear();
}
function getScaleFactor(element) {
  let scale = 1;
  let currentElement = element;
  while (currentElement && currentElement !== document.documentElement) {
    let zoomStyle = currentElement.style.zoom;
    if (zoomStyle) {
      let zoom = parseFloat(zoomStyle) || 1;
      scale *= zoom;
    }
    let transformStyle = currentElement.style.transform;
    if (transformStyle) {
      let scaleMatch = transformStyle.match(/scale\(([^)]+)\)/);
      if (scaleMatch) {
        let scaleValue = parseFloat(scaleMatch[1]) || 1;
        scale *= scaleValue;
      }
    }
    currentElement = currentElement.parentElement;
  }
  return scale;
}
class SearchQuery {
  /**
    Create a query object.
    */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || '';
    this.valid = !!this.search && !(this.regexp && !validRegExp(this.search));
    this.wholeWord = !!config2.wholeWord;
    this.filter = config2.filter || null;
    this.impl = !this.valid ? nullQuery : this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
    Compare this query to another query.
    */
  eq(other) {
    return (
      this.search == other.search &&
      this.replace == other.replace &&
      this.caseSensitive == other.caseSensitive &&
      this.regexp == other.regexp &&
      this.wholeWord == other.wholeWord
    );
  }
  /**
    Find the next occurrence of this query in the given range.
    */
  findNext(state, from = 0, to = state.doc.content.size) {
    for (;;) {
      if (from >= to) return null;
      let result = this.impl.findNext(state, from, to);
      if (!result || this.checkResult(state, result)) return result;
      from = result.from + 1;
    }
  }
  /**
    Find the previous occurrence of this query in the given range.
    Note that, if `to` is given, it should be _less_ than `from`.
    */
  findPrev(state, from = state.doc.content.size, to = 0) {
    for (;;) {
      if (from <= to) return null;
      let result = this.impl.findPrev(state, from, to);
      if (!result || this.checkResult(state, result)) return result;
      from = result.to - 1;
    }
  }
  /**
    @internal
    */
  checkResult(state, result) {
    return (
      (!this.wholeWord || (checkWordBoundary(state, result.from) && checkWordBoundary(state, result.to))) &&
      (!this.filter || this.filter(state, result))
    );
  }
  /**
    @internal
    */
  unquote(string) {
    return this.literal
      ? string
      : string.replace(/\\([nrt\\])/g, (_, ch) => (ch == 'n' ? '\n' : ch == 'r' ? '\r' : ch == 't' ? '	' : '\\'));
  }
  /**
    Get the ranges that should be replaced for this result. This can
    return multiple ranges when `this.replace` contains
    `$1`/`$&`-style placeholders, in which case the preserved
    content is skipped by the replacements.
    
    Ranges are sorted by position, and `from`/`to` positions all
    refer to positions in `state.doc`. When applying these, you'll
    want to either apply them from back to front, or map these
    positions through your transaction's current mapping.
    */
  getReplacements(state, result) {
    let $from = state.doc.resolve(result.from);
    let marks = $from.marksAcross(state.doc.resolve(result.to));
    let ranges = [];
    let frag = Fragment.empty,
      pos = result.from,
      { match } = result;
    let groups = match ? getGroupIndices(match) : [[0, result.to - result.from]];
    let replParts = parseReplacement(this.unquote(this.replace));
    for (let part of replParts) {
      if (typeof part == 'string') {
        frag = frag.addToEnd(state.schema.text(part, marks));
      } else {
        const groupSpan = groups[part.group];
        if (!groupSpan) continue;
        let from = result.matchStart + groupSpan[0],
          to = result.matchStart + groupSpan[1];
        if (part.copy) {
          frag = frag.append(state.doc.slice(from, to).content);
        } else {
          if (frag != Fragment.empty || from > pos) {
            ranges.push({ from: pos, to: from, insert: new Slice(frag, 0, 0) });
            frag = Fragment.empty;
          }
          pos = to;
        }
      }
    }
    if (frag != Fragment.empty || pos < result.to)
      ranges.push({ from: pos, to: result.to, insert: new Slice(frag, 0, 0) });
    return ranges;
  }
}
const nullQuery = new (class {
  findNext() {
    return null;
  }
  findPrev() {
    return null;
  }
})();
class StringQuery {
  constructor(query) {
    this.query = query;
    let string = query.unquote(query.search);
    if (!query.caseSensitive) string = string.toLowerCase();
    this.string = string;
  }
  findNext(state, from, to) {
    return scanTextblocks(state.doc, from, to, (node, start) => {
      let off = Math.max(from, start);
      let content = textContent(node).slice(off - start, Math.min(node.content.size, to - start));
      let index = (this.query.caseSensitive ? content : content.toLowerCase()).indexOf(this.string);
      if (index < 0) return null;
      const startOffset = off - start;
      const absoluteIndex = startOffset + index;
      const fromPos = mapIndexToDocPos(node, start, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start, absoluteIndex + this.string.length);
      return { from: fromPos, to: toPos, match: null, matchStart: start };
    });
  }
  findPrev(state, from, to) {
    return scanTextblocks(state.doc, from, to, (node, start) => {
      let off = Math.max(start, to);
      let content = textContent(node).slice(off - start, Math.min(node.content.size, from - start));
      if (!this.query.caseSensitive) content = content.toLowerCase();
      let index = content.lastIndexOf(this.string);
      if (index < 0) return null;
      const startOffset = off - start;
      const absoluteIndex = startOffset + index;
      const fromPos = mapIndexToDocPos(node, start, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start, absoluteIndex + this.string.length);
      return { from: fromPos, to: toPos, match: null, matchStart: start };
    });
  }
}
const baseFlags = 'g' + (/x/.unicode == null ? '' : 'u') + (/x/.hasIndices == null ? '' : 'd');
class RegExpQuery {
  constructor(query) {
    this.query = query;
    this.regexp = new RegExp(query.search, baseFlags + (query.caseSensitive ? '' : 'i'));
  }
  findNext(state, from, to) {
    return scanTextblocks(state.doc, from, to, (node, start) => {
      let content = textContent(node).slice(0, Math.min(node.content.size, to - start));
      this.regexp.lastIndex = from - start;
      let match = this.regexp.exec(content);
      if (!match) return null;
      const absoluteIndex = match.index;
      const fromPos = mapIndexToDocPos(node, start, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start, absoluteIndex + match[0].length);
      return { from: fromPos, to: toPos, match, matchStart: start };
    });
  }
  findPrev(state, from, to) {
    return scanTextblocks(state.doc, from, to, (node, start) => {
      let content = textContent(node).slice(0, Math.min(node.content.size, from - start));
      let match;
      for (let off = 0; ; ) {
        this.regexp.lastIndex = off;
        let next = this.regexp.exec(content);
        if (!next) break;
        match = next;
        off = next.index + 1;
      }
      if (!match) return null;
      const absoluteIndex = match.index;
      const fromPos = mapIndexToDocPos(node, start, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start, absoluteIndex + match[0].length);
      return { from: fromPos, to: toPos, match, matchStart: start };
    });
  }
}
function getGroupIndices(match) {
  if (match.indices) return match.indices;
  let result = [[0, match[0].length]];
  for (let i = 1, pos = 0; i < match.length; i++) {
    let found = match[i] ? match[0].indexOf(match[i], pos) : -1;
    result.push(found < 0 ? void 0 : [found, (pos = found + match[i].length)]);
  }
  return result;
}
function parseReplacement(text) {
  let result = [],
    highestSeen = -1;
  function add(text2) {
    let last = result.length - 1;
    if (last > -1 && typeof result[last] == 'string') result[last] += text2;
    else result.push(text2);
  }
  while (text.length) {
    let m = /\$([$&\d+])/.exec(text);
    if (!m) {
      add(text);
      return result;
    }
    if (m.index > 0) add(text.slice(0, m.index + (m[1] == '$' ? 1 : 0)));
    if (m[1] != '$') {
      let n = m[1] == '&' ? 0 : +m[1];
      if (highestSeen >= n) {
        result.push({ group: n, copy: true });
      } else {
        highestSeen = n || 1e3;
        result.push({ group: n, copy: false });
      }
    }
    text = text.slice(m.index + m[0].length);
  }
  return result;
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch {
    return false;
  }
}
const TextContentCache = /* @__PURE__ */ new WeakMap();
const transparentInlineNodes = /* @__PURE__ */ new Set(['run', 'bookmarkStart']);
function textContent(node) {
  let cached = TextContentCache.get(node);
  if (cached) return cached;
  let content = '';
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i);
    if (child.isText) content += child.text;
    else if (child.isLeaf) content += '';
    else if (child.type && transparentInlineNodes.has(child.type.name)) content += textContent(child);
    else content += ' ' + textContent(child) + ' ';
  }
  TextContentCache.set(node, content);
  return content;
}
function mapIndexToDocPos(node, start, index) {
  if (index <= 0) return start;
  const fullTextLength = textContent(node).length;
  if (index >= fullTextLength) return start + node.content.size;
  return mapIndexWithinNode(node, start, index);
}
function mapIndexWithinNode(node, start, index) {
  if (index <= 0) return start;
  let offset = start;
  for (let i = 0; i < node.childCount; i++) {
    const child = node.child(i);
    const childStart = offset;
    if (child.isText) {
      const len = child.text.length;
      if (index <= len) return childStart + index;
      index -= len;
      offset += child.nodeSize;
      continue;
    }
    if (child.isLeaf) {
      if (index <= 1) return childStart + Math.min(index, 1);
      index -= 1;
      offset += child.nodeSize;
      continue;
    }
    const isTransparentInline = child.inlineContent && child.type && transparentInlineNodes.has(child.type.name);
    const innerTextLength = textContent(child).length;
    if (isTransparentInline) {
      if (index <= innerTextLength) return mapIndexWithinNode(child, childStart + 1, index);
      index -= innerTextLength;
      offset += child.nodeSize;
      continue;
    }
    const contribution = innerTextLength + 2;
    const relativeIndex = index - 1;
    if (relativeIndex < 0) return childStart;
    if (relativeIndex <= innerTextLength) {
      return mapIndexWithinNode(child, childStart + 1, relativeIndex);
    }
    if (relativeIndex === innerTextLength + 1) return childStart + child.nodeSize;
    index -= contribution;
    offset += child.nodeSize;
  }
  return start + node.content.size;
}
function scanTextblocks(node, from, to, f2, nodeStart = 0) {
  const isTransparentInline = node.inlineContent && node.type && transparentInlineNodes.has(node.type.name);
  if (node.inlineContent && !isTransparentInline) {
    return f2(node, nodeStart);
  } else if (!node.isLeaf) {
    if (from > to) {
      for (let i = node.childCount - 1, pos = nodeStart + node.content.size; i >= 0 && pos > to; i--) {
        let child = node.child(i);
        pos -= child.nodeSize;
        if (pos < from) {
          let result = scanTextblocks(child, from, to, f2, pos + 1);
          if (result != null) return result;
        }
      }
    } else {
      for (let i = 0, pos = nodeStart; i < node.childCount && pos < to; i++) {
        let child = node.child(i),
          start = pos;
        pos += child.nodeSize;
        if (pos > from) {
          let result = scanTextblocks(child, from, to, f2, start + 1);
          if (result != null) return result;
        }
      }
    }
  }
  return null;
}
function checkWordBoundary(state, pos) {
  let $pos = state.doc.resolve(pos);
  let before = $pos.nodeBefore,
    after = $pos.nodeAfter;
  if (!before || !after || !before.isText || !after.isText) return true;
  return !/\p{L}$/u.test(before.text) || !/^\p{L}/u.test(after.text);
}
class SearchState {
  constructor(query, range, deco) {
    this.query = query;
    this.range = range;
    this.deco = deco;
  }
}
function buildMatchDeco(state, query, range) {
  if (!query.valid) return DecorationSet.empty;
  let deco = [];
  let sel = state.selection;
  for (let pos = range ? range.from : 0, end = range ? range.to : state.doc.content.size; ; ) {
    let next = query.findNext(state, pos, end);
    if (!next) break;
    let cls =
      next.from == sel.from && next.to == sel.to ? 'ProseMirror-active-search-match' : 'ProseMirror-search-match';
    deco.push(Decoration.inline(next.from, next.to, { class: cls }));
    pos = next.to;
  }
  return DecorationSet.create(state.doc, deco);
}
const searchKey = new PluginKey('search');
function search(options = {}) {
  return new Plugin({
    key: searchKey,
    state: {
      init(_config, state) {
        let query = options.initialQuery || new SearchQuery({ search: '' });
        let range = options.initialRange || null;
        return new SearchState(query, range, buildMatchDeco(state, query, range));
      },
      apply(tr, search2, _oldState, state) {
        let set = tr.getMeta(searchKey);
        if (set) return new SearchState(set.query, set.range, buildMatchDeco(state, set.query, set.range));
        if (tr.docChanged || tr.selectionSet) {
          let range = search2.range;
          if (range) {
            let from = tr.mapping.map(range.from, 1);
            let to = tr.mapping.map(range.to, -1);
            range = from < to ? { from, to } : null;
          }
          search2 = new SearchState(search2.query, range, buildMatchDeco(state, search2.query, range));
        }
        return search2;
      },
    },
    props: {
      decorations: (state) => searchKey.getState(state).deco,
    },
  });
}
function getMatchHighlights(state) {
  let search2 = searchKey.getState(state);
  return search2 ? search2.deco : DecorationSet.empty;
}
function setSearchState(tr, query, range = null) {
  return tr.setMeta(searchKey, { query, range });
}
const isRegExp = (value) => Object.prototype.toString.call(value) === '[object RegExp]';
const Search = Extension.create({
  addStorage() {
    return {
      /**
       * @private
       * @type {SearchMatch[]|null}
       */
      searchResults: [],
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const storage = this.storage;
    const searchHighlightWithIdPlugin = new Plugin({
      key: new PluginKey('customSearchHighlights'),
      props: {
        decorations(state) {
          if (!editor) return null;
          const matches = storage?.searchResults;
          if (!matches?.length) return null;
          const decorations = matches.map((match) =>
            Decoration.inline(match.from, match.to, {
              id: `search-match-${match.id}`,
            }),
          );
          return DecorationSet.create(state.doc, decorations);
        },
      },
    });
    return [search(), searchHighlightWithIdPlugin];
  },
  addCommands() {
    return {
      /**
       * Navigate to the first search match
       * @category Command
       * @example
       * editor.commands.goToFirstMatch()
       * @note Scrolls editor to the first match from previous search
       */
      goToFirstMatch:
        () =>
        /** @returns {boolean} */
        ({ state, editor }) => {
          const highlights = getMatchHighlights(state);
          if (!highlights) return false;
          const decorations = highlights.find();
          if (!decorations?.length) return false;
          const firstMatch = decorations[0];
          const domPos = editor.view.domAtPos(firstMatch.from);
          domPos?.node?.scrollIntoView(true);
          return true;
        },
      /**
       * Search for string matches in editor content
       * @category Command
       * @param {String|RegExp} patternInput - Search string or pattern
       * @example
       * const matches = editor.commands.search('test string')
       * const regexMatches = editor.commands.search(/test/i)
       * @note Returns array of SearchMatch objects with positions and IDs
       */
      search:
        (patternInput) =>
        /** @returns {SearchMatch[]} */
        ({ state, dispatch }) => {
          let pattern;
          let caseSensitive = false;
          let regexp = false;
          const wholeWord = false;
          if (isRegExp(patternInput)) {
            const regexPattern =
              /** @type {RegExp} */
              patternInput;
            regexp = true;
            pattern = regexPattern.source;
            caseSensitive = !regexPattern.flags.includes('i');
          } else if (typeof patternInput === 'string' && /^\/(.+)\/([gimsuy]*)$/.test(patternInput)) {
            const [, body, flags] = patternInput.match(/^\/(.+)\/([gimsuy]*)$/);
            regexp = true;
            pattern = body;
            caseSensitive = !flags.includes('i');
          } else {
            pattern = String(patternInput);
          }
          const query = new SearchQuery({
            search: pattern,
            caseSensitive,
            regexp,
            wholeWord,
          });
          const tr = setSearchState(state.tr, query);
          dispatch(tr);
          const newState = state.apply(tr);
          const decoSet = getMatchHighlights(newState);
          const matches = decoSet ? decoSet.find() : [];
          const resultMatches = matches.map((d2) => ({
            from: d2.from,
            to: d2.to,
            text: newState.doc.textBetween(d2.from, d2.to),
            id: v4(),
          }));
          this.storage.searchResults = resultMatches;
          return resultMatches;
        },
      /**
       * Navigate to a specific search match
       * @category Command
       * @param {SearchMatch} match - Match object to navigate to
       * @example
       * const searchResults = editor.commands.search('test string')
       * editor.commands.goToSearchResult(searchResults[3])
       * @note Scrolls to match and selects it
       */
      goToSearchResult:
        (match) =>
        /** @returns {boolean} */
        ({ state, dispatch, editor }) => {
          const { from, to } = match;
          editor.view.focus();
          const tr = state.tr.setSelection(TextSelection.create(state.doc, from, to)).scrollIntoView();
          dispatch(tr);
          const { node } = editor.view.domAtPos(from);
          if (node?.scrollIntoView) {
            node.scrollIntoView({ block: 'center', inline: 'nearest' });
          }
          return true;
        },
    };
  },
});
const NodeResizerKey = new PluginKey('node-resizer');
const nodeResizer = (nodeNames = ['image'], editor) => {
  let resizeState = {
    dragging: false,
    startX: 0,
    startWidth: 0,
    handle: null,
    pos: null,
    resizableElement: null,
    aspectRatio: 1,
  };
  let resizeContainer = null;
  let editorView = null;
  let globalClickHandler = null;
  let globalMousedownHandler = null;
  let scrollHandler = null;
  let currentWrapper = null;
  return new Plugin({
    key: NodeResizerKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldState, _, newState) {
        if (tr.getMeta(NodeResizerKey)) {
          return oldState;
        }
        if (typeof document === 'undefined' || editor.options.isHeadless) return oldState;
        if (!editor.options.isHeaderOrFooter && (editor.options.documentMode === 'viewing' || !editor.isEditable)) {
          return DecorationSet.empty;
        }
        const { selection } = newState;
        const node = selection.node;
        if (!node || !nodeNames.includes(node.type.name)) {
          return DecorationSet.empty;
        }
        const decorations = [];
        if (nodeNames.includes(selection.node?.type.name)) {
          decorations.push(
            Decoration.node(selection.from, selection.to, {
              nodeName: 'span',
              class: 'sd-editor-resizable-wrapper',
              'data-pos': selection.from,
            }),
          );
        }
        return DecorationSet.create(newState.doc, decorations);
      },
    },
    props: {
      decorations(state) {
        return this.getState(state);
      },
    },
    view(view) {
      editorView = view;
      globalClickHandler = (event) => {
        if (
          !event.target.closest('.sd-editor-resizable-wrapper') &&
          !event.target.closest('.sd-editor-resize-container')
        ) {
          hideResizeHandles();
        }
      };
      document.addEventListener('click', globalClickHandler);
      globalMousedownHandler = (event) => {
        if (event.target.closest('.sd-editor-resize-handle')) {
          event.preventDefault();
          event.stopPropagation();
          startResize(editorView, event, event.target);
          return true;
        }
      };
      document.addEventListener('mousedown', globalMousedownHandler);
      scrollHandler = () => {
        if (currentWrapper && resizeContainer) {
          updateHandlePositions(currentWrapper.firstElementChild);
        }
      };
      window.addEventListener('scroll', scrollHandler, true);
      return {
        update(view2, prevState) {
          const { selection } = view2.state;
          const prevSelection = prevState.selection;
          if (selection.from !== prevSelection.from || selection.to !== prevSelection.to) {
            setTimeout(() => {
              const searchRoot = editorView?.dom;
              const selectedResizableWrapper = searchRoot?.querySelector('.sd-editor-resizable-wrapper');
              if (selectedResizableWrapper) {
                showResizeHandles(view2, selectedResizableWrapper);
              } else {
                hideResizeHandles();
              }
            }, 10);
          }
        },
        destroy() {
          hideResizeHandles();
          cleanupEventListeners();
          if (globalClickHandler) {
            document.removeEventListener('click', globalClickHandler);
            globalClickHandler = null;
          }
          if (globalMousedownHandler) {
            document.removeEventListener('mousedown', globalMousedownHandler);
            globalMousedownHandler = null;
          }
          if (scrollHandler) {
            window.removeEventListener('scroll', scrollHandler, true);
            scrollHandler = null;
          }
          editorView = null;
        },
      };
    },
  });
  function showResizeHandles(view, wrapper) {
    hideResizeHandles();
    const pos = Number.parseInt(wrapper.getAttribute('data-pos'), 10);
    const node = view.state.doc.nodeAt(pos);
    if (!nodeNames.includes(node?.type.name)) return;
    currentWrapper = wrapper;
    resizeContainer = document.createElement('div');
    resizeContainer.className = 'sd-editor-resize-container';
    resizeContainer.style.position = 'absolute';
    resizeContainer.style.pointerEvents = 'none';
    resizeContainer.style.zIndex = '1000';
    const handles = ['nw', 'ne', 'sw', 'se'];
    for (const handle of handles) {
      const handleEl = document.createElement('div');
      handleEl.className = `sd-editor-resize-handle sd-editor-resize-handle-${handle}`;
      handleEl.setAttribute('data-handle', handle);
      handleEl.setAttribute('data-pos', pos);
      handleEl.style.pointerEvents = 'auto';
      resizeContainer.appendChild(handleEl);
    }
    applyStyleIsolationClass(resizeContainer);
    document.body.appendChild(resizeContainer);
    updateHandlePositions(wrapper.firstElementChild);
  }
  function hideResizeHandles() {
    if (resizeContainer?.parentNode) {
      resizeContainer.parentNode.removeChild(resizeContainer);
      resizeContainer = null;
    }
    currentWrapper = null;
  }
  function updateHandlePositions(resizableElement) {
    if (!resizeContainer || !resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    resizeContainer.style.left = `${rect.left + scrollLeft}px`;
    resizeContainer.style.top = `${rect.top + scrollTop}px`;
    resizeContainer.style.width = `${rect.width}px`;
    resizeContainer.style.height = `${rect.height}px`;
  }
  function startResize(view, event, handleElement) {
    if (!view.hasFocus()) return;
    const handle = handleElement.getAttribute('data-handle');
    const pos = Number.parseInt(handleElement.getAttribute('data-pos'), 10);
    if (view.state.selection.from !== pos || !nodeNames.includes(view.state.selection.node?.type.name)) return;
    const resizableElement = view.nodeDOM(pos);
    if (!resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    resizeState = {
      dragging: true,
      startX: event.clientX,
      startY: event.clientY,
      startWidth: rect.width,
      startHeight: rect.height,
      handle,
      pos,
      resizableElement,
      aspectRatio: rect.width / rect.height,
    };
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    document.body.style.cursor = getResizeCursor(handle);
    document.body.style.userSelect = 'none';
  }
  function handleMouseMove(event) {
    if (!resizeState.dragging) return;
    event.preventDefault();
    event.stopPropagation();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes('w')) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    if (resizeState.resizableElement) {
      resizeState.resizableElement.style.width = `${newWidth}px`;
      resizeState.resizableElement.style.height = 'auto';
      updateHandlePositions(resizeState.resizableElement);
    }
  }
  function handleMouseUp(event) {
    if (!resizeState.dragging) return;
    cleanupEventListeners();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes('w')) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    const newHeight = newWidth / resizeState.aspectRatio;
    if (editorView && resizeState.pos < editorView.state.doc.content.size) {
      const tr = editorView.state.tr;
      const node = tr.doc.nodeAt(resizeState.pos);
      if (nodeNames.includes(node?.type.name)) {
        const attrs = {
          ...node.attrs,
          size: {
            ...node.attrs.size,
            width: Math.round(newWidth),
            height: Math.round(newHeight),
          },
        };
        tr.setNodeMarkup(resizeState.pos, null, attrs);
        tr.setMeta(NodeResizerKey, { action: 'resize' });
        editorView.dispatch(tr);
      }
    }
    resizeState = {
      dragging: false,
      startX: 0,
      startY: 0,
      startWidth: 0,
      startHeight: 0,
      handle: null,
      pos: null,
      resizableElement: null,
      aspectRatio: 1,
    };
  }
  function cleanupEventListeners() {
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  }
  function getResizeCursor(handle) {
    switch (handle) {
      case 'nw':
      case 'se':
        return 'nwse-resize';
      case 'ne':
      case 'sw':
        return 'nesw-resize';
      default:
        return 'default';
    }
  }
};
const NodeResizer = Extension.create({
  name: 'nodeResizer',
  addOptions() {
    return {};
  },
  addPmPlugins() {
    const isHeadless2 = this.editor.options.isHeadless;
    const hasDocument = typeof document !== 'undefined';
    if (isHeadless2 || !hasDocument) return [];
    return [nodeResizer(['image'], this.editor)];
  },
});
const getRichTextExtensions = () => {
  return [
    Bold,
    BulletList,
    Color,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    ListItem,
    LineHeight,
    Link,
    OrderedList,
    Paragraph,
    Strike,
    Text,
    TextAlign,
    TextIndent,
    TextStyle,
    Underline,
    Placeholder,
    PopoverPlugin,
    Mention,
    Highlight,
    FormatCommands,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    AiPlugin,
    Image,
    NodeResizer,
    CustomSelection,
  ];
};
const getStarterExtensions = () => {
  return [
    Bold,
    BlockNode,
    BulletList,
    Color,
    CommentRangeStart,
    CommentRangeEnd,
    CommentReference,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    ListItem,
    LineHeight,
    Link,
    OrderedList,
    Paragraph,
    LineBreak,
    HardBreak,
    Run,
    SlashMenu,
    Strike,
    TabNode,
    TableOfContents,
    Text,
    TextAlign,
    TextIndent,
    TextStyle,
    Underline,
    FormatCommands,
    CommentsPlugin,
    Gapcursor,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    Image,
    BookmarkStart,
    BookmarkEnd,
    Mention,
    Collaboration,
    CollaborationCursor,
    TrackChanges,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    CommentsMark,
    Pagination,
    Highlight,
    LinkedStyles,
    AiPlugin,
    AiMark,
    AiAnimationMark,
    AiLoaderNode,
    PageNumber,
    TotalPageCount,
    PageReference,
    ShapeContainer,
    ShapeTextbox,
    ContentBlock,
    Search,
    StructuredContent,
    StructuredContentBlock,
    StructuredContentCommands,
    DocumentSection,
    DocumentPartObject,
    NodeResizer,
    CustomSelection,
    TextTransform,
    VectorShape,
    ShapeGroup,
  ];
};
export { getStarterExtensions };
