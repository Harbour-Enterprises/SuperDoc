<script setup>
import '@harbour-enterprises/common/styles/common-styles.css';
import { getCurrentInstance, ref, onMounted, onBeforeUnmount, nextTick, computed, reactive } from 'vue'
import { storeToRefs } from 'pinia';

import PdfViewer from './components/PdfViewer/PdfViewer.vue';
import CommentsLayer from './components/CommentsLayer/CommentsLayer.vue';
import CommentDialog from '@/components/CommentsLayer/CommentDialog.vue';
import FloatingComments from '@/components/CommentsLayer/FloatingComments.vue';
import HrbrFieldsLayer from '@/components/HrbrFieldsLayer/HrbrFieldsLayer.vue';
import useSelection from '@/helpers/use-selection';

import { useSuperdocStore } from '@/stores/superdoc-store';
import { useCommentsStore } from '@/stores/comments-store';

import { DOCX, PDF, HTML } from '@harbour-enterprises/common';
import { SuperEditor } from '@harbour-enterprises/super-editor';
import HtmlViewer from './components/HtmlViewer/HtmlViewer.vue';
import useConversation from './components/CommentsLayer/use-conversation';
import useComment from './components/CommentsLayer/use-comment';

// Stores
const superdocStore = useSuperdocStore();
const commentsStore = useCommentsStore();
const emit = defineEmits(['selection-update']);

const {
  documents,
  isReady,
  documentContainers,
  areDocumentsReady,
  selectionPosition,
  activeSelection,
  activeZoom,
} = storeToRefs(superdocStore);
const { handlePageReady, modules, user, getDocument } = superdocStore;

// for html viewer
// union of all field classes
const fieldClasses = ['annotation'];
// union of all field properties regardless of type
const fieldFormat = {
    id: (field) => field.getAttribute('data-itemid') || null,
    value: (field) =>  field.querySelector('.annotation-text')?.innerHTML || null,
    type: (field) => field.getAttribute('data-itemfieldtype') || null
}

const {
  getConfig,
  documentsWithConverations,
  pendingComment,
  activeComment
} = storeToRefs(commentsStore);
const { initialCheck, showAddComment } = commentsStore;
const { proxy } = getCurrentInstance();
commentsStore.proxy = proxy;

// Refs
const layers = ref(null);

// Comments layer
const commentsLayer = ref(null);
const toolsMenuPosition = reactive({ top: null, right: '-25px', zIndex: 10 });

// Hrbr Fields
const hrbrFieldsLayer = ref(null);

const handlePdfReady = (documentId, container) => {
  const doc = getDocument(documentId);
  doc.isReady = true;
  doc.container = container;
  if (areDocumentsReady.value) {
    isReady.value = true;
    nextTick(() => initialCheck());
  }
}

const handleToolClick = (tool) => {
  const toolOptions = {
    comments: showAddComment,
  }

  if (tool in toolOptions) {
    toolOptions[tool](activeSelection.value, selectionPosition.value);
  }

  activeSelection.value = null;
  toolsMenuPosition.top = null;
}

const handleDocumentMouseDown = (e) => {
  if (pendingComment.value) return;
}

const handleHighlightClick = () => toolsMenuPosition.top = null;
const cancelPendingComment = (e) => {
  if (e.target.classList.contains('n-dropdown-option-body__label')) return;
}

const onCommentsLoaded = ({ comments }) => {
  proxy.$superdoc.log('[superdoc] onCommentsLoaded', comments);
  comments.forEach((c) => {
    const convo = useConversation(c);
    const doc = getDocument(c.documentId);
    doc.conversations.push(convo);
  })
  isReady.value = true;
};

const onEditorCreate = ({ editor }) => {
  const { documentId } = editor.options;
  const doc = getDocument(documentId);
  doc.setEditor(editor);
  proxy.$superdoc.activeEditor = editor;
  proxy.$superdoc.broadcastEditorCreate(editor);
  proxy.$superdoc.log('[Superdoc] Editor created', proxy.$superdoc.activeEditor);
  proxy.$superdoc.log('[Superdoc] Page styles (pixels)', editor.getPageStyles());
}

const onEditorDestroy = () => {
  proxy.$superdoc.broadcastEditorDestroy();
};

const onEditorFocus = ({ editor }) => {
  proxy.$superdoc.setActiveEditor(editor);
}

const onEditorSelectionChange = ({ editor, transaction }) => {
  const { documentId } = editor.options;
  const { $from, $to } = transaction.selection;
  if ($from.pos === $to.pos) {
    updateSelection({ x: null, y: null, x2: null, y2: null, source: 'super-editor' });
  }

  const layerBounds = layers.value.getBoundingClientRect();
  const bounds = getSelectionBoundingBox();
  const selectionBounds = {
    top: (bounds.top - layerBounds.top) / activeZoom.value,
    left: (bounds.left - layerBounds.left) / activeZoom.value,
    right: (bounds.right - layerBounds.left) / activeZoom.value,
    bottom: (bounds.bottom - layerBounds.top) / activeZoom.value,
  };

  const selection = useSelection({
    selectionBounds,
    page: 1,
    documentId,
    source: 'super-editor',
  });

  handleSelectionChange(selection);

  // TODO: Figure out why the selection is being undone here andwe need the delay
  setTimeout(() => {
    const { activeThreadId } = transaction.getMeta('commentsPluginState') || {};
    const document = getDocument(documentId);
    const convo = document.conversations.find((c) => c.thread == activeThreadId);
    activeComment.value = convo?.conversationId;
  }, 250);
};

const getTrackedChange = (commentData) => {
  const trackedChange = {};
  if (commentData.insertion) {
    trackedChange.insertion = commentData.insertion;
  } else if (commentData.deletion) {
    trackedChange.deletion = commentData.deletion;
  }
  return trackedChange;
}

const onEditorCommentsUpdate = ({ editor, transaction }) => {  
  const { documentId } = editor.options;
  const { commentPositions = {}, activeThreadId } = transaction.getMeta('commentsPluginState') || {};
  if (activeThreadId) onEditorSelectionChange({ editor, transaction });

  if (!Object.keys(commentPositions).length) return;

  const containerBounds = layers.value.getBoundingClientRect();
  const document = getDocument(documentId);

  Object.keys(commentPositions).forEach((threadId) => {    
    let convo = document.conversations.find((c) => c.thread == threadId);
    const commentData = commentPositions[threadId];

    if (!convo && commentData.type === 'trackedChange') {
      const selection = useSelection({
        page: 1,
          selectionBounds: commentPositions[threadId],
          documentId,
          source: 'super-editor',
        });

        const trackedChange = {};
        if (commentData.insertion) {
          trackedChange.insertion = commentData.insertion;
        } else if (commentData.deletion) {
          trackedChange.deletion = commentData.deletion;
        }
        const comment = useComment({
          id: threadId,
          trackedChange: getTrackedChange(commentData),
          user: {
            email: proxy.$superdoc.user.email,
            name: proxy.$superdoc.user.name,
          }
        });

      convo = useConversation({
        thread: threadId,
        isTrackedChange: true,
        documentId,
        comments: [comment],
        creatorEmail: proxy.$superdoc.user.email,
        creatorName: proxy.$superdoc.user.name,
        selection,
      });
      // console.debug('New conversation', convo);
      document.conversations.push(convo);
    } else if (commentData.type === 'trackedChange') {
      convo.comments[0].trackedChange = getTrackedChange(commentData);
    }

    const adjustedSelection = {
      top: commentPositions[threadId].top - containerBounds.top,
      left: commentPositions[threadId].left - containerBounds.left,
      right: commentPositions[threadId].right - containerBounds.left,
      bottom: commentPositions[threadId].bottom - containerBounds.top,
    };

    const newSelection = useSelection({
      selectionBounds: adjustedSelection,
      documentId,
      source: 'super-editor',
    });
    convo.selection = newSelection;
  });
}

function getSelectionBoundingBox() {
  const selection = window.getSelection();

  if (selection.rangeCount > 0) {
    const range = selection.getRangeAt(0);
    return range.getBoundingClientRect();
  }

  return null;
}

const onCommentClicked = ({ conversation }) => {
  const { conversationId } = conversation;
  activeComment.value = conversationId;
}

const editorOptions = computed(() => {
  return {
    user: proxy.$superdoc.user,
    onCreate: onEditorCreate,
    onDestroy: onEditorDestroy,
    onFocus: onEditorFocus,
    onSelectionUpdate: onEditorSelectionChange,
    onCommentsLoaded,
    onCommentClicked,
    onCommentsUpdate: onEditorCommentsUpdate,
    documentMode: proxy.$documentMode,
  }
});

const isCommentsEnabled = computed(() => 'comments' in modules);
const showCommentsSidebar = computed(() => {
  return pendingComment.value || (
         documentsWithConverations.value.length > 0
          && layers.value
          && isReady.value
          && isCommentsEnabled.value
        )
});

const showToolsFloatingMenu = computed(() => toolsMenuPosition.top && !getConfig.value?.readOnly)
const showActiveSelection = computed(() => !getConfig?.readOnly && selectionPosition.value)

onMounted(() => {
  if (isCommentsEnabled.value && !modules.comments.readOnly) {
    document.addEventListener('mousedown', handleDocumentMouseDown);
  }
});

onBeforeUnmount(() => {
  document.removeEventListener('mousedown', handleDocumentMouseDown);
});


const selectionLayer = ref(null);
const isDragging = ref(false);

const getSelectionPosition = computed(() => {
  if (!selectionPosition.value || selectionPosition.value.source === 'super-editor') {
    return { top: null, left: null, right: null, bottom: null };
  };

  const style = {
    zIndex: 500,
    borderRadius: '4px',
    top: selectionPosition.value.top + 'px',
    left: selectionPosition.value.left + 'px',
    height: selectionPosition.value.height + 'px',
    width: selectionPosition.value.width + 'px',
  }
  return style;
});

const handleSelectionChange = (selection) => {
  if (!selection.selectionBounds) return;

  const x = selection.selectionBounds.left;
  const y = selection.selectionBounds.top;
  const x2 = selection.selectionBounds.right;
  const y2 = selection.selectionBounds.bottom;
  updateSelection({ x, y, x2, y2, source: selection.source.value });

  activeSelection.value = selection

  // Place the tools menu at the level of the selection
  let top = selection.selectionBounds.top;
  if (selection.bottom - selection.selectionBounds.top < 0) {
    top = selection.selectionBounds.botton;
  }

  toolsMenuPosition.top = top - 20 + 'px';
}

const updateSelection = ({ x, y, x2, y2, source }) => {

  if (y != null) {
    selectionPosition.value.top = y;
    selectionPosition.value.height = 0;
  }
  if (x != null) {
    selectionPosition.value.left = x;
    selectionPosition.value.width = 0;
  }
  if (y2 != null) selectionPosition.value.height = y2 - selectionPosition.value.top;
  if (x2 != null) selectionPosition.value.width = x2 - selectionPosition.value.left;

  selectionPosition.value.source = source;
};

const handleSelectionStart = (e) => {
  selectionLayer.value.style.pointerEvents = 'auto';

  isDragging.value = true;
  const y = e.offsetY / activeZoom.value
  const x = e.offsetX / activeZoom.value
  updateSelection({ x, y, x2: 0, y2: 0 });
  selectionLayer.value.addEventListener('mousemove', handleDragMove);
};

const handleDragMove = (e) => {
  if (!isDragging.value) return;
  const y2 = e.offsetY / activeZoom.value;
  const x2 = e.offsetX / activeZoom.value;
  updateSelection({ x2, y2 })
};

const handleDragEnd = (e) => {
  if (!isDragging.value) return;
  selectionLayer.value.removeEventListener('mousemove', handleDragMove);

  const selection = useSelection({
    selectionBounds: {
      top: selectionPosition.value.top,
      left: selectionPosition.value.left,
      right: selectionPosition.value.left + selectionPosition.value.width,
      bottom: selectionPosition.value.top + selectionPosition.value.height,
    },
    documentId: documents.value[0].id,
  });
  handleSelectionChange(selection);
  selectionLayer.value.style.pointerEvents = 'none';
}

const handlePdfClick = (e) => {
  isDragging.value = true;
  handleSelectionStart(e);
}

</script>

<template>
<div class="superdoc">

  <div class="layers" ref="layers">

    <!-- Floating tools menu (shows up when user has text selection)-->
    <div  v-if="showToolsFloatingMenu" class="tools" :style="toolsMenuPosition">
      <i
          class="fas fa-comment fa-tool-icon"
          data-id="is-tool"
          @click.stop.prevent="handleToolClick('comments')"></i>
    </div>

    <div class="document">

      <div class="selection-layer" @mousedown="handleSelectionStart" @mouseup="handleDragEnd" ref="selectionLayer">
        <div :style="getSelectionPosition" class="sd-highlight sd-initial-highlight temp-selection"></div>
      </div>

      <!-- Fields layer -->
      <HrbrFieldsLayer
          v-if="'hrbr-fields' in modules && layers"
          :fields="modules['hrbr-fields']"
          class="comments-layer"
          style="z-index: 5; background-color: blue;"
          ref="hrbrFieldsLayer" />

      <!-- On-document comments layer -->
      <CommentsLayer
          class="comments-layer"
          v-if="showCommentsSidebar"
          style="z-index: 3;"
          ref="commentsLayer"
          :parent="layers"
          :user="user"
          @highlight-click="handleHighlightClick" />

      <div class="sub-document" v-for="doc in documents" :key="doc.id" ref="documentContainers">
        <!-- PDF renderer -->

        <PdfViewer
            v-if="doc.type === PDF"
            :document-data="doc"
            @selection-change="handleSelectionChange"
            @ready="handlePdfReady" 
            @bypass-selection="handlePdfClick" />

        <SuperEditor
            v-if="doc.type === DOCX"
            :file-source="doc.data"
            :document-id="doc.id"
            :options="{ ...editorOptions, id: doc.id }" />

          <!-- omitting field props -->
          <HtmlViewer
              v-if="doc.type === HTML"
              :file-source="doc.data"
              :document-id="doc.id" />
      </div>
    </div>
  </div>

    <div class="right-sidebar" v-if="showCommentsSidebar">
    <CommentDialog
        v-if="pendingComment"
        :data="pendingComment"
        :current-document="getDocument(pendingComment.documentId)"
        :user="user" 
        :parent="layers"
        v-click-outside="cancelPendingComment" />

    <FloatingComments
        v-if="isReady"
        v-for="doc in documentsWithConverations"
        :parent="layers"
        :current-document="doc" />

  </div>
</div>
</template>


<style scoped>
.selection-layer {
  position: absolute;
  min-height: 100%;
  min-width: 100%;
  z-index: 10;
  pointer-events: none;
}
.temp-selection {
  position: absolute;
}
/* Right sidebar drawer */
.right-sidebar {
  width: 320px;
  padding: 0 10px;
  min-height: 100%;
  position: relative;
  z-index: 100;
}
.fa-tool-icon {
  cursor: pointer;
}

/* General Styles */
.box-sizing, .layers {
  box-sizing: border-box;
}
.cursor-pointer, .tools .tool-icon, .toolbar-item {
  cursor: pointer;
}
.flex {
  display: flex;
}
.flex-column {
  flex-direction: column;
}
.flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Layer Styles */
.comments-layer {
  position: absolute;
  top: 0;
  height: 100%;
  position: relative;
}
.layers {
  position: relative;
}

/* Document Styles */
.docx {
  border: 1px solid #DFDFDF;
  pointer-events: auto;
}
.sub-document {
  position: relative;
}

/* Toolbar Styles */
.toolbar {
  height: 25px;
  background-color: #fff;
  margin-bottom: 5px;
}
.toolbar-item {
  width: 20px;
  height: 20px;
  border-radius: 8px;
  border: 1px solid #DBDBDB;
  padding: 3px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: all 250ms ease;
}
.toolbar-item:hover {
  background-color: #DBDBDB;
}

/* Tools Styles */
.tools {
  position: absolute;
  width: 50px;
  height: 50px;
  background-color: rgba(219, 219, 219, 0.6);
  border-radius: 12px;
  z-index: 9999999;
  display: flex;
  align-items: center;
  justify-content: center;
}
.tools .tool-icon {
  font-size: 20px;
  border-radius: 12px;
  border: none;
  outline: none;
  background-color: #DBDBDB;
}

@media (max-width: 768px) {
  .sub-document {
    max-width: 100%;
    overflow: hidden;
  }
  .right-sidebar {
    padding: 10px;
    width: 55px;
    position: relative;
  }
}
</style>
